.TH "INTRO" 3 "2009-02-26" "Man Page" "Tokyo Cabinet"


.SH FUNDAMENTAL SPECIFICATIONS OF TOKYO CABINET VERSION 1

.SH TABLE OF CONTENTS
Introduction
.br
Features
.br
Installation
.br
The Utility API
.br
The Hash Database API
.br
The B+ Tree Database API
.br
The Fixed\-length Database API
.br
The Table Database API
.br
The Abstract Database API
.br
License
.br

.SH INTRODUCTION
.PP
Tokyo Cabinet is a library of routines for managing a database.  The database is a simple data file containing records, each is a pair of a key and a value.  Every key and value is serial bytes with variable length.  Both binary data and character string can be used as a key and a value.  There is neither concept of data tables nor data types.  Records are organized in hash table, B+ tree, or fixed\-length array.
.PP
As for database of hash table, each key must be unique within a database, so it is impossible to store two or more records with a key overlaps.  The following access methods are provided to the database: storing a record with a key and a value, deleting a record by a key, retrieving a record by a key.  Moreover, traversal access to every key are provided, although the order is arbitrary.  These access methods are similar to ones of DBM (or its followers: NDBM and GDBM) library defined in the UNIX standard.  Tokyo Cabinet is an alternative for DBM because of its higher performance.
.PP
As for database of B+ tree, records whose keys are duplicated can be stored.  Access methods of storing, deleting, and retrieving are provided as with the database of hash table.  Records are stored in order by a comparison function assigned by a user.  It is possible to access each record with the cursor in ascending or descending order.  According to this mechanism, forward matching search for strings and range search for integers are realized.
.PP
As for database of fixed\-length array, records are stored with unique natural numbers.  It is impossible to store two or more records with a key overlaps.  Moreover, the length of each record is limited by the specified length.  Provided operations are the same as ones of hash database.
.PP
Table database is also provided as a variant of hash database.  Each record is identified by the primary key and has a set of named columns.  Although there is no concept of data schema, it is possible to search for records with complex conditions efficiently by using indexes of arbitrary columns.
.PP
Tokyo Cabinet is written in the C language, and provided as API of C, Perl, Ruby, Java, and Lua.  Tokyo Cabinet is available on platforms which have API conforming to C99 and POSIX.  Tokyo Cabinet is a free software licensed under the GNU Lesser General Public License.

.SH FEATURES
.PP
Tokyo Cabinet is the successor of QDBM and improves time and space efficiency.  This section describes the features of Tokyo Cabinet.

.SH THE DINOSAUR WING OF THE DBM FORKS
.PP
Tokyo Cabinet is developed as the successor of GDBM and QDBM on the following purposes.  They are achieved and Tokyo Cabinet replaces conventional DBM products.
.PP
.RS
improves space efficiency : smaller size of database file.
.br
improves time efficiency : faster processing speed.
.br
improves parallelism : higher performance in multi\-thread environment.
.br
improves usability : simplified API.
.br
improves robustness : database file is not corrupted even under catastrophic situation.
.br
supports 64\-bit architecture : enormous memory space and database file are available.
.br
.RE
.PP
As with QDBM, the following three restrictions of traditional DBM: a process can handle only one database, the size of a key and a value is bounded, a database file is sparse, are cleared.  Moreover, the following three restrictions of QDBM: the size of a database file is limited to 2GB, environments with different byte orders can not share a database file, only one thread can search a database at the same time, are cleared.
.PP
Tokyo Cabinet runs very fast.  For example, elapsed time to store 1 million records is 0.7 seconds for hash database, and 1.6 seconds for B+ tree database.  Moreover, the size of database of Tokyo Cabinet is very small.  For example, overhead for a record is 16 bytes for hash database, and 5 bytes for B+ tree database.  Furthermore, scalability of Tokyo Cabinet is great.  The database size can be up to 8EB (9.22e18 bytes).

.SH EFFECTIVE IMPLEMENTATION OF HASH DATABASE
.PP
Tokyo Cabinet uses hash algorithm to retrieve records.  If a bucket array has sufficient number of elements, the time complexity of retrieval is `O(1)'.  That is, time required for retrieving a record is constant, regardless of the scale of a database.  It is also the same about storing and deleting.  Collision of hash values is managed by separate chaining.  Data structure of the chains is binary search tree.  Even if a bucket array has unusually scarce elements, the time complexity of retrieval is `O(log n)'.
.PP
Tokyo Cabinet attains improvement in retrieval by loading RAM with the whole of a bucket array.  If a bucket array is on RAM, it is possible to access a region of a target record by about one path of file operations.  A bucket array saved in a file is not read into RAM with the `read' call but directly mapped to RAM with the `mmap' call.  Therefore, preparation time on connecting to a database is very short, and two or more processes can share the same memory map.
.PP
If the number of elements of a bucket array is about half of records stored within a database, although it depends on characteristic of the input, the probability of collision of hash values is about 56.7% (36.8% if the same, 21.3% if twice, 11.5% if four times, 6.0% if eight times).  In such case, it is possible to retrieve a record by two or less paths of file operations.  If it is made into a performance index, in order to handle a database containing one million of records, a bucket array with half a million of elements is needed.  The size of each element is 4 bytes.  That is, if 2M bytes of RAM is available, a database containing one million records can be handled.
.PP
Traditional DBM provides two modes of the storing operations: `insert' and `replace'.  In the case a key overlaps an existing record, the insert mode keeps the existing value, while the replace mode transposes it to the specified value.  In addition to the two modes, Tokyo Cabinet provides `concatenate' mode.  In the mode, the specified value is concatenated at the end of the existing value and stored.  This feature is useful when adding an element to a value as an array.
.PP
Generally speaking, while succession of updating, fragmentation of available regions occurs, and the size of a database grows rapidly.  Tokyo Cabinet deal with this problem by coalescence of dispensable regions and reuse of them, and featuring of optimization of a database.  When overwriting a record with a value whose size is greater than the existing one, it is necessary to remove the region to another position of the file.  Because the time complexity of the operation depends on the size of the region of a record, extending values successively is inefficient.  However, Tokyo Cabinet deal with this problem by alignment.  If increment can be put in padding, it is not necessary to remove the region.

.SH USEFUL IMPLEMENTATION OF B+ TREE DATABASE
.PP
Although B+ tree database is slower than hash database, it features ordering access to each record.  The order can be assigned by users.  Records of B+ tree are sorted and arranged in logical pages.  Sparse index organized in B tree that is multiway balanced tree are maintained for each page.  Thus, the time complexity of retrieval and so on is `O(log n)'.  Cursor is provided to access each record in order.  The cursor can jump to a position specified by a key and can step forward or backward from the current position.  Because each page is arranged as double linked list, the time complexity of stepping cursor is `O(1)'.
.PP
B+ tree database is implemented, based on above hash database.  Because each page of B+ tree is stored as each record of hash database, B+ tree database inherits efficiency of storage management of hash database.  Because the header of each record is smaller and alignment of each page is adjusted according to the page size, in most cases, the size of database file is cut by half compared to one of hash database.  Although operation of many pages are required to update B+ tree, QDBM expedites the process by caching pages and reducing file operations.  In most cases, because whole of the sparse index is cached on memory, it is possible to retrieve a record by one or less path of file operations.
.PP
Each pages of B+ tree can be stored with compressed.  Two compression method; Deflate of ZLIB and Block Sorting of BZIP2, are supported.  Because each record in a page has similar patterns, high efficiency of compression is expected due to the Lempel\-Ziv or the BWT algorithms.  In case handling text data, the size of a database is reduced to about 25%.  If the scale of a database is large and disk I/O is the bottleneck, featuring compression makes the processing speed improved to a large extent.

.SH NAIVE IMPLEMENTATION OF FIXED\-LENGTH DATABASE
.PP
Fixed\-length database has restrictions that each key should be a natural number and that the length of each value is limited.  However, time efficiency and space efficiency are higher than the other data structures as long as the use case is within the restriction.
.PP
Because the whole region of the database is mapped on memory by the `mmap' call and referred as a multidimensional array, the overhead related to the file I/O is minimized.  Due to this simple structure, fixed\-length database works faster than hash database, and its concurrency in multi\-thread environment is prominent.
.PP
The size of the database is proportional to the range of keys and the limit size of each value.  That is, the smaller the range of keys is or the smaller the length of each value is, the higher the space efficiency is.  For example, if the maximum key is 1000000 and the limit size of the value is 100 bytes, the size of the database will be about 100MB.  Because regions around referred records are only loaded on the RAM, you can increase the size of the database to the size of the virtual memory.

.SH FLEXIBLE IMPLEMENTATION OF TABLE DATABASE
.PP
Table database does not express simple key/value structure but expresses a structure like a table of relational database.  Each record is identified by the primary key and has a set of multiple columns named with arbitrary strings.  For example, a stuff in your company can be expressed by a record identified by the primary key of the employee ID number and structured by columns of his name, division, salary, and so on.  Unlike relational database, table database does not need to define any data schema and can contain records of various structures different from each other.
.PP
Table database supports query functions with not only the primary key but also with conditions about arbitrary columns.  Each column condition is composed of the name of a column and a condition expression.  Operators of full matching, forward matching, regular expression matching, and so on are provided for the string type.  Operators of full matching, range matching and so on are provided for the number type.  A query can contain multiple conditions.  The order of the result set can be specified as the ascending or descending order of strings or numbers.
.PP
You can create indexes for arbitrary columns to improve performance of search and sorting.  Although columns do not have data types, indexes have types for strings or numbers.  The query optimizer uses indexes in suitable way according to each query.  Indexes are implemented as different files of B+ tree database.

.SH PRACTICAL FUNCTIONALITY
.PP
Hash database and B+ tree database feature transaction mechanisms.  It is possible to commit a series of operations between the beginning and the end of the transaction in a lump, or to abort the transaction and perform rollback to the state before the transaction.  Two isolation levels are supported; serializable and read uncommitted.  Durability is secured by write ahead logging and shadow paging.
.PP
Tokyo Cabinet provides two modes to connect to a database: `reader' and `writer'.  A reader can perform retrieving but neither storing nor deleting.  A writer can perform all access methods.  Exclusion control between processes is performed when connecting to a database by file locking.  While a writer is connected to a database, neither readers nor writers can be connected.  While a reader is connected to a database, other readers can be connect, but writers can not.  According to this mechanism, data consistency is guaranteed with simultaneous connections in multitasking environment.
.PP
Functions of API of Tokyo cabinet are reentrant and available in multi\-thread environment.  Discrete database object can be operated in parallel entirely.  For simultaneous operations of the same database object, read\-write lock is used for exclusion control.  That is, while a writing thread is operating the database, other reading threads and writing threads are blocked.  However, while a reading thread is operating the database, reading threads are not blocked.

.SH SIMPLE BUT VARIOUS INTERFACES
.PP
Tokyo Cabinet provides simple API based on the object oriented design.  Every operation for database is encapsulated and published as lucid methods as `open' (connect), `close' (disconnect), `put' (insert), `out' (remove), `get' (retrieve), and so on.  Because the three of hash, B+ tree, and fixed\-length array database APIs are very similar with each other, porting an application from one to the other is easy.  Moreover, the abstract API is provided to handle these databases with the same interface.  Applications of the abstract API can determine the type of the database in runtime.
.PP
The utility API is also provided.  Such fundamental data structure as list and map are included.  And, some useful features; memory pool, string processing, encoding, are also included.
.PP
Six kinds of API; the utility API, the hash database API, the B+ tree database API, the fixed\-length database API, the table database API, and the abstract database API, are provided for the C language.  Command line interfaces are also provided corresponding to each API.  They are useful for prototyping, test, and debugging.  Except for C, Tokyo Cabinet provides APIs for Perl, Ruby, Java, and Lua.  APIs for other languages will hopefully be provided by third party.
.PP
In cases that multiple processes access a database at the same time or some processes access a database on a remote host, the remote service is useful.  The remote service is composed of a database server and its access library.  Applications can access the database server by using the remote database API.  The server implements HTTP and the memcached protocol partly so that client programs on almost all platforms can access the server easily.

.SH INSTALLATION
.PP
This section describes how to install Tokyo Cabinet with the source package.  As for a binary package, see its installation manual.

.SH PREPARATION
.PP
Tokyo Cabinet is available on UNIX\-like systems.  At least, the following environments are supported.
.PP
.RS
Linux 2.4 and later (x86\-32/x86\-64/PowerPC/Alpha/SPARC)
.br
Mac OS X 10.3 and later (x86\-32/x86\-64/PowerPC)
.br
.RE
.PP
\fBgcc\fR 3.1 or later and \fBmake\fR are required to install Tokyo Cabinet with the source package.  They are installed by default on Linux, FreeBSD and so on.
.PP
As Tokyo Cabinet depends on the following libraries, install them beforehand.
.PP
.RS
zlib : for loss\-less data compression.  1.2.3 or later is suggested.
.br
bzip2 : for loss\-less data compression.  1.0.5 or later is suggested.
.br
.RE

.SH INSTALLATION
.PP
When an archive file of Tokyo Cabinet is extracted, change the current working directory to the generated directory and perform installation.
.PP
Run the configuration script.
.PP
Build programs.
.PP
Perform self\-diagnostic test.
.PP
Install programs.  This operation must be carried out by the \fBroot\fR user.

.SH RESULT
.PP
When a series of work finishes, the following files will be installed.

.SH OPTIONS OF CONFIGURE
.PP
The following options can be specified with `\fB./configure\fR'.
.PP
.RS
\fB\-\-enable\-debug\fR : build for debugging.  Enable debugging symbols, do not perform optimization, and perform static linking.
.br
\fB\-\-enable\-devel\fR : build for development.  Enable debugging symbols, perform optimization, and perform dynamic linking.
.br
\fB\-\-enable\-profile\fR : build for profiling.  Enable profiling symbols, perform optimization, and perform dynamic linking.
.br
\fB\-\-enable\-static\fR : build by static linking.
.br
\fB\-\-enable\-fastest\fR : build for fastest run.
.br
\fB\-\-enable\-off64\fR : build with 64\-bit file offset on 32\-bit system.
.br
\fB\-\-enable\-swab\fR : build for swapping byte\-orders.
.br
\fB\-\-enable\-uyield\fR : build for detecting race conditions.
.br
\fB\-\-disable\-zlib\fR : build without ZLIB compression.
.br
\fB\-\-disable\-bzip\fR : build without BZIP2 compression.
.br
\fB\-\-disable\-pthread\fR : build without POSIX thread support.
.br
\fB\-\-disable\-shared\fR :  avoid to build shared libraries.
.br
.RE
.PP
`\fB\-\-prefix\fR' and other options are also available as with usual UNIX software packages.  If you want to install Tokyo Cabinet under `\fB/usr\fR' not `\fB/usr/local\fR', specify `\fB\-\-prefix=/usr\fR'.  As well, the library search path does not include `\fB/usr/local/lib\fR', it is necessary to set the environment variable `\fBLD_LIBRARY_PATH\fR' to include `\fB/usr/local/lib\fR' before running applications of Tokyo Cabinet.

.SH HOW TO USE THE LIBRARY
.PP
Tokyo Cabinet provides API of the C language and it is available by programs conforming to the C89 (ANSI C) standard or the C99 standard.  As the header files of Tokyo Cabinet are provided as `\fBtcutil.h\fR', `\fBtchdb.h\fR', `\fBtcbdb.h\fR', and `\fBtcadb.h\fR', applications should include one or more of them accordingly to use the API.  As the library is provided as `\fBlibtokyocabinet.a\fR' and `\fBlibtokyocabinet.so\fR' and they depends `\fBlibz.so\fR', `\fBlibrt.so\fR', `\fBlibpthread.so\fR', `\fBlibm.so\fR', and `\fBlibc.so\fR', linker options `\fB\-ltokyocabinet\fR', `\fB\-lz\fR', `\fB\-lbz2\fR', `\fB\-lrt\fR', `\fB\-lpthread\fR', `\fB\-lm\fR', and `\fB\-lc\fR' are required for build command.  A typical build command is the following.
.PP
You can also use Tokyo Cabinet in programs written in C++.  Because each header is wrapped in C linkage (`\fBextern "C"\fR' block), you can simply include them into your C++ programs.

.SH THE UTILITY API
.PP
The utility API is a set of routines to handle records on memory easily.  Especially, extensible string, array list, hash map, and ordered tree are useful.  See `\fBtcutil.h\fR' for the entire specification.

.SH DESCRIPTION
.PP
To use the utility API, include `\fBtcutil.h\fR' and related standard header files.  Usually, write the following description near the front of a source file.
.PP
.RS
.br
\fB#include <tcutil.h>\fR
.br
\fB#include <stdlib.h>\fR
.br
\fB#include <stdbool.h>\fR
.br
\fB#include <stdint.h>\fR
.RE
.PP
Objects whose type is pointer to `\fBTCXSTR\fR' are used for extensible string.  An extensible string object is created with the function `\fBtcxstrnew\fR' and is deleted with the function `\fBtcxstrdel\fR'.  Objects whose type is pointer to `\fBTCLIST\fR' are used for array list.  A list object is created with the function `\fBtclistnew\fR' and is deleted with the function `\fBtclistdel\fR'.  Objects whose type is pointer to `\fBTCMAP\fR' are used for hash map.  A map object is created with the function `\fBtcmapnew\fR' and is deleted with the function `\fBtcmapdel\fR'.  Objects whose type is pointer to `\fBTCTREE\fR' are used for ordered tree.  A tree object is created with the function `\fBtctreenew\fR' and is deleted with the function `\fBtctreedel\fR'.  To avoid memory leak, it is important to delete every object when it is no longer in use.

.SH API OF BASIC UTILITIES
.PP
The constant `tcversion' is the string containing the version information.
.PP
.RS
.br
\fBextern const char *tcversion;\fR
.RE
.PP
The variable `tcfatalfunc' is the pointer to the call back function for handling a fatal error.
.PP
.RS
.br
\fBextern void (*tcfatalfunc)(const char *);\fR
.RS
The argument specifies the error message.
.RE
.RS
The initial value of this variable is `NULL'.  If the value is `NULL', the default function is called when a fatal error occurs.  A fatal error occurs when memory allocation is failed.
.RE
.RE
.PP
The function `tcmalloc' is used in order to allocate a region on memory.
.PP
.RS
.br
\fBvoid *tcmalloc(size_t \fIsize\fB);\fR
.RS
`\fIsize\fR' specifies the size of the region.
.RE
.RS
The return value is the pointer to the allocated region.
.RE
.RS
This function handles failure of memory allocation implicitly.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tccalloc' is used in order to allocate a nullified region on memory.
.PP
.RS
.br
\fBvoid *tccalloc(size_t \fInmemb\fB, size_t \fIsize\fB);\fR
.RS
`\fInmemb\fR' specifies the number of elements.
.RE
.RS
`\fIsize\fR' specifies the size of each element.
.RE
.RS
The return value is the pointer to the allocated nullified region.
.RE
.RS
This function handles failure of memory allocation implicitly.  Because the region of the return value is allocated with the `calloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcrealloc' is used in order to re\-allocate a region on memory.
.PP
.RS
.br
\fBvoid *tcrealloc(void *\fIptr\fB, size_t \fIsize\fB);\fR
.RS
`\fIptr\fR' specifies the pointer to the region.
.RE
.RS
`\fIsize\fR' specifies the size of the region.
.RE
.RS
The return value is the pointer to the re\-allocated region.
.RE
.RS
This function handles failure of memory allocation implicitly.  Because the region of the return value is allocated with the `realloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcmemdup' is used in order to duplicate a region on memory.
.PP
.RS
.br
\fBvoid *tcmemdup(const void *\fIptr\fB, size_t \fIsize\fB);\fR
.RS
`\fIptr\fR' specifies the pointer to the region.
.RE
.RS
`\fIsize\fR' specifies the size of the region.
.RE
.RS
The return value is the pointer to the allocated region of the duplicate.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcstrdup' is used in order to duplicate a string on memory.
.PP
.RS
.br
\fBchar *tcstrdup(const void *\fIstr\fB);\fR
.RS
`\fIstr\fR' specifies the string.
.RE
.RS
The return value is the allocated string equivalent to the specified string.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcfree' is used in order to free a region on memory.
.PP
.RS
.br
\fBvoid tcfree(void *\fIptr\fB);\fR
.RS
`\fIptr\fR' specifies the pointer to the region.  If it is `NULL', this function has no effect.
.RE
.RS
Although this function is just a wrapper of `free' call, this is useful in applications using another package of the `malloc' series.
.RE
.RE

.SH API OF EXTENSIBLE STRING
.PP
The function `tcxstrnew' is used in order to create an extensible string object.
.PP
.RS
.br
\fBTCXSTR *tcxstrnew(void);\fR
.RS
The return value is the new extensible string object.
.RE
.RE
.PP
The function `tcxstrnew2' is used in order to create an extensible string object from a character string.
.PP
.RS
.br
\fBTCXSTR *tcxstrnew2(const char *\fIstr\fB);\fR
.RS
`\fIstr\fR' specifies the string of the initial content.
.RE
.RS
The return value is the new extensible string object containing the specified string.
.RE
.RE
.PP
The function `tcxstrnew3' is used in order to create an extensible string object with the initial allocation size.
.PP
.RS
.br
\fBTCXSTR *tcxstrnew3(int \fIasiz\fB);\fR
.RS
`\fIasiz\fR' specifies the initial allocation size.
.RE
.RS
The return value is the new extensible string object.
.RE
.RE
.PP
The function `tcxstrdup' is used in order to copy an extensible string object.
.PP
.RS
.br
\fBTCXSTR *tcxstrdup(const TCXSTR *\fIxstr\fB);\fR
.RS
`\fIxstr\fR' specifies the extensible string object.
.RE
.RS
The return value is the new extensible string object equivalent to the specified object.
.RE
.RE
.PP
The function `tcxstrdel' is used in order to delete an extensible string object.
.PP
.RS
.br
\fBvoid tcxstrdel(TCXSTR *\fIxstr\fB);\fR
.RS
`\fIxstr\fR' specifies the extensible string object.
.RE
.RS
Note that the deleted object and its derivatives can not be used anymore.
.RE
.RE
.PP
The function `tcxstrcat' is used in order to concatenate a region to the end of an extensible string object.
.PP
.RS
.br
\fBvoid tcxstrcat(TCXSTR *\fIxstr\fB, const void *\fIptr\fB, int \fIsize\fB);\fR
.RS
`\fIxstr\fR' specifies the extensible string object.
.RE
.RS
`\fIptr\fR' specifies the pointer to the region to be appended.
.RE
.RS
`\fIsize\fR' specifies the size of the region.
.RE
.RE
.PP
The function `tcxstrcat2' is used in order to concatenate a character string to the end of an extensible string object.
.PP
.RS
.br
\fBvoid tcxstrcat2(TCXSTR *\fIxstr\fB, const char *\fIstr\fB);\fR
.RS
`\fIxstr\fR' specifies the extensible string object.
.RE
.RS
`\fIstr\fR' specifies the string to be appended.
.RE
.RE
.PP
The function `tcxstrptr' is used in order to get the pointer of the region of an extensible string object.
.PP
.RS
.br
\fBconst void *tcxstrptr(const TCXSTR *\fIxstr\fB);\fR
.RS
`\fIxstr\fR' specifies the extensible string object.
.RE
.RS
The return value is the pointer of the region of the object.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.
.RE
.RE
.PP
The function `tcxstrsize' is used in order to get the size of the region of an extensible string object.
.PP
.RS
.br
\fBint tcxstrsize(const TCXSTR *\fIxstr\fB);\fR
.RS
`\fIxstr\fR' specifies the extensible string object.
.RE
.RS
The return value is the size of the region of the object.
.RE
.RE
.PP
The function `tcxstrclear' is used in order to clear an extensible string object.
.PP
.RS
.br
\fBvoid tcxstrclear(TCXSTR *\fIxstr\fB);\fR
.RS
`\fIxstr\fR' specifies the extensible string object.
.RE
.RS
The internal buffer of the object is cleared and the size is set zero.
.RE
.RE
.PP
The function `tcxstrprintf' is used in order to perform formatted output into an extensible string object.
.PP
.RS
.br
\fBvoid tcxstrprintf(TCXSTR *\fIxstr\fB, const char *\fIformat\fB, ...);\fR
.RS
`\fIxstr\fR' specifies the extensible string object.
.RE
.RS
`\fIformat\fR' specifies the printf\-like format string.  The conversion character `%' can be used with such flag characters as `s', `d', `o', `u', `x', `X', `c', `e', `E', `f', `g', `G', `@', `?', `b', and `%'.  `@' works as with `s' but escapes meta characters of XML.  `?' works as with `s' but escapes meta characters of URL.  `b' converts an integer to the string as binary numbers.  The other conversion character work as with each original.
.RE
.RS
The other arguments are used according to the format string.
.RE
.RE
.PP
The function `tcsprintf' is used in order to allocate a formatted string on memory.
.PP
.RS
.br
\fBchar *tcsprintf(const char *\fIformat\fB, ...);\fR
.RS
`\fIformat\fR' specifies the printf\-like format string.  The conversion character `%' can be used with such flag characters as `s', `d', `o', `u', `x', `X', `c', `e', `E', `f', `g', `G', `@', `?', `b', and `%'.  `@' works as with `s' but escapes meta characters of XML.  `?' works as with `s' but escapes meta characters of URL.  `b' converts an integer to the string as binary numbers.  The other conversion character work as with each original.
.RE
.RS
The other arguments are used according to the format string.
.RE
.RS
The return value is the pointer to the region of the result string.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE

.SH API OF ARRAY LIST
.PP
The function `tclistnew' is used in order to create a list object.
.PP
.RS
.br
\fBTCLIST *tclistnew(void);\fR
.RS
The return value is the new list object.
.RE
.RE
.PP
The function `tclistnew2' is used in order to create a list object with expecting the number of elements.
.PP
.RS
.br
\fBTCLIST *tclistnew2(int \fIanum\fB);\fR
.RS
`\fIanum\fR' specifies the number of elements expected to be stored in the list.
.RE
.RS
The return value is the new list object.
.RE
.RE
.PP
The function `tclistnew3' is used in order to create a list object with initial string elements.
.PP
.RS
.br
\fBTCLIST *tclistnew3(const char *\fIstr\fB, ...);\fR
.RS
`\fIstr\fR' specifies the string of the first element.
.RE
.RS
The other arguments are other elements.  They should be trailed by a `NULL' argument.
.RE
.RS
The return value is the new list object.
.RE
.RE
.PP
The function `tclistdup' is used in order to copy a list object.
.PP
.RS
.br
\fBTCLIST *tclistdup(const TCLIST *\fIlist\fB);\fR
.RS
`\fIlist\fR' specifies the list object.
.RE
.RS
The return value is the new list object equivalent to the specified object.
.RE
.RE
.PP
The function `tclistdel' is used in order to delete a list object.
.PP
.RS
.br
\fBvoid tclistdel(TCLIST *\fIlist\fB);\fR
.RS
`\fIlist\fR' specifies the list object.
.RE
.RS
Note that the deleted object and its derivatives can not be used anymore.
.RE
.RE
.PP
The function `tclistnum' is used in order to get the number of elements of a list object.
.PP
.RS
.br
\fBint tclistnum(const TCLIST *\fIlist\fB);\fR
.RS
`\fIlist\fR' specifies the list object.
.RE
.RS
The return value is the number of elements of the list.
.RE
.RE
.PP
The function `tclistval' is used in order to get the pointer to the region of an element of a list object.
.PP
.RS
.br
\fBconst void *tclistval(const TCLIST *\fIlist\fB, int \fIindex\fB, int *\fIsp\fB);\fR
.RS
`\fIlist\fR' specifies the list object.
.RE
.RS
`\fIindex\fR' specifies the index of the element.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
The return value is the pointer to the region of the value.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  If `index' is equal to or more than the number of elements, the return value is `NULL'.
.RE
.RE
.PP
The function `tclistval2' is used in order to get the string of an element of a list object.
.PP
.RS
.br
\fBconst char *tclistval2(const TCLIST *\fIlist\fB, int \fIindex\fB);\fR
.RS
`\fIlist\fR' specifies the list object.
.RE
.RS
`\fIindex\fR' specifies the index of the element.
.RE
.RS
The return value is the string of the value.
.RE
.RS
If `index' is equal to or more than the number of elements, the return value is `NULL'.
.RE
.RE
.PP
The function `tclistpush' is used in order to add an element at the end of a list object.
.PP
.RS
.br
\fBvoid tclistpush(TCLIST *\fIlist\fB, const void *\fIptr\fB, int \fIsize\fB);\fR
.RS
`\fIlist\fR' specifies the list object.
.RE
.RS
`\fIptr\fR' specifies the pointer to the region of the new element.
.RE
.RS
`\fIsize\fR' specifies the size of the region.
.RE
.RE
.PP
The function `tclistpush2' is used in order to add a string element at the end of a list object.
.PP
.RS
.br
\fBvoid tclistpush2(TCLIST *\fIlist\fB, const char *\fIstr\fB);\fR
.RS
`\fIlist\fR' specifies the list object.
.RE
.RS
`\fIstr\fR' specifies the string of the new element.
.RE
.RE
.PP
The function `tclistpop' is used in order to remove an element of the end of a list object.
.PP
.RS
.br
\fBvoid *tclistpop(TCLIST *\fIlist\fB, int *\fIsp\fB);\fR
.RS
`\fIlist\fR' specifies the list object.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
The return value is the pointer to the region of the removed element.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If the list is empty, the return value is `NULL'.
.RE
.RE
.PP
The function `tclistpop2' is used in order to remove a string element of the end of a list object.
.PP
.RS
.br
\fBchar *tclistpop2(TCLIST *\fIlist\fB);\fR
.RS
`\fIlist\fR' specifies the list object.
.RE
.RS
The return value is the string of the removed element.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If the list is empty, the return value is `NULL'.
.RE
.RE
.PP
The function `tclistunshift' is used in order to add an element at the top of a list object.
.PP
.RS
.br
\fBvoid tclistunshift(TCLIST *\fIlist\fB, const void *\fIptr\fB, int \fIsize\fB);\fR
.RS
`\fIlist\fR' specifies the list object.
.RE
.RS
`\fIptr\fR' specifies the pointer to the region of the new element.
.RE
.RS
`\fIsize\fR' specifies the size of the region.
.RE
.RE
.PP
The function `tclistunshift2' is used in order to add a string element at the top of a list object.
.PP
.RS
.br
\fBvoid tclistunshift2(TCLIST *\fIlist\fB, const char *\fIstr\fB);\fR
.RS
`\fIlist\fR' specifies the list object.
.RE
.RS
`\fIstr\fR' specifies the string of the new element.
.RE
.RE
.PP
The function `tclistshift' is used in order to remove an element of the top of a list object.
.PP
.RS
.br
\fBvoid *tclistshift(TCLIST *\fIlist\fB, int *\fIsp\fB);\fR
.RS
`\fIlist\fR' specifies the list object.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
The return value is the pointer to the region of the removed element.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If the list is empty, the return value is `NULL'.
.RE
.RE
.PP
The function `tclistshift2' is used in order to remove a string element of the top of a list object.
.PP
.RS
.br
\fBchar *tclistshift2(TCLIST *\fIlist\fB);\fR
.RS
`\fIlist\fR' specifies the list object.
.RE
.RS
The return value is the string of the removed element.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If the list is empty, the return value is `NULL'.
.RE
.RE
.PP
The function `tclistinsert' is used in order to add an element at the specified location of a list object.
.PP
.RS
.br
\fBvoid tclistinsert(TCLIST *\fIlist\fB, int \fIindex\fB, const void *\fIptr\fB, int \fIsize\fB);\fR
.RS
`\fIlist\fR' specifies the list object.
.RE
.RS
`\fIindex\fR' specifies the index of the new element.
.RE
.RS
`\fIptr\fR' specifies the pointer to the region of the new element.
.RE
.RS
`\fIsize\fR' specifies the size of the region.
.RE
.RS
If `index' is equal to or more than the number of elements, this function has no effect.
.RE
.RE
.PP
The function `tclistinsert2' is used in order to add a string element at the specified location of a list object.
.PP
.RS
.br
\fBvoid tclistinsert2(TCLIST *\fIlist\fB, int \fIindex\fB, const char *\fIstr\fB);\fR
.RS
`\fIlist\fR' specifies the list object.
.RE
.RS
`\fIindex\fR' specifies the index of the new element.
.RE
.RS
`\fIstr\fR' specifies the string of the new element.
.RE
.RS
If `index' is equal to or more than the number of elements, this function has no effect.
.RE
.RE
.PP
The function `tclistremove' is used in order to remove an element at the specified location of a list object.
.PP
.RS
.br
\fBvoid *tclistremove(TCLIST *\fIlist\fB, int \fIindex\fB, int *\fIsp\fB);\fR
.RS
`\fIlist\fR' specifies the list object.
.RE
.RS
`\fIindex\fR' specifies the index of the element to be removed.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
The return value is the pointer to the region of the removed element.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If `index' is equal to or more than the number of elements, no element is removed and the return value is `NULL'.
.RE
.RE
.PP
The function `tclistremove2' is used in order to remove a string element at the specified location of a list object.
.PP
.RS
.br
\fBchar *tclistremove2(TCLIST *\fIlist\fB, int \fIindex\fB);\fR
.RS
`\fIlist\fR' specifies the list object.
.RE
.RS
`\fIindex\fR' specifies the index of the element to be removed.
.RE
.RS
The return value is the string of the removed element.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If `index' is equal to or more than the number of elements, no element is removed and the return value is `NULL'.
.RE
.RE
.PP
The function `tclistover' is used in order to overwrite an element at the specified location of a list object.
.PP
.RS
.br
\fBvoid tclistover(TCLIST *\fIlist\fB, int \fIindex\fB, const void *\fIptr\fB, int \fIsize\fB);\fR
.RS
`\fIlist\fR' specifies the list object.
.RE
.RS
`\fIindex\fR' specifies the index of the element to be overwritten.
.RE
.RS
`\fIptr\fR' specifies the pointer to the region of the new content.
.RE
.RS
`\fIsize\fR' specifies the size of the new content.
.RE
.RS
If `index' is equal to or more than the number of elements, this function has no effect.
.RE
.RE
.PP
The function `tclistover2' is used in order to overwrite a string element at the specified location of a list object.
.PP
.RS
.br
\fBvoid tclistover2(TCLIST *\fIlist\fB, int \fIindex\fB, const char *\fIstr\fB);\fR
.RS
`\fIlist\fR' specifies the list object.
.RE
.RS
`\fIindex\fR' specifies the index of the element to be overwritten.
.RE
.RS
`\fIstr\fR' specifies the string of the new content.
.RE
.RS
If `index' is equal to or more than the number of elements, this function has no effect.
.RE
.RE
.PP
The function `tclistsort' is used in order to sort elements of a list object in lexical order.
.PP
.RS
.br
\fBvoid tclistsort(TCLIST *\fIlist\fB);\fR
.RS
`\fIlist\fR' specifies the list object.
.RE
.RE
.PP
The function `tclistlsearch' is used in order to search a list object for an element using liner search.
.PP
.RS
.br
\fBint tclistlsearch(const TCLIST *\fIlist\fB, const void *\fIptr\fB, int \fIsize\fB);\fR
.RS
`\fIlist\fR' specifies the list object.
.RE
.RS
`\fIptr\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIsize\fR' specifies the size of the region.
.RE
.RS
The return value is the index of a corresponding element or \-1 if there is no corresponding element.
.RE
.RS
If two or more elements correspond, the former returns.
.RE
.RE
.PP
The function `tclistbsearch' is used in order to search a list object for an element using binary search.
.PP
.RS
.br
\fBint tclistbsearch(const TCLIST *\fIlist\fB, const void *\fIptr\fB, int \fIsize\fB);\fR
.RS
`\fIlist\fR' specifies the list object.  It should be sorted in lexical order.
.RE
.RS
`\fIptr\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIsize\fR' specifies the size of the region.
.RE
.RS
The return value is the index of a corresponding element or \-1 if there is no corresponding element.
.RE
.RS
If two or more elements correspond, which returns is not defined.
.RE
.RE
.PP
The function `tclistclear' is used in order to clear a list object.
.PP
.RS
.br
\fBvoid tclistclear(TCLIST *\fIlist\fB);\fR
.RS
`\fIlist\fR' specifies the list object.
.RE
.RS
All elements are removed.
.RE
.RE
.PP
The function `tclistdump' is used in order to serialize a list object into a byte array.
.PP
.RS
.br
\fBvoid *tclistdump(const TCLIST *\fIlist\fB, int *\fIsp\fB);\fR
.RS
`\fIlist\fR' specifies the list object.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
The return value is the pointer to the region of the result serial region.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tclistload' is used in order to create a list object from a serialized byte array.
.PP
.RS
.br
\fBTCLIST *tclistload(const void *\fIptr\fB, int \fIsize\fB);\fR
.RS
`\fIptr\fR' specifies the pointer to the region of serialized byte array.
.RE
.RS
`\fIsize\fR' specifies the size of the region.
.RE
.RS
The return value is a new list object.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.
.RE
.RE

.SH API OF HASH MAP
.PP
The function `tcmapnew' is used in order to create a map object.
.PP
.RS
.br
\fBTCMAP *tcmapnew(void);\fR
.RS
The return value is the new map object.
.RE
.RE
.PP
The function `tcmapnew2' is used in order to create a map object with specifying the number of the buckets.
.PP
.RS
.br
\fBTCMAP *tcmapnew2(uint32_t \fIbnum\fB);\fR
.RS
`\fIbnum\fR' specifies the number of the buckets.
.RE
.RS
The return value is the new map object.
.RE
.RE
.PP
The function `tcmapnew3' is used in order to create a map object with initial string elements.
.PP
.RS
.br
\fBTCMAP *tcmapnew3(const char *\fIstr\fB, ...);\fR
.RS
`\fIstr\fR' specifies the string of the first element.
.RE
.RS
The other arguments are other elements.  They should be trailed by a `NULL' argument.
.RE
.RS
The return value is the new map object.
.RE
.RS
The key and the value of each record are situated one after the other.
.RE
.RE
.PP
The function `tcmapdup' is used in order to copy a map object.
.PP
.RS
.br
\fBTCMAP *tcmapdup(const TCMAP *\fImap\fB);\fR
.RS
`\fImap\fR' specifies the map object.
.RE
.RS
The return value is the new map object equivalent to the specified object.
.RE
.RE
.PP
The function `tcmapdel' is used in order to delete a map object.
.PP
.RS
.br
\fBvoid tcmapdel(TCMAP *\fImap\fB);\fR
.RS
`\fImap\fR' specifies the map object.
.RE
.RS
Note that the deleted object and its derivatives can not be used anymore.
.RE
.RE
.PP
The function `tcmapput' is used in order to store a record into a map object.
.PP
.RS
.br
\fBvoid tcmapput(TCMAP *\fImap\fB, const void *\fIkbuf\fB, int \fIksiz\fB, const void *\fIvbuf\fB, int \fIvsiz\fB);\fR
.RS
`\fImap\fR' specifies the map object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.
.RE
.RS
If a record with the same key exists in the map, it is overwritten.
.RE
.RE
.PP
The function `tcmapput2' is used in order to store a string record into a map object.
.PP
.RS
.br
\fBvoid tcmapput2(TCMAP *\fImap\fB, const char *\fIkstr\fB, const char *\fIvstr\fB);\fR
.RS
`\fImap\fR' specifies the map object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
`\fIvstr\fR' specifies the string of the value.
.RE
.RS
If a record with the same key exists in the map, it is overwritten.
.RE
.RE
.PP
The function `tcmapputkeep' is used in order to store a new record into a map object.
.PP
.RS
.br
\fBbool tcmapputkeep(TCMAP *\fImap\fB, const void *\fIkbuf\fB, int \fIksiz\fB, const void *\fIvbuf\fB, int \fIvsiz\fB);\fR
.RS
`\fImap\fR' specifies the map object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the map, this function has no effect.
.RE
.RE
.PP
The function `tcmapputkeep2' is used in order to store a new string record into a map object.
.PP
.RS
.br
\fBbool tcmapputkeep2(TCMAP *\fImap\fB, const char *\fIkstr\fB, const char *\fIvstr\fB);\fR
.RS
`\fImap\fR' specifies the map object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
`\fIvstr\fR' specifies the string of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the map, this function has no effect.
.RE
.RE
.PP
The function `tcmapputcat' is used in order to concatenate a value at the end of the value of the existing record in a map object.
.PP
.RS
.br
\fBvoid tcmapputcat(TCMAP *\fImap\fB, const void *\fIkbuf\fB, int \fIksiz\fB, const void *\fIvbuf\fB, int \fIvsiz\fB);\fR
.RS
`\fImap\fR' specifies the map object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.
.RE
.RS
If there is no corresponding record, a new record is created.
.RE
.RE
.PP
The function `tcmapputcat2' is used in order to concatenate a string value at the end of the value of the existing record in a map object.
.PP
.RS
.br
\fBvoid tcmapputcat2(TCMAP *\fImap\fB, const char *\fIkstr\fB, const char *\fIvstr\fB);\fR
.RS
`\fImap\fR' specifies the map object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
`\fIvstr\fR' specifies the string of the value.
.RE
.RS
If there is no corresponding record, a new record is created.
.RE
.RE
.PP
The function `tcmapout' is used in order to remove a record of a map object.
.PP
.RS
.br
\fBbool tcmapout(TCMAP *\fImap\fB, const void *\fIkbuf\fB, int \fIksiz\fB);\fR
.RS
`\fImap\fR' specifies the map object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
If successful, the return value is true.  False is returned when no record corresponds to the specified key.
.RE
.RE
.PP
The function `tcmapout2' is used in order to remove a string record of a map object.
.PP
.RS
.br
\fBbool tcmapout2(TCMAP *\fImap\fB, const char *\fIkstr\fB);\fR
.RS
`\fImap\fR' specifies the map object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
If successful, the return value is true.  False is returned when no record corresponds to the specified key.
.RE
.RE
.PP
The function `tcmapget' is used in order to retrieve a record in a map object.
.PP
.RS
.br
\fBconst void *tcmapget(const TCMAP *\fImap\fB, const void *\fIkbuf\fB, int \fIksiz\fB, int *\fIsp\fB);\fR
.RS
`\fImap\fR' specifies the map object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned when no record corresponds.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.
.RE
.RE
.PP
The function `tcmapget2' is used in order to retrieve a string record in a map object.
.PP
.RS
.br
\fBconst char *tcmapget2(const TCMAP *\fImap\fB, const char *\fIkstr\fB);\fR
.RS
`\fImap\fR' specifies the map object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned when no record corresponds.
.RE
.RE
.PP
The function `tcmapmove' is used in order to move a record to the edge of a map object.
.PP
.RS
.br
\fBbool tcmapmove(TCMAP *\fImap\fB, const void *\fIkbuf\fB, int \fIksiz\fB, bool \fIhead\fB);\fR
.RS
`\fImap\fR' specifies the map object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of a key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIhead\fR' specifies the destination which is the head if it is true or the tail if else.
.RE
.RS
If successful, the return value is true.  False is returned when no record corresponds to the specified key.
.RE
.RE
.PP
The function `tcmapmove2' is used in order to move a string record to the edge of a map object.
.PP
.RS
.br
\fBbool tcmapmove2(TCMAP *\fImap\fB, const char *\fIkstr\fB, bool \fIhead\fB);\fR
.RS
`\fImap\fR' specifies the map object.
.RE
.RS
`\fIkstr\fR' specifies the string of a key.
.RE
.RS
`\fIhead\fR' specifies the destination which is the head if it is true or the tail if else.
.RE
.RS
If successful, the return value is true.  False is returned when no record corresponds to the specified key.
.RE
.RE
.PP
The function `tcmapiterinit' is used in order to initialize the iterator of a map object.
.PP
.RS
.br
\fBvoid tcmapiterinit(TCMAP *\fImap\fB);\fR
.RS
`\fImap\fR' specifies the map object.
.RE
.RS
The iterator is used in order to access the key of every record stored in the map object.
.RE
.RE
.PP
The function `tcmapiternext' is used in order to get the next key of the iterator of a map object.
.PP
.RS
.br
\fBconst void *tcmapiternext(TCMAP *\fImap\fB, int *\fIsp\fB);\fR
.RS
`\fImap\fR' specifies the map object.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  The order of iteration is assured to be the same as the stored order.
.RE
.RE
.PP
The function `tcmapiternext2' is used in order to get the next key string of the iterator of a map object.
.PP
.RS
.br
\fBconst char *tcmapiternext2(TCMAP *\fImap\fB);\fR
.RS
`\fImap\fR' specifies the map object.
.RE
.RS
If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.
.RE
.RS
The order of iteration is assured to be the same as the stored order.
.RE
.RE
.PP
The function `tcmaprnum' is used in order to get the number of records stored in a map object.
.PP
.RS
.br
\fBuint64_t tcmaprnum(const TCMAP *\fImap\fB);\fR
.RS
`\fImap\fR' specifies the map object.
.RE
.RS
The return value is the number of the records stored in the map object.
.RE
.RE
.PP
The function `tcmapmsiz' is used in order to get the total size of memory used in a map object.
.PP
.RS
.br
\fBuint64_t tcmapmsiz(const TCMAP *\fImap\fB);\fR
.RS
`\fImap\fR' specifies the map object.
.RE
.RS
The return value is the total size of memory used in a map object.
.RE
.RE
.PP
The function `tcmapkeys' is used in order to create a list object containing all keys in a map object.
.PP
.RS
.br
\fBTCLIST *tcmapkeys(const TCMAP *\fImap\fB);\fR
.RS
`\fImap\fR' specifies the map object.
.RE
.RS
The return value is the new list object containing all keys in the map object.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.
.RE
.RE
.PP
The function `tcmapvals' is used in order to create a list object containing all values in a map object.
.PP
.RS
.br
\fBTCLIST *tcmapvals(const TCMAP *\fImap\fB);\fR
.RS
`\fImap\fR' specifies the map object.
.RE
.RS
The return value is the new list object containing all values in the map object.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.
.RE
.RE
.PP
The function `tcmapaddint' is used in order to add an integer to a record in a map object.
.PP
.RS
.br
\fBint tcmapaddint(TCMAP *\fImap\fB, const void *\fIkbuf\fB, int \fIksiz\fB, int \fInum\fB);\fR
.RS
`\fImap\fR' specifies the map object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fInum\fR' specifies the additional value.
.RE
.RS
The return value is the summation value.
.RE
.RS
If the corresponding record exists, the value is treated as an integer and is added to.  If no record corresponds, a new record of the additional value is stored.
.RE
.RE
.PP
The function `tcmapadddouble' is used in order to add a real number to a record in a map object.
.PP
.RS
.br
\fBdouble tcmapadddouble(TCMAP *\fImap\fB, const void *\fIkbuf\fB, int \fIksiz\fB, double \fInum\fB);\fR
.RS
`\fImap\fR' specifies the map object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fInum\fR' specifies the additional value.
.RE
.RS
The return value is the summation value.
.RE
.RS
If the corresponding record exists, the value is treated as a real number and is added to.  If no record corresponds, a new record of the additional value is stored.
.RE
.RE
.PP
The function `tcmapclear' is used in order to clear a map object.
.PP
.RS
.br
\fBvoid tcmapclear(TCMAP *\fImap\fB);\fR
.RS
`\fImap\fR' specifies the map object.
.RE
.RS
All records are removed.
.RE
.RE
.PP
The function `tcmapcutfront' is used in order to remove front records of a map object.
.PP
.RS
.br
\fBvoid tcmapcutfront(TCMAP *\fImap\fB, int \fInum\fB);\fR
.RS
`\fImap\fR' specifies the map object.
.RE
.RS
`\fInum\fR' specifies the number of records to be removed.
.RE
.RE
.PP
The function `tcmapdump' is used in order to serialize a map object into a byte array.
.PP
.RS
.br
\fBvoid *tcmapdump(const TCMAP *\fImap\fB, int *\fIsp\fB);\fR
.RS
`\fImap\fR' specifies the map object.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
The return value is the pointer to the region of the result serial region.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcmapload' is used in order to create a map object from a serialized byte array.
.PP
.RS
.br
\fBTCMAP *tcmapload(const void *\fIptr\fB, int \fIsize\fB);\fR
.RS
`\fIptr\fR' specifies the pointer to the region of serialized byte array.
.RE
.RS
`\fIsize\fR' specifies the size of the region.
.RE
.RS
The return value is a new map object.
.RE
.RS
Because the object of the return value is created with the function `tcmapnew', it should be deleted with the function `tcmapdel' when it is no longer in use.
.RE
.RE

.SH API OF ORDERED TREE
.PP
The function `tctreenew' is used in order to create a tree object.
.PP
.RS
.br
\fBTCTREE *tctreenew(void);\fR
.RS
The return value is the new tree object.
.RE
.RE
.PP
The function `tctreenew2' is used in order to create a tree object with specifying the custom comparison function.
.PP
.RS
.br
\fBTCTREE *tctreenew2(TCCMP \fIcmp\fB, void *\fIcmpop\fB);\fR
.RS
`\fIcmp\fR' specifies the pointer to the custom comparison function.  It receives five parameters.  The first parameter is the pointer to the region of one key.  The second parameter is the size of the region of one key.  The third parameter is the pointer to the region of the other key.  The fourth parameter is the size of the region of the other key.  The fifth parameter is the pointer to the optional opaque object.  It returns positive if the former is big, negative if the latter is big, 0 if both are equivalent.
.RE
.RS
`\fIcmpop\fR' specifies an arbitrary pointer to be given as a parameter of the comparison function.  If it is not needed, `NULL' can be specified.
.RE
.RS
The return value is the new tree object.
.RE
.RS
The default comparison function compares keys of two records by lexical order.  The functions `tccmplexical' (dafault), `tccmpdecimal', `tccmpint32', and `tccmpint64' are built\-in.
.RE
.RE
.PP
The function `tctreedup' is used in order to copy a tree object.
.PP
.RS
.br
\fBTCTREE *tctreedup(const TCTREE *\fItree\fB);\fR
.RS
`\fItree\fR' specifies the tree object.
.RE
.RS
The return value is the new tree object equivalent to the specified object.
.RE
.RE
.PP
The function `tctreedel' is used in order to delete a tree object.
.PP
.RS
.br
\fBvoid tctreedel(TCTREE *\fItree\fB);\fR
.RS
`tree' specifies the tree object.
.RE
.RS
Note that the deleted object and its derivatives can not be used anymore.
.RE
.RE
.PP
The function `tctreeput' is used in order to store a record into a tree object.
.PP
.RS
.br
\fBvoid tctreeput(TCTREE *\fItree\fB, const void *\fIkbuf\fB, int \fIksiz\fB, const void *\fIvbuf\fB, int \fIvsiz\fB);\fR
.RS
`\fItree\fR' specifies the tree object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.
.RE
.RS
If a record with the same key exists in the tree, it is overwritten.
.RE
.RE
.PP
The function `tctreeput2' is used in order to store a string record into a tree object.
.PP
.RS
.br
\fBvoid tctreeput2(TCTREE *\fItree\fB, const char *\fIkstr\fB, const char *\fIvstr\fB);\fR
.RS
`\fItree\fR' specifies the tree object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
`\fIvstr\fR' specifies the string of the value.
.RE
.RS
If a record with the same key exists in the tree, it is overwritten.
.RE
.RE
.PP
The function `tctreeputkeep' is used in order to store a new record into a tree object.
.PP
.RS
.br
\fBbool tctreeputkeep(TCTREE *\fItree\fB, const void *\fIkbuf\fB, int \fIksiz\fB, const void *\fIvbuf\fB, int \fIvsiz\fB);\fR
.RS
`\fItree\fR' specifies the tree object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the tree, this function has no effect.
.RE
.RE
.PP
The function `tctreeputkeep2' is used in order to store a new string record into a tree object.
.PP
.RS
.br
\fBbool tctreeputkeep2(TCTREE *\fItree\fB, const char *\fIkstr\fB, const char *\fIvstr\fB);\fR
.RS
`\fItree\fR' specifies the tree object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
`\fIvstr\fR' specifies the string of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the tree, this function has no effect.
.RE
.RE
.PP
The function `tctreeputcat' is used in order to concatenate a value at the end of the value of the existing record in a tree object.
.PP
.RS
.br
\fBvoid tctreeputcat(TCTREE *\fItree\fB, const void *\fIkbuf\fB, int \fIksiz\fB, const void *\fIvbuf\fB, int \fIvsiz\fB);\fR
.RS
`\fItree\fR' specifies the tree object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.
.RE
.RS
If there is no corresponding record, a new record is created.
.RE
.RE
.PP
The function `tctreeputcat2' is used in order to concatenate a string value at the end of the value of the existing record in a tree object.
.PP
.RS
.br
\fBvoid tctreeputcat2(TCTREE *\fItree\fB, const char *\fIkstr\fB, const char *\fIvstr\fB);\fR
.RS
`\fItree\fR' specifies the tree object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
`\fIvstr\fR' specifies the string of the value.
.RE
.RS
If there is no corresponding record, a new record is created.
.RE
.RE
.PP
The function `tctreeout' is used in order to remove a record of a tree object.
.PP
.RS
.br
\fBbool tctreeout(TCTREE *\fItree\fB, const void *\fIkbuf\fB, int \fIksiz\fB);\fR
.RS
`\fItree\fR' specifies the tree object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
If successful, the return value is true.  False is returned when no record corresponds to the specified key.
.RE
.RE
.PP
The function `tctreeout2' is used in order to remove a string record of a tree object.
.PP
.RS
.br
\fBbool tctreeout2(TCTREE *\fItree\fB, const char *\fIkstr\fB);\fR
.RS
`\fItree\fR' specifies the tree object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
If successful, the return value is true.  False is returned when no record corresponds to the specified key.
.RE
.RE
.PP
The function `tctreeget' is used in order to retrieve a record in a tree object.
.PP
.RS
.br
\fBconst void *tctreeget(TCTREE *\fItree\fB, const void *\fIkbuf\fB, int \fIksiz\fB, int *\fIsp\fB);\fR
.RS
`\fItree\fR' specifies the tree object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned when no record corresponds.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.
.RE
.RE
.PP
The function `tctreeget2' is used in order to retrieve a string record in a tree object.
.PP
.RS
.br
\fBconst char *tctreeget2(TCTREE *\fItree\fB, const char *\fIkstr\fB);\fR
.RS
`\fItree\fR' specifies the tree object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned when no record corresponds.
.RE
.RE
.PP
The function `tctreeiterinit' is used in order to initialize the iterator of a tree object.
.PP
.RS
.br
\fBvoid tctreeiterinit(TCTREE *\fItree\fB);\fR
.RS
`\fItree\fR' specifies the tree object.
.RE
.RS
The iterator is used in order to access the key of every record stored in the tree object.
.RE
.RE
.PP
The function `tctreeiterinit2' is used in order to initialize the iterator of a tree object in front of records corresponding a key.
.PP
.RS
.br
\fBvoid tctreeiterinit2(TCTREE *\fItree\fB, const void *\fIkbuf\fB, int \fIksiz\fB);\fR
.RS
`\fItree\fR' specifies the tree object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
The iterator is set to the first record corresponding the key or the next substitute if completely matching record does not exist.
.RE
.RE
.PP
The function `tctreeiterinit3' is used in order to initialize the iterator of a tree object in front of records corresponding a key string.
.PP
.RS
.br
\fBvoid tctreeiterinit3(TCTREE *\fItree\fB, const char *\fIkstr\fB);\fR
.RS
`\fItree\fR' specifies the tree object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
The iterator is set to the first record corresponding the key or the next substitute if completely matching record does not exist.
.RE
.RE
.PP
The function `tctreeiternext' is used in order to get the next key of the iterator of a tree object.
.PP
.RS
.br
\fBconst void *tctreeiternext(TCTREE *\fItree\fB, int *\fIsp\fB);\fR
.RS
`\fItree\fR' specifies the tree object.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  The order of iteration is assured to be ascending of the keys.
.RE
.RE
.PP
The function `tctreeiternext2' is used in order to get the next key string of the iterator of a tree object.
.PP
.RS
.br
\fBconst char *tctreeiternext2(TCTREE *\fItree\fB);\fR
.RS
`\fItree\fR' specifies the tree object.
.RE
.RS
If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.
.RE
.RS
The order of iteration is assured to be ascending of the keys.
.RE
.RE
.PP
The function `tctreernum' is used in order to get the number of records stored in a tree object.
.PP
.RS
.br
\fBuint64_t tctreernum(const TCTREE *\fItree\fB);\fR
.RS
`\fItree\fR' specifies the tree object.
.RE
.RS
The return value is the number of the records stored in the tree object.
.RE
.RE
.PP
The function `tctreemsiz' is used in order to get the total size of memory used in a tree object.
.PP
.RS
.br
\fBuint64_t tctreemsiz(const TCTREE *\fItree\fB);\fR
.RS
`\fItree\fR' specifies the tree object.
.RE
.RS
The return value is the total size of memory used in a tree object.
.RE
.RE
.PP
The function `tctreekeys' is used in order to create a list object containing all keys in a tree object.
.PP
.RS
.br
\fBTCLIST *tctreekeys(const TCTREE *\fItree\fB);\fR
.RS
`\fItree\fR' specifies the tree object.
.RE
.RS
The return value is the new list object containing all keys in the tree object.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.
.RE
.RE
.PP
The function `tctreevals' is used in order to create a list object containing all values in a tree object.
.PP
.RS
.br
\fBTCLIST *tctreevals(const TCTREE *\fItree\fB);\fR
.RS
`\fItree\fR' specifies the tree object.
.RE
.RS
The return value is the new list object containing all values in the tree object.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.
.RE
.RE
.PP
The function `tctreeaddint' is used in order to add an integer to a record in a tree object.
.PP
.RS
.br
\fBint tctreeaddint(TCTREE *\fItree\fB, const void *\fIkbuf\fB, int \fIksiz\fB, int \fInum\fB);\fR
.RS
`\fItree\fR' specifies the tree object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fInum\fR' specifies the additional value.
.RE
.RS
The return value is the summation value.
.RE
.RS
If the corresponding record exists, the value is treated as an integer and is added to.  If no record corresponds, a new record of the additional value is stored.
.RE
.RE
.PP
The function `tctreeadddouble' is used in order to add a real number to a record in a tree object.
.PP
.RS
.br
\fBdouble tctreeadddouble(TCTREE *\fItree\fB, const void *\fIkbuf\fB, int \fIksiz\fB, double \fInum\fB);\fR
.RS
`\fItree\fR' specifies the tree object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fInum\fR' specifies the additional value.
.RE
.RS
The return value is the summation value.
.RE
.RS
If the corresponding record exists, the value is treated as a real number and is added to.  If no record corresponds, a new record of the additional value is stored.
.RE
.RE
.PP
The function `tctreeclear' is used in order to clear a tree object.
.PP
.RS
.br
\fBvoid tctreeclear(TCTREE *\fItree\fB);\fR
.RS
`\fItree\fR' specifies the tree object.
.RE
.RS
All records are removed.
.RE
.RE
.PP
The function `tctreecutfringe' is used in order to remove fringe records of a tree object.
.PP
.RS
.br
\fBvoid tctreecutfringe(TCTREE *\fItree\fB, int \fInum\fB);\fR
.RS
`\fItree\fR' specifies the tree object.
.RE
.RS
`\fInum\fR' specifies the number of records to be removed.
.RE
.RE
.PP
The function `tctreedump' is used in order to serialize a tree object into a byte array.
.PP
.RS
.br
\fBvoid *tctreedump(const TCTREE *\fItree\fB, int *\fIsp\fB);\fR
.RS
`\fItree\fR' specifies the tree object.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
The return value is the pointer to the region of the result serial region.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tctreeload' is used in order to create a tree object from a serialized byte array.
.PP
.RS
.br
\fBTCTREE *tctreeload(const void *\fIptr\fB, int \fIsize\fB, TCCMP \fIcmp\fB, void *\fIcmpop\fB);\fR
.RS
`\fIptr\fR' specifies the pointer to the region of serialized byte array.
.RE
.RS
`\fIsize\fR' specifies the size of the region.
.RE
.RS
`\fIcmp\fR' specifies the pointer to the custom comparison function.
.RE
.RS
`\fIcmpop\fR' specifies an arbitrary pointer to be given as a parameter of the comparison function.
.RE
.RS
If it is not needed, `NULL' can be specified.
.RE
.RS
The return value is a new tree object.
.RE
.RS
Because the object of the return value is created with the function `tctreenew', it should be deleted with the function `tctreedel' when it is no longer in use.
.RE
.RE

.SH API OF ON\-MEMORY HASH DATABASE
.PP
The function `tcmdbnew' is used in order to create an on\-memory hash database object.
.PP
.RS
.br
\fBTCMDB *tcmdbnew(void);\fR
.RS
The return value is the new on\-memory hash database object.
.RE
.RS
The object can be shared by plural threads because of the internal mutex.
.RE
.RE
.PP
The function `tcmdbnew2' is used in order to create an on\-memory hash database object with specifying the number of the buckets.
.PP
.RS
.br
\fBTCMDB *tcmdbnew2(uint32_t \fIbnum\fB);\fR
.RS
`\fIbnum\fR' specifies the number of the buckets.
.RE
.RS
The return value is the new on\-memory hash database object.
.RE
.RS
The object can be shared by plural threads because of the internal mutex.
.RE
.RE
.PP
The function `tcmdbdel' is used in order to delete an on\-memory hash database object.
.PP
.RS
.br
\fBvoid tcmdbdel(TCMDB *\fImdb\fB);\fR
.RS
`\fImdb\fR' specifies the on\-memory hash database object.
.RE
.RE
.PP
The function `tcmdbput' is used in order to store a record into an on\-memory hash database object.
.PP
.RS
.br
\fBvoid tcmdbput(TCMDB *\fImdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, const void *\fIvbuf\fB, int \fIvsiz\fB);\fR
.RS
`\fImdb\fR' specifies the on\-memory hash database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.
.RE
.RS
If a record with the same key exists in the database, it is overwritten.
.RE
.RE
.PP
The function `tcmdbput2' is used in order to store a string record into an on\-memory hash database object.
.PP
.RS
.br
\fBvoid tcmdbput2(TCMDB *\fImdb\fB, const char *\fIkstr\fB, const char *\fIvstr\fB);\fR
.RS
`\fImdb\fR' specifies the on\-memory hash database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
`\fIvstr\fR' specifies the string of the value.
.RE
.RS
If a record with the same key exists in the database, it is overwritten.
.RE
.RE
.PP
The function `tcmdbputkeep' is used in order to store a new record into an on\-memory hash database object.
.PP
.RS
.br
\fBbool tcmdbputkeep(TCMDB *\fImdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, const void *\fIvbuf\fB, int \fIvsiz\fB);\fR
.RS
`\fImdb\fR' specifies the on\-memory hash database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, this function has no effect.
.RE
.RE
.PP
The function `tcmdbputkeep2' is used in order to store a new string record into an on\-memory hash database object.
.PP
.RS
.br
\fBbool tcmdbputkeep2(TCMDB *\fImdb\fB, const char *\fIkstr\fB, const char *\fIvstr\fB);\fR
.RS
`\fImdb\fR' specifies the on\-memory hash database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
`\fIvstr\fR' specifies the string of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, this function has no effect.
.RE
.RE
.PP
The function `tcmdbputcat' is used in order to concatenate a value at the end of the existing record in an on\-memory hash database.
.PP
.RS
.br
\fBvoid tcmdbputcat(TCMDB *\fImdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, const void *\fIvbuf\fB, int \fIvsiz\fB);\fR
.RS
`\fImdb\fR' specifies the on\-memory hash database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.
.RE
.RS
If there is no corresponding record, a new record is created.
.RE
.RE
.PP
The function `tcmdbputcat2' is used in order to concatenate a string at the end of the existing record in an on\-memory hash database.
.PP
.RS
.br
\fBvoid tcmdbputcat2(TCMDB *\fImdb\fB, const char *\fIkstr\fB, const char *\fIvstr\fB);\fR
.RS
`\fImdb\fR' specifies the on\-memory hash database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
`\fIvstr\fR' specifies the string of the value.
.RE
.RS
If there is no corresponding record, a new record is created.
.RE
.RE
.PP
The function `tcmdbout' is used in order to remove a record of an on\-memory hash database object.
.PP
.RS
.br
\fBbool tcmdbout(TCMDB *\fImdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB);\fR
.RS
`\fImdb\fR' specifies the on\-memory hash database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
If successful, the return value is true.  False is returned when no record corresponds to the specified key.
.RE
.RE
.PP
The function `tcmdbout2' is used in order to remove a string record of an on\-memory hash database object.
.PP
.RS
.br
\fBbool tcmdbout2(TCMDB *\fImdb\fB, const char *\fIkstr\fB);\fR
.RS
`\fImdb\fR' specifies the on\-memory hash database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
If successful, the return value is true.  False is returned when no record corresponds to the specified key.
.RE
.RE
.PP
The function `tcmdbget' is used in order to retrieve a record in an on\-memory hash database object.
.PP
.RS
.br
\fBvoid *tcmdbget(TCMDB *\fImdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, int *\fIsp\fB);\fR
.RS
`\fImdb\fR' specifies the on\-memory hash database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned when no record corresponds.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcmdbget2' is used in order to retrieve a string record in an on\-memory hash database object.
.PP
.RS
.br
\fBchar *tcmdbget2(TCMDB *\fImdb\fB, const char *\fIkstr\fB);\fR
.RS
`\fImdb\fR' specifies the on\-memory hash database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned when no record corresponds.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcmdbvsiz' is used in order to get the size of the value of a record in an on\-memory hash database object.
.PP
.RS
.br
\fBint tcmdbvsiz(TCMDB *\fImdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB);\fR
.RS
`\fImdb\fR' specifies the on\-memory hash database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
If successful, the return value is the size of the value of the corresponding record, else, it is \-1.
.RE
.RE
.PP
The function `tcmdbvsiz2' is used in order to get the size of the value of a string record in an on\-memory hash database object.
.PP
.RS
.br
\fBint tcmdbvsiz2(TCMDB *\fImdb\fB, const char *\fIkstr\fB);\fR
.RS
`\fImdb\fR' specifies the on\-memory hash database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
If successful, the return value is the size of the value of the corresponding record, else, it is \-1.
.RE
.RE
.PP
The function `tcmdbiterinit' is used in order to initialize the iterator of an on\-memory hash database object.
.PP
.RS
.br
\fBvoid tcmdbiterinit(TCMDB *\fImdb\fB);\fR
.RS
`\fImdb\fR' specifies the on\-memory hash database object.
.RE
.RS
The iterator is used in order to access the key of every record stored in the on\-memory hash database.
.RE
.RE
.PP
The function `tcmdbiternext' is used in order to get the next key of the iterator of an on\-memory hash database object.
.PP
.RS
.br
\fBvoid *tcmdbiternext(TCMDB *\fImdb\fB, int *\fIsp\fB);\fR
.RS
`\fImdb\fR' specifies the on\-memory hash database object.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return
.RE
.RS
value is assigned.
.RE
.RS
If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  The order of iteration is assured to be the same as the stored order.
.RE
.RE
.PP
The function `tcmdbiternext2' is used in order to get the next key string of the iterator of an on\-memory hash database object.
.PP
.RS
.br
\fBchar *tcmdbiternext2(TCMDB *\fImdb\fB);\fR
.RS
`\fImdb\fR' specifies the on\-memory hash database object.
.RE
.RS
If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  The order of iteration is assured to be the same as the stored order.
.RE
.RE
.PP
The function `tcmdbfwmkeys' is used in order to get forward matching keys in an on\-memory hash database object.
.PP
.RS
.br
\fBTCLIST *tcmdbfwmkeys(TCMDB *\fImdb\fB, const void *\fIpbuf\fB, int \fIpsiz\fB, int \fImax\fB);\fR
.RS
`\fImdb\fR' specifies the on\-memory hash database object.
.RE
.RS
`\fIpbuf\fR' specifies the pointer to the region of the prefix.
.RE
.RS
`\fIpsiz\fR' specifies the size of the region of the prefix.
.RE
.RS
`\fImax\fR' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.
.RE
.RS
The return value is a list object of the corresponding keys.  This function does never fail and return an empty list even if no key corresponds.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.
.RE
.RE
.PP
The function `tcmdbfwmkeys2' is used in order to get forward matching string keys in an on\-memory hash database object.
.PP
.RS
.br
\fBTCLIST *tcmdbfwmkeys2(TCMDB *\fImdb\fB, const char *\fIpstr\fB, int \fImax\fB);\fR
.RS
`\fImdb\fR' specifies the on\-memory hash database object.
.RE
.RS
`\fIpstr\fR' specifies the string of the prefix.
.RE
.RS
`\fImax\fR' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.
.RE
.RS
The return value is a list object of the corresponding keys.  This function does never fail and return an empty list even if no key corresponds.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.
.RE
.RE
.PP
The function `tcmdbrnum' is used in order to get the number of records stored in an on\-memory hash database object.
.PP
.RS
.br
\fBuint64_t tcmdbrnum(TCMDB *\fImdb\fB);\fR
.RS
`\fImdb\fR' specifies the on\-memory hash database object.
.RE
.RS
The return value is the number of the records stored in the database.
.RE
.RE
.PP
The function `tcmdbmsiz' is used in order to get the total size of memory used in an on\-memory hash database object.
.PP
.RS
.br
\fBuint64_t tcmdbmsiz(TCMDB *\fImdb\fB);\fR
.RS
`\fImdb\fR' specifies the on\-memory hash database object.
.RE
.RS
The return value is the total size of memory used in the database.
.RE
.RE
.PP
The function `tcmdbaddint' is used in order to add an integer to a record in an on\-memory hash database object.
.PP
.RS
.br
\fBint tcmdbaddint(TCMDB *\fImdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, int \fInum\fB);\fR
.RS
`\fImdb\fR' specifies the on\-memory hash database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fInum\fR' specifies the additional value.
.RE
.RS
The return value is the summation value.
.RE
.RS
If the corresponding record exists, the value is treated as an integer and is added to.  If no record corresponds, a new record of the additional value is stored.
.RE
.RE
.PP
The function `tcmdbadddouble' is used in order to add a real number to a record in an on\-memory hash database object.
.PP
.RS
.br
\fBdouble tcmdbadddouble(TCMDB *\fImdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, double \fInum\fB);\fR
.RS
`\fImdb\fR' specifies the on\-memory hash database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fInum\fR' specifies the additional value.
.RE
.RS
The return value is the summation value.
.RE
.RS
If the corresponding record exists, the value is treated as a real number and is added to.  If no record corresponds, a new record of the additional value is stored.
.RE
.RE
.PP
The function `tcmdbvanish' is used in order to clear an on\-memory hash database object.
.PP
.RS
.br
\fBvoid tcmdbvanish(TCMDB *\fImdb\fB);\fR
.RS
`\fImdb\fR' specifies the on\-memory hash database object.
.RE
.RS
All records are removed.
.RE
.RE
.PP
The function `tcmdbcutfront' is used in order to remove front records of an on\-memory hash database object.
.PP
.RS
.br
\fBvoid tcmdbcutfront(TCMDB *\fImdb\fB, int \fInum\fB);\fR
.RS
`\fImdb\fR' specifies the on\-memory hash database object.
.RE
.RS
`\fInum\fR' specifies the number of records to be removed.
.RE
.RE

.SH API OF ON\-MEMORY TREE DATABASE
.PP
The function `tcndbnew' is used in order to create an on\-memory tree database object.
.PP
.RS
.br
\fBTCNDB *tcndbnew(void);\fR
.RS
The return value is the new on\-memory tree database object.
.RE
.RS
The object can be shared by plural threads because of the internal mutex.
.RE
.RE
.PP
The function `tcndbnew2' is used in order to create an on\-memory tree database object with specifying the custom comparison function.
.PP
.RS
.br
\fBTCNDB *tcndbnew2(TCCMP \fIcmp\fB, void *\fIcmpop\fB);\fR
.RS
`\fIcmp\fR' specifies the pointer to the custom comparison function.
.RE
.RS
`\fIcmpop\fR' specifies an arbitrary pointer to be given as a parameter of the comparison function.  If it is not needed, `NULL' can be specified.
.RE
.RS
The return value is the new on\-memory tree database object.
.RE
.RS
The default comparison function compares keys of two records by lexical order.  The functions `tccmplexical' (dafault), `tccmpdecimal', `tccmpint32', and `tccmpint64' are built\-in.  The object can be shared by plural threads because of the internal mutex.
.RE
.RE
.PP
The function `tcndbdel' is used in order to delete an on\-memory tree database object.
.PP
.RS
.br
\fBvoid tcndbdel(TCNDB *\fIndb\fB);\fR
.RS
`\fIndb\fR' specifies the on\-memory tree database object.
.RE
.RE
.PP
The function `tcndbput' is used in order to store a record into an on\-memory tree database object.
.PP
.RS
.br
\fBvoid tcndbput(TCNDB *\fIndb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, const void *\fIvbuf\fB, int \fIvsiz\fB);\fR
.RS
`\fIndb\fR' specifies the on\-memory tree database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.
.RE
.RS
If a record with the same key exists in the database, it is overwritten.
.RE
.RE
.PP
The function `tcndbput2' is used in order to store a string record into an on\-memory tree database object.
.PP
.RS
.br
\fBvoid tcndbput2(TCNDB *\fIndb\fB, const char *\fIkstr\fB, const char *\fIvstr\fB);\fR
.RS
`\fIndb\fR' specifies the on\-memory tree database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
`\fIvstr\fR' specifies the string of the value.
.RE
.RS
If a record with the same key exists in the database, it is overwritten.
.RE
.RE
.PP
The function `tcndbputkeep' is used in order to store a new record into an on\-memory tree database object.
.PP
.RS
.br
\fBbool tcndbputkeep(TCNDB *\fIndb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, const void *\fIvbuf\fB, int \fIvsiz\fB);\fR
.RS
`\fIndb\fR' specifies the on\-memory tree database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, this function has no effect.
.RE
.RE
.PP
The function `tcndbputkeep2' is used in order to store a new string record into an on\-memory tree database object.
.PP
.RS
.br
\fBbool tcndbputkeep2(TCNDB *\fIndb\fB, const char *\fIkstr\fB, const char *\fIvstr\fB);\fR
.RS
`\fIndb\fR' specifies the on\-memory tree database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
`\fIvstr\fR' specifies the string of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, this function has no effect.
.RE
.RE
.PP
The function `tcndbputcat' is used in order to concatenate a value at the end of the existing record in an on\-memory tree database.
.PP
.RS
.br
\fBvoid tcndbputcat(TCNDB *\fIndb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, const void *\fIvbuf\fB, int \fIvsiz\fB);\fR
.RS
`\fIndb\fR' specifies the on\-memory tree database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.
.RE
.RS
If there is no corresponding record, a new record is created.
.RE
.RE
.PP
The function `tcndbputcat2' is used in order to concatenate a string at the end of the existing record in an on\-memory tree database.
.PP
.RS
.br
\fBvoid tcndbputcat2(TCNDB *\fIndb\fB, const char *\fIkstr\fB, const char *\fIvstr\fB);\fR
.RS
`\fIndb\fR' specifies the on\-memory tree database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
`\fIvstr\fR' specifies the string of the value.
.RE
.RS
If there is no corresponding record, a new record is created.
.RE
.RE
.PP
The function `tcndbout' is used in order to remove a record of an on\-memory tree database object.
.PP
.RS
.br
\fBbool tcndbout(TCNDB *\fIndb\fB, const void *\fIkbuf\fB, int \fIksiz\fB);\fR
.RS
`\fIndb\fR' specifies the on\-memory tree database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
If successful, the return value is true.  False is returned when no record corresponds to the specified key.
.RE
.RE
.PP
The function `tcndbout2' is used in order to remove a string record of an on\-memory tree database object.
.PP
.RS
.br
\fBbool tcndbout2(TCNDB *\fIndb\fB, const char *\fIkstr\fB);\fR
.RS
`\fIndb\fR' specifies the on\-memory tree database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
If successful, the return value is true.  False is returned when no record corresponds to the specified key.
.RE
.RE
.PP
The function `tcndbget' is used in order to retrieve a record in an on\-memory tree database object.
.PP
.RS
.br
\fBvoid *tcndbget(TCNDB *\fIndb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, int *\fIsp\fB);\fR
.RS
`\fIndb\fR' specifies the on\-memory tree database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned when no record corresponds.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcndbget2' is used in order to retrieve a string record in an on\-memory tree database object.
.PP
.RS
.br
\fBchar *tcndbget2(TCNDB *\fIndb\fB, const char *\fIkstr\fB);\fR
.RS
`\fIndb\fR' specifies the on\-memory tree database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned when no record corresponds.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcndbvsiz' is used in order to get the size of the value of a record in an on\-memory tree database object.
.PP
.RS
.br
\fBint tcndbvsiz(TCNDB *\fIndb\fB, const void *\fIkbuf\fB, int \fIksiz\fB);\fR
.RS
`\fIndb\fR' specifies the on\-memory tree database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
If successful, the return value is the size of the value of the corresponding record, else, it is \-1.
.RE
.RE
.PP
The function `tcndbvsiz2' is used in order to get the size of the value of a string record in an on\-memory tree database object.
.PP
.RS
.br
\fBint tcndbvsiz2(TCNDB *\fIndb\fB, const char *\fIkstr\fB);\fR
.RS
`\fIndb\fR' specifies the on\-memory tree database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
If successful, the return value is the size of the value of the corresponding record, else, it is \-1.
.RE
.RE
.PP
The function `tcndbiterinit' is used in order to initialize the iterator of an on\-memory tree database object.
.PP
.RS
.br
\fBvoid tcndbiterinit(TCNDB *\fIndb\fB);\fR
.RS
`\fIndb\fR' specifies the on\-memory tree database object.
.RE
.RS
The iterator is used in order to access the key of every record stored in the on\-memory database.
.RE
.RE
.PP
The function `tcndbiterinit2' is used in order to initialize the iterator of an on\-memory tree database object in front of a key.
.PP
.RS
.br
\fBvoid tcndbiterinit2(TCNDB *\fIndb\fB, const void *\fIkbuf\fB, int \fIksiz\fB);\fR
.RS
`\fIndb\fR' specifies the on\-memory tree database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
The iterator is set to the first record corresponding the key or the next substitute if completely matching record does not exist.
.RE
.RE
.PP
The function `tcndbiterinit3' is used in order to initialize the iterator of an on\-memory tree database object in front of a key string.
.PP
.RS
.br
\fBvoid tcndbiterinit3(TCNDB *\fIndb\fB, const char *\fIkstr\fB);\fR
.RS
`\fIndb\fR' specifies the on\-memory tree database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
The iterator is set to the first record corresponding the key or the next substitute if completely matching record does not exist.
.RE
.RE
.PP
The function `tcndbiternext' is used in order to get the next key of the iterator of an on\-memory tree database object.
.PP
.RS
.br
\fBvoid *tcndbiternext(TCNDB *\fIndb\fB, int *\fIsp\fB);\fR
.RS
`\fIndb\fR' specifies the on\-memory tree database object.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  The order of iteration is assured to be the same as the stored order.
.RE
.RE
.PP
The function `tcndbiternext2' is used in order to get the next key string of the iterator of an on\-memory tree database object.
.PP
.RS
.br
\fBchar *tcndbiternext2(TCNDB *\fIndb\fB);\fR
.RS
`\fIndb\fR' specifies the on\-memory tree database object.
.RE
.RS
If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  The order of iteration is assured to be the same as the stored order.
.RE
.RE
.PP
The function `tcndbfwmkeys' is used in order to get forward matching keys in an on\-memory tree database object.
.PP
.RS
.br
\fBTCLIST *tcndbfwmkeys(TCNDB *\fIndb\fB, const void *\fIpbuf\fB, int \fIpsiz\fB, int \fImax\fB);\fR
.RS
`\fIndb\fR' specifies the on\-memory tree database object.
.RE
.RS
`\fIpbuf\fR' specifies the pointer to the region of the prefix.
.RE
.RS
`\fIpsiz\fR' specifies the size of the region of the prefix.
.RE
.RS
`\fImax\fR' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.
.RE
.RS
The return value is a list object of the corresponding keys.  This function does never fail and return an empty list even if no key corresponds.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.
.RE
.RE
.PP
The function `tcndbfwmkeys2' is used in order to get forward matching string keys in an on\-memory tree database object.
.PP
.RS
.br
\fBTCLIST *tcndbfwmkeys2(TCNDB *\fIndb\fB, const char *\fIpstr\fB, int \fImax\fB);\fR
.RS
`\fIndb\fR' specifies the on\-memory tree database object.
.RE
.RS
`\fIpstr\fR' specifies the string of the prefix.
.RE
.RS
`\fImax\fR' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.
.RE
.RS
The return value is a list object of the corresponding keys.  This function does never fail and return an empty list even if no key corresponds.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.
.RE
.RE
.PP
The function `tcndbrnum' is used in order to get the number of records stored in an on\-memory tree database object.
.PP
.RS
.br
\fBuint64_t tcndbrnum(TCNDB *\fIndb\fB);\fR
.RS
`\fIndb\fR' specifies the on\-memory tree database object.
.RE
.RS
The return value is the number of the records stored in the database.
.RE
.RE
.PP
The function `tcndbmsiz' is used in order to get the total size of memory used in an on\-memory tree database object.
.PP
.RS
.br
\fBuint64_t tcndbmsiz(TCNDB *\fIndb\fB);\fR
.RS
`\fIndb\fR' specifies the on\-memory tree database object.
.RE
.RS
The return value is the total size of memory used in the database.
.RE
.RE
.PP
The function `tcndbaddint' is used in order to add an integer to a record in an on\-memory tree database object.
.PP
.RS
.br
\fBint tcndbaddint(TCNDB *\fIndb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, int \fInum\fB);\fR
.RS
`\fIndb\fR' specifies the on\-memory tree database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fInum\fR' specifies the additional value.
.RE
.RS
The return value is the summation value.
.RE
.RS
If the corresponding record exists, the value is treated as an integer and is added to.  If no record corresponds, a new record of the additional value is stored.
.RE
.RE
.PP
The function `tcndbadddouble' is used in order to add a real number to a record in an on\-memory tree database object.
.PP
.RS
.br
\fBdouble tcndbadddouble(TCNDB *\fIndb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, double \fInum\fB);\fR
.RS
`\fIndb\fR' specifies the on\-memory tree database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fInum\fR' specifies the additional value.
.RE
.RS
The return value is the summation value.
.RE
.RS
If the corresponding record exists, the value is treated as a real number and is added to.  If no record corresponds, a new record of the additional value is stored.
.RE
.RE
.PP
The function `tcndbvanish' is used in order to clear an on\-memory tree database object.
.PP
.RS
.br
\fBvoid tcndbvanish(TCNDB *\fIndb\fB);\fR
.RS
`\fIndb\fR' specifies the on\-memory tree database object.
.RE
.RS
All records are removed.
.RE
.RE
.PP
The function `tcndbcutfringe' is used in order to remove fringe records of an on\-memory tree database object.
.PP
.RS
.br
\fBvoid tcndbcutfringe(TCNDB *\fIndb\fB, int \fInum\fB);\fR
.RS
`\fIndb\fR' specifies the on\-memory tree database object.
.RE
.RS
`\fInum\fR' specifies the number of records to be removed.
.RE
.RE

.SH API OF MEMORY POOL
.PP
The function `tcmpoolnew' is used in order to create a memory pool object.
.PP
.RS
.br
\fBTCMPOOL *tcmpoolnew(void);\fR
.RS
The return value is the new memory pool object.
.RE
.RE
.PP
The function `tcmpooldel' is used in order to delete a memory pool object.
.PP
.RS
.br
\fBvoid tcmpooldel(TCMPOOL *\fImpool\fB);\fR
.RS
`\fImpool\fR' specifies the memory pool object.
.RE
.RS
Note that the deleted object and its derivatives can not be used anymore.
.RE
.RE
.PP
The function `tcmpoolput' is used in order to relegate an arbitrary object to a memory pool object.
.PP
.RS
.br
\fBvoid tcmpoolput(TCMPOOL *\fImpool\fB, void *\fIptr\fB, void (*\fIdel\fB)(void *));\fR
.RS
`\fImpool\fR' specifies the memory pool object.
.RE
.RS
`\fIptr\fR' specifies the pointer to the object to be relegated.
.RE
.RS
`\fIdel\fR' specifies the pointer to the function to delete the object.
.RE
.RS
This function assures that the specified object is deleted when the memory pool object is deleted.
.RE
.RE
.PP
The function `tcmpoolputptr' is used in order to relegate an allocated region to a memory pool object.
.PP
.RS
.br
\fBvoid tcmpoolputptr(TCMPOOL *\fImpool\fB, void *\fIptr\fB);\fR
.RS
`\fIptr\fR' specifies the pointer to the region to be relegated.
.RE
.RS
This function assures that the specified region is released when the memory pool object is deleted.
.RE
.RE
.PP
The function `tcmpoolputxstr' is used in order to relegate an extensible string object to a memory pool object.
.PP
.RS
.br
\fBvoid tcmpoolputxstr(TCMPOOL *\fImpool\fB, TCXSTR *\fIxstr\fB);\fR
.RS
`\fImpool\fR' specifies the memory pool object.
.RE
.RS
`\fIxstr\fR' specifies the extensible string object.
.RE
.RS
This function assures that the specified object is deleted when the memory pool object is deleted.
.RE
.RE
.PP
The function `tcmpoolputlist' is used in order to relegate a list object to a memory pool object.
.PP
.RS
.br
\fBvoid tcmpoolputlist(TCMPOOL *\fImpool\fB, TCLIST *\fIlist\fB);\fR
.RS
`\fImpool\fR' specifies the memory pool object.
.RE
.RS
`\fIlist\fR' specifies the list object.
.RE
.RS
This function assures that the specified object is deleted when the memory pool object is deleted.
.RE
.RE
.PP
The function `tcmpoolputmap' is used in order to relegate a map object to a memory pool object.
.PP
.RS
.br
\fBvoid tcmpoolputmap(TCMPOOL *\fImpool\fB, TCMAP *\fImap\fB);\fR
.RS
`\fImpool\fR' specifies the memory pool object.
.RE
.RS
`\fImap\fR' specifies the map object.
.RE
.RS
This function assures that the specified object is deleted when the memory pool object is deleted.
.RE
.RE
.PP
The function `tcmpoolputtree' is used in order to relegate a tree object to a memory pool object.
.PP
.RS
.br
\fBvoid tcmpoolputtree(TCMPOOL *\fImpool\fB, TCTREE *\fItree\fB);\fR
.RS
`\fImpool\fR' specifies the memory pool object.
.RE
.RS
`\fItree\fR' specifies the tree object.
.RE
.RS
This function assures that the specified object is deleted when the memory pool object is deleted.
.RE
.RE
.PP
The function `tcmpoolmalloc' is used in order to allocate a region relegated to a memory pool object.
.PP
.RS
.br
\fBvoid *tcmpoolmalloc(TCMPOOL *\fImpool\fB, size_t \fIsize\fB);\fR
.RS
`\fImpool\fR' specifies the memory pool object.
.RE
.RS
The return value is the pointer to the allocated region under the memory pool.
.RE
.RE
.PP
The function `tcmpoolxstrnew' is used in order to create an extensible string object relegated to a memory pool object.
.PP
.RS
.br
\fBTCXSTR *tcmpoolxstrnew(TCMPOOL *\fImpool\fB);\fR
.RS
The return value is the new extensible string object under the memory pool.
.RE
.RE
.PP
The function `tcmpoollistnew' is used in order to create a list object relegated to a memory pool object.
.PP
.RS
.br
\fBTCLIST *tcmpoollistnew(TCMPOOL *\fImpool\fB);\fR
.RS
The return value is the new list object under the memory pool.
.RE
.RE
.PP
The function `tcmpoolmapnew' is used in order to create a map object relegated to a memory pool object.
.PP
.RS
.br
\fBTCMAP *tcmpoolmapnew(TCMPOOL *\fImpool\fB);\fR
.RS
The return value is the new map object under the memory pool.
.RE
.RE
.PP
The function `tcmpooltreenew' is used in order to create a tree object relegated to a memory pool object.
.PP
.RS
.br
\fBTCTREE *tcmpooltreenew(TCMPOOL *\fImpool\fB);\fR
.RS
The return value is the new tree object under the memory pool.
.RE
.RE
.PP
The function `tcmpoolglobal' is used in order to get the global memory pool object.
.PP
.RS
.br
\fBTCMPOOL *tcmpoolglobal(void);\fR
.RS
The return value is the global memory pool object.
.RE
.RS
The global memory pool object is a singleton and assured to be deleted when the process is terminating normally.
.RE
.RE

.SH API OF MISCELLANEOUS UTILITIES
.PP
The function `tclmax' is used in order to get the larger value of two integers.
.PP
.RS
.br
\fBlong tclmax(long \fIa\fB, long \fIb\fB);\fR
.RS
`\fIa\fR' specifies an integer.
.RE
.RS
`\fIb\fR' specifies the other integer.
.RE
.RS
The return value is the larger value of the two.
.RE
.RE
.PP
The function `tclmin' is used in order to get the lesser value of two integers.
.PP
.RS
.br
\fBlong tclmin(long \fIa\fB, long \fIb\fB);\fR
.RS
`\fIa\fR' specifies an integer.
.RE
.RS
`\fIb\fR' specifies the other integer.
.RE
.RS
The return value is the lesser value of the two.
.RE
.RE
.PP
The function `tclrand' is used in order to get a random number as long integer based on uniform distribution.
.PP
.RS
.br
\fBunsigned long tclrand(void);\fR
.RS
The return value is the random number between 0 and `ULONG_MAX'.
.RE
.RS
This function uses the random number source device and generates a real random number if possible.
.RE
.RE
.PP
The function `tcdrand' is used in order to get a random number as double decimal based on uniform distribution.
.PP
.RS
.br
\fBdouble tcdrand(void);\fR
.RS
The return value is the random number equal to or greater than 0, and less than 1.0.
.RE
.RS
This function uses the random number source device and generates a real random number if possible.
.RE
.RE
.PP
The function `tcdrandnd' is used in order to get a random number as double decimal based on normal distribution.
.PP
.RS
.br
\fBdouble tcdrandnd(double \fIavg\fB, double \fIsd\fB);\fR
.RS
`\fIavg\fR' specifies the average.
.RE
.RS
`\fIsd\fR' specifies the standard deviation.
.RE
.RS
The return value is the random number.
.RE
.RS
This function uses the random number source device and generates a real random number if possible.
.RE
.RE
.PP
The function `tcstricmp' is used in order to compare two strings with case insensitive evaluation.
.PP
.RS
.br
\fBint tcstricmp(const char *\fIastr\fB, const char *\fIbstr\fB);\fR
.RS
`\fIastr\fR' specifies a string.
.RE
.RS
`\fIbstr\fR' specifies of the other string.
.RE
.RS
The return value is positive if the former is big, negative if the latter is big, 0 if both are equivalent.
.RE
.RE
.PP
The function `tcstrfwm' is used in order to check whether a string begins with a key.
.PP
.RS
.br
\fBbool tcstrfwm(const char *\fIstr\fB, const char *\fIkey\fB);\fR
.RS
`\fIstr\fR' specifies the target string.
.RE
.RS
`\fIkey\fR' specifies the forward matching key string.
.RE
.RS
The return value is true if the target string begins with the key, else, it is false.
.RE
.RE
.PP
The function `tcstrifwm' is used in order to check whether a string begins with a key with case insensitive evaluation.
.PP
.RS
.br
\fBbool tcstrifwm(const char *\fIstr\fB, const char *\fIkey\fB);\fR
.RS
`\fIstr\fR' specifies the target string.
.RE
.RS
`\fIkey\fR' specifies the forward matching key string.
.RE
.RS
The return value is true if the target string begins with the key, else, it is false.
.RE
.RE
.PP
The function `tcstrbwm' is used in order to check whether a string ends with a key.
.PP
.RS
.br
\fBbool tcstrbwm(const char *\fIstr\fB, const char *\fIkey\fB);\fR
.RS
`\fIstr\fR' specifies the target string.
.RE
.RS
`\fIkey\fR' specifies the backward matching key string.
.RE
.RS
The return value is true if the target string ends with the key, else, it is false.
.RE
.RE
.PP
The function `tcstribwm' is used in order to check whether a string ends with a key with case insensitive evaluation.
.PP
.RS
.br
\fBbool tcstribwm(const char *\fIstr\fB, const char *\fIkey\fB);\fR
.RS
`\fIstr\fR' specifies the target string.
.RE
.RS
`\fIkey\fR' specifies the backward matching key string.
.RE
.RS
The return value is true if the target string ends with the key, else, it is false.
.RE
.RE
.PP
The function `tcstrdist' is used in order to calculate the edit distance of two strings.
.PP
.RS
.br
\fBint tcstrdist(const char *\fIastr\fB, const char *\fIbstr\fB);\fR
.RS
`\fIastr\fR' specifies a string.
.RE
.RS
`\fIbstr\fR' specifies of the other string.
.RE
.RS
The return value is the edit distance which is known as the Levenshtein distance.  The cost is calculated by byte.
.RE
.RE
.PP
The function `tcstrdistutf' is used in order to calculate the edit distance of two UTF\-8 strings.
.PP
.RS
.br
\fBint tcstrdistutf(const char *\fIastr\fB, const char *\fIbstr\fB);\fR
.RS
`\fIastr\fR' specifies a string.
.RE
.RS
`\fIbstr\fR' specifies of the other string.
.RE
.RS
The return value is the edit distance which is known as the Levenshtein distance.  The cost is calculated by Unicode character.
.RE
.RE
.PP
The function `tcstrtoupper' is used in order to convert the letters of a string into upper case.
.PP
.RS
.br
\fBchar *tcstrtoupper(char *\fIstr\fB);\fR
.RS
`\fIstr\fR' specifies the string to be converted.
.RE
.RS
The return value is the string itself.
.RE
.RE
.PP
The function `tcstrtolower' is used in order to convert the letters of a string into lower case.
.PP
.RS
.br
\fBchar *tcstrtolower(char *\fIstr\fB);\fR
.RS
`\fIstr\fR' specifies the string to be converted.
.RE
.RS
The return value is the string itself.
.RE
.RE
.PP
The function `tcstrtrim' is used in order to cut space characters at head or tail of a string.
.PP
.RS
.br
\fBchar *tcstrtrim(char *\fIstr\fB);\fR
.RS
`\fIstr\fR' specifies the string to be converted.
.RE
.RS
The return value is the string itself.
.RE
.RE
.PP
The function `tcstrsqzspc' is used in order to squeeze space characters in a string and trim it.
.PP
.RS
.br
\fBchar *tcstrsqzspc(char *\fIstr\fB);\fR
.RS
`\fIstr\fR' specifies the string to be converted.
.RE
.RS
The return value is the string itself.
.RE
.RE
.PP
The function `tcstrsubchr' is used in order to substitute characters in a string.
.PP
.RS
.br
\fBchar *tcstrsubchr(char *\fIstr\fB, const char *\fIrstr\fB, const char *\fIsstr\fB);\fR
.RS
`\fIstr\fR' specifies the string to be converted.
.RE
.RS
`\fIrstr\fR' specifies the string containing characters to be replaced.
.RE
.RS
`\fIsstr\fR' specifies the string containing characters to be substituted.
.RE
.RS
If the substitute string is shorter then the replacement string, corresponding characters are removed.
.RE
.RE
.PP
The function `tcstrcntutf' is used in order to count the number of characters in a string of UTF\-8.
.PP
.RS
.br
\fBint tcstrcntutf(const char *\fIstr\fB);\fR
.RS
`\fIstr\fR' specifies the string of UTF\-8.
.RE
.RS
The return value is the number of characters in the string.
.RE
.RE
.PP
The function `tcstrcututf' is used in order to cut a string of UTF\-8 at the specified number of characters.
.PP
.RS
.br
\fBchar *tcstrcututf(char *\fIstr\fB, int \fInum\fB);\fR
.RS
`\fIstr\fR' specifies the string of UTF\-8.
.RE
.RS
`\fInum\fR' specifies the number of characters to be kept.
.RE
.RS
The return value is the string itself.
.RE
.RE
.PP
The function `tcstrutftoucs' is used in order to convert a UTF\-8 string into a UCS\-2 array.
.PP
.RS
.br
\fBvoid tcstrutftoucs(const char *\fIstr\fB, uint16_t *\fIary\fB, int *\fInp\fB);\fR
.RS
`\fIstr\fR' specifies the UTF\-8 string.
.RE
.RS
`\fIary\fR' specifies the pointer to the region into which the result UCS\-2 codes are written.  The size of the buffer should be sufficient.
.RE
.RS
`\fInp\fR' specifies the pointer to a variable into which the number of elements of the result array is assigned.
.RE
.RE
.PP
The function `tcstrucstoutf' is used in order to convert a UCS\-2 array into a UTF\-8 string.
.PP
.RS
.br
\fBvoid tcstrucstoutf(const uint16_t *\fIary\fB, int \fInum\fB, char *\fIstr\fB);\fR
.RS
`\fIary\fR' specifies the array of UCS\-2 code codes.
.RE
.RS
`\fInum\fR' specifies the number of the array.
.RE
.RS
`\fIstr\fR' specifies the pointer to the region into which the result UTF\-8 string is written.  The size of the buffer should be sufficient.
.RE
.RE
.PP
The function `tcstrsplit' is used in order to create a list object by splitting a string.
.PP
.RS
.br
\fBTCLIST *tcstrsplit(const char *\fIstr\fB, const char *\fIdelims\fB);\fR
.RS
`\fIstr\fR' specifies the source string.
.RE
.RS
`\fIdelims\fR' specifies a string containing delimiting characters.
.RE
.RS
The return value is a list object of the split elements.
.RE
.RS
If two delimiters are successive, it is assumed that an empty element is between the two.  Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.
.RE
.RE
.PP
The function `tcstrjoin' is used in order to create a string by joining all elements of a list object.
.PP
.RS
.br
\fBchar *tcstrjoin(const TCLIST *\fIlist\fB, char \fIdelim\fB);\fR
.RS
`\fIlist\fR' specifies a list object.
.RE
.RS
`\fIdelim\fR' specifies a delimiting character.
.RE
.RS
The return value is the result string.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcatoi' is used in order to convert a string to an integer.
.PP
.RS
.br
\fBint64_t tcatoi(const char *\fIstr\fB);\fR
.RS
`\fIstr\fR' specifies a string.
.RE
.RS
The return value is the integer.  If the string does not contain numeric expression, 0 is returned.
.RE
.RS
This function is equivalent to `atoll' except that it does not depend on the locale.
.RE
.RE
.PP
The function `tcatoix' is used in order to convert a string with a metric prefix to an integer.
.PP
.RS
.br
\fBint64_t tcatoix(const char *\fIstr\fB);\fR
.RS
`\fIstr\fR' specifies a string which can be trailed by a binary metric prefix.  "K", "M", "G", "T", "P", and "E" are supported.  They are case\-insensitive.
.RE
.RS
The return value is the integer.  If the string does not contain numeric expression, 0 is returned.  If the integer overflows the domain, `INT64_MAX' or `INT64_MIN' is returned according to the sign.
.RE
.RE
.PP
The function `tcatof' is used in order to convert a string to a real number.
.PP
.RS
.br
\fBdouble tcatof(const char *\fIstr\fB);\fR
.RS
`\fIstr\fR' specifies a string.
.RE
.RS
The return value is the real number.  If the string does not contain numeric expression, 0.0 is returned.
.RE
.RS
This function is equivalent to `atof' except that it does not depend on the locale.
.RE
.RE
.PP
The function `tcregexmatch' is used in order to check whether a string matches a regular expression.
.PP
.RS
.br
\fBbool tcregexmatch(const char *\fIstr\fB, const char *\fIregex\fB);\fR
.RS
`\fIstr\fR' specifies the target string.
.RE
.RS
`\fIregex\fR' specifies the regular expression string.  If it begins with `*', the trailing substring is used as a case\-insensitive regular expression.
.RE
.RS
The return value is true if matching is success, else, it is false.
.RE
.RE
.PP
The function `tcregexreplace' is used in order to replace each substring matching a regular expression string.
.PP
.RS
.br
\fBchar *tcregexreplace(const char *\fIstr\fB, const char *\fIregex\fB, const char *\fIalt\fB);\fR
.RS
`\fIstr\fR' specifies the target string.
.RE
.RS
`\fIregex\fR' specifies the regular expression string for substrings.  If it begins with `*', the trailing substring is used as a case\-insensitive regular expression.
.RE
.RS
`\fIalt\fR' specifies the alternative string with which each substrings is replaced.  Each `&' in the string is replaced with the matched substring.  Each `\' in the string escapes the following character.  Special escapes "\1" through "\9" referring to the corresponding matching sub\-expressions in the regular expression string are supported.
.RE
.RS
The return value is a new converted string.  Even if the regular expression is invalid, a copy of the original string is returned.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcmd5hash' is used in order to get the MD5 hash value of a record.
.PP
.RS
.br
\fBvoid tcmd5hash(const void *\fIptr\fB, int \fIsize\fB, char *\fIbuf\fB);\fR
.RS
`\fIptr\fR' specifies the pointer to the region of the record.
.RE
.RS
`\fIsize\fR' specifies the size of the region.
.RE
.RS
`\fIbuf\fR' specifies the pointer to the region into which the result string is written.  The size of the buffer should be equal to or more than 48 bytes.
.RE
.RE
.PP
The function `tcchidxnew' is used in order to create a consistent hashing object.
.PP
.RS
.br
\fBTCCHIDX *tcchidxnew(int \fIrange\fB);\fR
.RS
`\fIrange\fR' specifies the number of nodes.  It should be more than 0.  The range of hash values is from 0 to less than the specified number.
.RE
.RS
The return value is the new consistent hashing object.
.RE
.RS
Consistent hashing is useful because the addition or removal of one node does not significantly change the mapping of keys to nodes.
.RE
.RE
.PP
The function `tcchidxdel' is used in order to delete a consistent hashing object.
.PP
.RS
.br
\fBvoid tcchidxdel(TCCHIDX *\fIchidx\fB);\fR
.RS
`\fIchidx\fR' specifies the consistent hashing object.
.RE
.RE
.PP
The function `tcchidxhash' is used in order to get the consistent hashing value of a record.
.PP
.RS
.br
\fBint tcchidxhash(TCCHIDX *\fIchidx\fB, const void *\fIptr\fB, int \fIsize\fB);\fR
.RS
`\fIchidx\fR' specifies the consistent hashing object.
.RE
.RS
`\fIptr\fR' specifies the pointer to the region of the record.
.RE
.RS
`\fIsize\fR' specifies the size of the region.
.RE
.RS
The return value is the hash value of the record.
.RE
.RE
.PP
The function `tctime' is used in order to get the time of day in seconds.
.PP
.RS
.br
\fBdouble tctime(void);\fR
.RS
The return value is the time of day in seconds.  The accuracy is in microseconds.
.RE
.RE
.PP
The function `tccalendar' is used in order to get the Gregorian calendar of a time.
.PP
.RS
.br
\fBvoid tccalendar(int64_t \fIt\fB, int \fIjl\fB, int *\fIyearp\fB, int *\fImonp\fB, int *\fIdayp\fB, int *\fIhourp\fB, int *\fIminp\fB, int *\fIsecp\fB);\fR
.RS
`\fIt\fR' specifies the source time in seconds from the epoch.  If it is `INT64_MAX', the current time is specified.
.RE
.RS
`\fIjl\fR' specifies the jet lag of a location in seconds.  If it is `INT_MAX', the local jet lag is specified.
.RE
.RS
`\fIyearp\fR' specifies the pointer to a variable to which the year is assigned.  If it is `NULL', it is not used.
.RE
.RS
`\fImonp\fR' specifies the pointer to a variable to which the month is assigned.  If it is `NULL', it is not used.  1 means January and 12 means December.
.RE
.RS
`\fIdayp\fR' specifies the pointer to a variable to which the day of the month is assigned.  If it is `NULL', it is not used.
.RE
.RS
`\fIhourp\fR' specifies the pointer to a variable to which the hours is assigned.  If it is `NULL', it is not used.
.RE
.RS
`\fIminp\fR' specifies the pointer to a variable to which the minutes is assigned.  If it is `NULL', it is not used.
.RE
.RS
`\fIsecp\fR' specifies the pointer to a variable to which the seconds is assigned.  If it is `NULL', it is not used.
.RE
.RE
.PP
The function `tcdatestrwww' is used in order to format a date as a string in W3CDTF.
.PP
.RS
.br
\fBvoid tcdatestrwww(int64_t \fIt\fB, int \fIjl\fB, char *\fIbuf\fB);\fR
.RS
`\fIt\fR' specifies the source time in seconds from the epoch.  If it is `INT64_MAX', the current time is specified.
.RE
.RS
`\fIjl\fR' specifies the jet lag of a location in seconds.  If it is `INT_MAX', the local jet lag is specified.
.RE
.RS
`\fIbuf\fR' specifies the pointer to the region into which the result string is written.  The size of the buffer should be equal to or more than 48 bytes.
.RE
.RS
W3CDTF represents a date as "YYYY\-MM\-DDThh:mm:ddTZD".
.RE
.RE
.PP
The function `tcdatestrhttp' is used in order to format a date as a string in RFC 1123 format.
.PP
.RS
.br
\fBvoid tcdatestrhttp(int64_t \fIt\fB, int \fIjl\fB, char *\fIbuf\fB);\fR
.RS
`\fIt\fR' specifies the source time in seconds from the epoch.  If it is `INT64_MAX', the current time is specified.
.RE
.RS
`\fIjl\fR' specifies the jet lag of a location in seconds.  If it is `INT_MAX', the local jet lag is specified.
.RE
.RS
`\fIbuf\fR' specifies the pointer to the region into which the result string is written.  The size of the buffer should be equal to or more than 48 bytes.
.RE
.RS
RFC 1123 format represents a date as "Wdy, DD\-Mon\-YYYY hh:mm:dd TZD".
.RE
.RE
.PP
The function `tcstrmktime' is used in order to get the time value of a date string.
.PP
.RS
.br
\fBint64_t tcstrmktime(const char *\fIstr\fB);\fR
.RS
`\fIstr\fR' specifies the date string in decimal, hexadecimal, W3CDTF, or RFC 822 (1123).  Decimal can be trailed by "s" for in seconds, "m" for in minutes, "h" for in hours, and "d" for in days.
.RE
.RS
The return value is the time value of the date or `INT64_MAX' if the format is invalid.
.RE
.RE
.PP
The function `tcjetlag' is used in order to get the jet lag of the local time.
.PP
.RS
.br
\fBint tcjetlag(void);\fR
.RS
The return value is the jet lag of the local time in seconds.
.RE
.RE
.PP
The function `tcdayofweek' is used in order to get the day of week of a date.
.PP
.RS
.br
\fBint tcdayofweek(int \fIyear\fB, int \fImon\fB, int \fIday\fB);\fR
.RS
`\fIyear\fR' specifies the year of a date.
.RE
.RS
`\fImon\fR' specifies the month of the date.
.RE
.RS
`\fIday\fR' specifies the day of the date.
.RE
.RS
The return value is the day of week of the date.  0 means Sunday and 6 means Saturday.
.RE
.RE

.SH API OF FILESYSTEM UTILITIES
.PP
The function `tcrealpath' is used in order to get the canonicalized absolute path of a file.
.PP
.RS
.br
\fBchar *tcrealpath(const char *\fIpath\fB);\fR
.RS
`\fIpath\fR' specifies the path of the file.
.RE
.RS
The return value is the canonicalized absolute path of a file, or `NULL' if the path is invalid.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcreadfile' is used in order to read whole data of a file.
.PP
.RS
.br
\fBvoid *tcreadfile(const char *\fIpath\fB, int \fIlimit\fB, int *\fIsp\fB);\fR
.RS
`\fIpath\fR' specifies the path of the file.  If it is `NULL', the standard input is specified.
.RE
.RS
`\fIlimit\fR' specifies the limiting size of reading data.  If it is not more than 0, the limitation is not specified.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.  If it is `NULL', it is not used.
.RE
.RS
The return value is the pointer to the allocated region of the read data, or `NULL' if the file could not be opened.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when when is no longer in use.
.RE
.RE
.PP
The function `tcreadfilelines' is used in order to read every line of a file.
.PP
.RS
.br
\fBTCLIST *tcreadfilelines(const char *\fIpath\fB);\fR
.RS
`\fIpath\fR' specifies the path of the file.  If it is `NULL', the standard input is specified.
.RE
.RS
The return value is a list object of every lines if successful, else it is `NULL'.
.RE
.RS
Line separators are cut out.  Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.
.RE
.RE
.PP
The function `tcwritefile' is used in order to write data into a file.
.PP
.RS
.br
\fBbool tcwritefile(const char *\fIpath\fB, const void *\fIptr\fB, int \fIsize\fB);\fR
.RS
`\fIpath\fR' specifies the path of the file.  If it is `NULL', the standard output is specified.
.RE
.RS
`\fIptr\fR' specifies the pointer to the data region.
.RE
.RS
`\fIsize\fR' specifies the size of the region.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tccopyfile' is used in order to copy a file.
.PP
.RS
.br
\fBbool tccopyfile(const char *\fIsrc\fB, const char *\fIdest\fB);\fR
.RS
`\fIsrc\fR' specifies the path of the source file.
.RE
.RS
`\fIdest\fR' specifies the path of the destination file.
.RE
.RS
The return value is true if successful, else, it is false.
.RE
.RS
If the destination file exists, it is overwritten.
.RE
.RE
.PP
The function `tcreaddir' is used in order to read names of files in a directory.
.PP
.RS
.br
\fBTCLIST *tcreaddir(const char *\fIpath\fB);\fR
.RS
`\fIpath\fR' specifies the path of the directory.
.RE
.RS
The return value is a list object of names if successful, else it is `NULL'.
.RE
.RS
Links to the directory itself and to the parent directory are ignored.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.
.RE
.RE
.PP
The function `tcglobpat' is used in order to expand a pattern into a list of matched paths.
.PP
.RS
.br
\fBTCLIST *tcglobpat(const char *\fIpattern\fB);\fR
.RS
`\fIpattern\fR' specifies the matching pattern.
.RE
.RS
The return value is a list object of matched paths.  If no path is matched, an empty list is returned.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.
.RE
.RE
.PP
The function `tcremovelink' is used in order to remove a file or a directory and its sub ones recursively.
.PP
.RS
.br
\fBbool tcremovelink(const char *\fIpath\fB);\fR
.RS
`\fIpath\fR' specifies the path of the link.
.RE
.RS
If successful, the return value is true, else, it is false.  False is returned when the link does not exist or the permission is denied.
.RE
.RE
.PP
The function `tcwrite' is used in order to write data into a file.
.PP
.RS
.br
\fBbool tcwrite(int \fIfd\fB, const void *\fIbuf\fB, size_t \fIsize\fB);\fR
.RS
`\fIfd\fR' specifies the file descriptor.
.RE
.RS
`\fIbuf\fR' specifies the buffer to be written.
.RE
.RS
`\fIsize\fR' specifies the size of the buffer.
.RE
.RS
The return value is true if successful, else, it is false.
.RE
.RE
.PP
The function `tcread' is used in order to read data from a file.
.PP
.RS
.br
\fBbool tcread(int \fIfd\fB, void *\fIbuf\fB, size_t \fIsize\fB);\fR
.RS
`\fIfd\fR' specifies the file descriptor.
.RE
.RS
`\fIbuf\fR' specifies the buffer to store into.
.RE
.RS
`\fIsize\fR' specifies the size of the buffer.
.RE
.RS
The return value is true if successful, else, it is false.
.RE
.RE
.PP
The function `tclock' is used in order to lock a file.
.PP
.RS
.br
\fBbool tclock(int \fIfd\fB, bool \fIex\fB, bool \fInb\fB);\fR
.RS
`\fIfd\fR' specifies the file descriptor.
.RE
.RS
`\fIex\fR' specifies whether an exclusive lock or a shared lock is performed.
.RE
.RS
`\fInb\fR' specifies whether to request with non\-blocking.
.RE
.RS
The return value is true if successful, else, it is false.
.RE
.RE
.PP
The function `tcunlock' is used in order to unlock a file.
.PP
.RS
.br
\fBbool tcunlock(int \fIfd\fB);\fR
.RS
`\fIfd\fR' specifies the file descriptor.
.RE
.RS
The return value is true if successful, else, it is false.
.RE
.RE
.PP
The function `tcsystem' is used in order to execute a shell command.
.PP
.RS
.br
\fBint tcsystem(const char **\fIargs\fB, int \fIanum\fB);\fR
.RS
`\fIargs\fR' specifies an array of the command name and its arguments.
.RE
.RS
`\fIanum\fR' specifies the number of elements of the array.
.RE
.RS
The return value is the exit code of the command or `INT_MAX' on failure.
.RE
.RS
The command name and the arguments are quoted and meta characters are escaped.
.RE
.RE

.SH API OF ENCODING UTILITIES
.PP
The function `tcurlencode' is used in order to encode a serial object with URL encoding.
.PP
.RS
.br
\fBchar *tcurlencode(const char *\fIptr\fB, int \fIsize\fB);\fR
.RS
`\fIptr\fR' specifies the pointer to the region.
.RE
.RS
`\fIsize\fR' specifies the size of the region.
.RE
.RS
The return value is the result string.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if when is no longer in use.
.RE
.RE
.PP
The function `tcurldecode' is used in order to decode a string encoded with URL encoding.
.PP
.RS
.br
\fBchar *tcurldecode(const char *\fIstr\fB, int *\fIsp\fB);\fR
.RS
`\fIstr\fR' specifies the encoded string.
.RE
.RS
`\fIsp\fR' specifies the pointer to a variable into which the size of the region of the return value is assigned.
.RE
.RS
The return value is the pointer to the region of the result.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcurlbreak' is used in order to break up a URL into elements.
.PP
.RS
.br
\fBTCMAP *tcurlbreak(const char *\fIstr\fB);\fR
.RS
`\fIstr\fR' specifies the URL string.
.RE
.RS
The return value is the map object whose keys are the name of elements.  The key "self" specifies the URL itself.  The key "scheme" specifies the scheme.  The key "host" specifies the host of the server.  The key "port" specifies the port number of the server.  The key "authority" specifies the authority information.  The key "path" specifies the path of the resource.  The key "file" specifies the file name without the directory section.  The key "query" specifies the query string.  The key "fragment" specifies the fragment string.
.RE
.RS
Supported schema are HTTP, HTTPS, FTP, and FILE.  Absolute URL and relative URL are supported.  Because the object of the return value is created with the function `tcmapnew', it should be deleted with the function `tcmapdel' when it is no longer in use.
.RE
.RE
.PP
The function `tcurlresolve' is used in order to resolve a relative URL with an absolute URL.
.PP
.RS
.br
\fBchar *tcurlresolve(const char *\fIbase\fB, const char *\fItarget\fB);\fR
.RS
`\fIbase\fR' specifies the absolute URL of the base location.
.RE
.RS
`\fItarget\fR' specifies the URL to be resolved.
.RE
.RS
The return value is the resolved URL.  If the target URL is relative, a new URL of relative location from the base location is returned.  Else, a copy of the target URL is returned.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcbaseencode' is used in order to encode a serial object with Base64 encoding.
.PP
.RS
.br
\fBchar *tcbaseencode(const char *\fIptr\fB, int \fIsize\fB);\fR
.RS
`\fIptr\fR' specifies the pointer to the region.
.RE
.RS
`\fIsize\fR' specifies the size of the region.
.RE
.RS
The return value is the result string.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if when is no longer in use.
.RE
.RE
.PP
The function `tcbasedecode' is used in order to decode a string encoded with Base64 encoding.
.PP
.RS
.br
\fBchar *tcbasedecode(const char *\fIstr\fB, int *\fIsp\fB);\fR
.RS
`\fIstr\fR' specifies the encoded string.
.RE
.RS
`\fIsp\fR' specifies the pointer to a variable into which the size of the region of the return value is assigned.
.RE
.RS
The return value is the pointer to the region of the result.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcquoteencode' is used in order to encode a serial object with Quoted\-printable encoding.
.PP
.RS
.br
\fBchar *tcquoteencode(const char *\fIptr\fB, int \fIsize\fB);\fR
.RS
`\fIptr\fR' specifies the pointer to the region.
.RE
.RS
`\fIsize\fR' specifies the size of the region.
.RE
.RS
The return value is the result string.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if when is no longer in use.
.RE
.RE
.PP
The function `tcquotedecode' is used in order to decode a string encoded with Quoted\-printable encoding.
.PP
.RS
.br
\fBchar *tcquotedecode(const char *\fIstr\fB, int *\fIsp\fB);\fR
.RS
`\fIstr\fR' specifies the encoded string.
.RE
.RS
`\fIsp\fR' specifies the pointer to a variable into which the size of the region of the return value is assigned.
.RE
.RS
The return value is the pointer to the region of the result.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcmimeencode' is used in order to encode a string with MIME encoding.
.PP
.RS
.br
\fBchar *tcmimeencode(const char *\fIstr\fB, const char *\fIencname\fB, bool \fIbase\fB);\fR
.RS
`\fIstr\fR' specifies the string.
.RE
.RS
`\fIencname\fR' specifies the string of the name of the character encoding.
.RE
.RS
`\fIbase\fR' specifies whether to use Base64 encoding.  If it is false, Quoted\-printable is used.
.RE
.RS
The return value is the result string.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcmimedecode' is used in order to decode a string encoded with MIME encoding.
.PP
.RS
.br
\fBchar *tcmimedecode(const char *\fIstr\fB, char *\fIenp\fB);\fR
.RS
`\fIstr\fR' specifies the encoded string.
.RE
.RS
`\fIenp\fR' specifies the pointer to the region into which the name of encoding is written.  If it is `NULL', it is not used.  The size of the buffer should be equal to or more than 32 bytes.
.RE
.RS
The return value is the result string.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcmimebreak' is used in order to split a string of MIME into headers and the body.
.PP
.RS
.br
\fBchar *tcmimebreak(const char *\fIptr\fB, int \fIsize\fB, TCMAP *\fIheaders\fB, int *\fIsp\fB);\fR
.RS
`\fIptr\fR' specifies the pointer to the region of MIME data.
.RE
.RS
`\fIsize\fR' specifies the size of the region.
.RE
.RS
`\fIheaders\fR' specifies a map object to store headers.  If it is `NULL', it is not used.  Each key of the map is an uncapitalized header name.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
The return value is the pointer to the region of the body data.
.RE
.RS
If the content type is defined, the header map has the key "TYPE" specifying the type.  If the character encoding is defined, the key "CHARSET" specifies the encoding name.  If the boundary string of multipart is defined, the key "BOUNDARY" specifies the string.  If the content disposition is defined, the key "DISPOSITION" specifies the direction.  If the file name is defined, the key "FILENAME" specifies the name.  If the attribute name is defined, the key "NAME" specifies the name.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcmimeparts' is used in order to split multipart data of MIME into its parts.
.PP
.RS
.br
\fBTCLIST *tcmimeparts(const char *\fIptr\fB, int \fIsize\fB, const char *\fIboundary\fB);\fR
.RS
`\fIptr\fR' specifies the pointer to the region of multipart data of MIME.
.RE
.RS
`\fIsize\fR' specifies the size of the region.
.RE
.RS
`\fIboundary\fR' specifies the boundary string.
.RE
.RS
The return value is a list object.  Each element of the list is the data of a part.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.
.RE
.RE
.PP
The function `tchexencode' is used in order to encode a serial object with hexadecimal encoding.
.PP
.RS
.br
\fBchar *tchexencode(const char *\fIptr\fB, int \fIsize\fB);\fR
.RS
`\fIptr\fR' specifies the pointer to the region.
.RE
.RS
`\fIsize\fR' specifies the size of the region.
.RE
.RS
The return value is the result string.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if when is no longer in use.
.RE
.RE
.PP
The function `tchexdecode' is used in order to decode a string encoded with hexadecimal encoding.
.PP
.RS
.br
\fBchar *tchexdecode(const char *\fIstr\fB, int *\fIsp\fB);\fR
.RS
`\fIstr\fR' specifies the encoded string.
.RE
.RS
`\fIsp\fR' specifies the pointer to a variable into which the size of the region of the return
.RE
.RS
value is assigned.
.RE
.RS
The return value is the pointer to the region of the result.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcpackencode' is used in order to compress a serial object with Packbits encoding.
.PP
.RS
.br
\fBchar *tcpackencode(const char *\fIptr\fB, int \fIsize\fB, int *\fIsp\fB);\fR
.RS
`\fIptr\fR' specifies the pointer to the region.
.RE
.RS
`\fIsize\fR' specifies the size of the region.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the result object, else, it is `NULL'.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcpackdecode' is used in order to decompress a serial object compressed with Packbits encoding.
.PP
.RS
.br
\fBchar *tcpackdecode(const char *\fIptr\fB, int \fIsize\fB, int *\fIsp\fB);\fR
.RS
`\fIptr\fR' specifies the pointer to the region.
.RE
.RS
`\fIsize\fR' specifies the size of the region.
.RE
.RS
`\fIsp\fR' specifies the pointer to a variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the result object, else, it is `NULL'.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcbsencode' is used in order to compress a serial object with TCBS encoding.
.PP
.RS
.br
\fBchar *tcbsencode(const char *\fIptr\fB, int \fIsize\fB, int *\fIsp\fB);\fR
.RS
`\fIptr\fR' specifies the pointer to the region.
.RE
.RS
`\fIsize\fR' specifies the size of the region.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the result object, else, it is `NULL'.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcbsdecode' is used in order to decompress a serial object compressed with TCBS encoding.
.PP
.RS
.br
\fBchar *tcbsdecode(const char *\fIptr\fB, int \fIsize\fB, int *\fIsp\fB);\fR
.RS
`\fIptr\fR' specifies the pointer to the region.
.RE
.RS
`\fIsize\fR' specifies the size of the region.
.RE
.RS
`\fIsp\fR' specifies the pointer to a variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the result object, else, it is `NULL'.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcdeflate' is used in order to compress a serial object with Deflate encoding.
.PP
.RS
.br
\fBchar *tcdeflate(const char *\fIptr\fB, int \fIsize\fB, int *\fIsp\fB);\fR
.RS
`\fIptr\fR' specifies the pointer to the region.
.RE
.RS
`\fIsize\fR' specifies the size of the region.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the result object, else, it is `NULL'.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcinflate' is used in order to decompress a serial object compressed with Deflate encoding.
.PP
.RS
.br
\fBchar *tcinflate(const char *\fIptr\fB, int \fIsize\fB, int *\fIsp\fB);\fR
.RS
`\fIptr\fR' specifies the pointer to the region.
.RE
.RS
`\fIsize\fR' specifies the size of the region.
.RE
.RS
`\fIsp\fR' specifies the pointer to a variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the result object, else, it is `NULL'.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcgzipencode' is used in order to compress a serial object with GZIP encoding.
.PP
.RS
.br
\fBchar *tcgzipencode(const char *\fIptr\fB, int \fIsize\fB, int *\fIsp\fB);\fR
.RS
`\fIptr\fR' specifies the pointer to the region.
.RE
.RS
`\fIsize\fR' specifies the size of the region.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the result object, else, it is `NULL'.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcgzipdecode' is used in order to decompress a serial object compressed with GZIP encoding.
.PP
.RS
.br
\fBchar *tcgzipdecode(const char *\fIptr\fB, int \fIsize\fB, int *\fIsp\fB);\fR
.RS
`\fIptr\fR' specifies the pointer to the region.
.RE
.RS
`\fIsize\fR' specifies the size of the region.
.RE
.RS
`\fIsp\fR' specifies the pointer to a variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the result object, else, it is `NULL'.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcgetcrc' is used in order to get the CRC32 checksum of a serial object.
.PP
.RS
.br
\fBunsigned int tcgetcrc(const char *\fIptr\fB, int \fIsize\fB);\fR
.RS
`\fIptr\fR' specifies the pointer to the region.
.RE
.RS
`\fIsize\fR' specifies the size of the region.
.RE
.RS
The return value is the CRC32 checksum of the object.
.RE
.RE
.PP
The function `tcbzipencode' is used in order to compress a serial object with BZIP2 encoding.
.PP
.RS
.br
\fBchar *tcbzipencode(const char *\fIptr\fB, int \fIsize\fB, int *\fIsp\fB);\fR
.RS
`\fIptr\fR' specifies the pointer to the region.
.RE
.RS
`\fIsize\fR' specifies the size of the region.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the result object, else, it is `NULL'.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcbzipdecode' is used in order to decompress a serial object compressed with BZIP2 encoding.
.PP
.RS
.br
\fBchar *tcbzipdecode(const char *\fIptr\fB, int \fIsize\fB, int *\fIsp\fB);\fR
.RS
`\fIptr\fR' specifies the pointer to the region.
.RE
.RS
`\fIsize\fR' specifies the size of the region.
.RE
.RS
`\fIsp\fR' specifies the pointer to a variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the result object, else, it is `NULL'.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcberencode' is used in order to encode an array of nonnegative integers with BER encoding.
.PP
.RS
.br
\fBchar *tcberencode(const unsigned int *\fIary\fB, int \fIanum\fB, int *\fIsp\fB);\fR
.RS
`\fIary\fR' specifies the pointer to the array of nonnegative integers.
.RE
.RS
`\fIanum\fR' specifies the size of the array.
.RE
.RS
`\fIsp\fR' specifies the pointer to a variable into which the size of the region of the return value is assigned.
.RE
.RS
The return value is the pointer to the region of the result.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if when is no longer in use.
.RE
.RE
.PP
The function `tcberdecode' is used in order to decode a serial object encoded with BER encoding.
.PP
.RS
.br
\fBunsigned int *tcberdecode(const char *\fIptr\fB, int \fIsize\fB, int *\fInp\fB);\fR
.RS
`\fIptr\fR' specifies the pointer to the region.
.RE
.RS
`\fIsize\fR' specifies the size of the region.
.RE
.RS
`\fInp\fR' specifies the pointer to a variable into which the number of elements of the return value is assigned.
.RE
.RS
The return value is the pointer to the array of the result.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if when is no longer in use.
.RE
.RE
.PP
The function `tcxmlescape' is used in order to escape meta characters in a string with the entity references of XML.
.PP
.RS
.br
\fBchar *tcxmlescape(const char *\fIstr\fB);\fR
.RS
`\fIstr\fR' specifies the string.
.RE
.RS
The return value is the pointer to the escaped string.
.RE
.RS
This function escapes only `&', `<', `>', and `"'.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcxmlunescape' is used in order to unescape entity references in a string of XML.
.PP
.RS
.br
\fBchar *tcxmlunescape(const char *\fIstr\fB);\fR
.RS
`\fIstr\fR' specifies the string.
.RE
.RS
The return value is the unescaped string.
.RE
.RS
This function restores only `&amp;', `&lt;', `&gt;', and `&quot;'.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcxmlbreak' is used in order to split an XML string into tags and text sections.
.PP
.RS
.br
\fBTCLIST *tcxmlbreak(const char *\fIstr\fB);\fR
.RS
`\fIstr\fR' specifies the XML string.
.RE
.RS
The return value is the list object whose elements are strings of tags or text sections.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Because this function does not check validation, it can handle also HTML and SGML.
.RE
.RE
.PP
The function `tcxmlattrs' is used in order to get the map of attributes of an XML tag.
.PP
.RS
.br
\fBTCMAP *tcxmlattrs(const char *\fIstr\fB);\fR
.RS
`\fIstr\fR' specifies the pointer to the region of a tag string.
.RE
.RS
The return value is the map object containing attribute names and their values which are unescaped.  You can get the name of the tag with the key of an empty string.
.RE
.RS
Because the object of the return value is created with the function `tcmapnew', it should be deleted with the function `tcmapdel' when it is no longer in use.
.RE
.RE

.SH EXAMPLE CODE
.PP
The following code is an example using extensible string, array list, and hash map.

.SH CLI
.PP
To use the utility API easily, the commands `\fBtcutest\fR', `\fBtcumttest\fR', and `\fBtcucodec\fR' are provided.
.PP
The command `\fBtcutest\fR' is a utility for facility test and performance test.  This command is used in the following format.  `\fIrnum\fR' specifies the number of iterations.  `\fIanum\fR' specifies the initial number of elements of array.  `\fIbnum\fR' specifies the number of buckets.
.PP
.RS
.br
\fBtcutest xstr \fIrnum\fB\fR
.RS
Perform test of extensible string.
.RE
.br
\fBtcutest list \fR[\fB\-rd\fR]\fB \fIrnum\fB \fR[\fB\fIanum\fB\fR]\fB\fR
.RS
Perform test of array list.
.RE
.br
\fBtcutest map \fR[\fB\-rd\fR]\fB \fR[\fB\-tr\fR]\fB \fR[\fB\-rnd\fR]\fB \fR[\fB\-dk\fR|\fB\-dc\fR|\fB\-dai\fR|\fB\-dad\fR|\fB\-dpr\fR]\fB \fIrnum\fB \fR[\fB\fIbnum\fB\fR]\fB\fR
.RS
Perform test of hash map.
.RE
.br
\fBtcutest tree \fR[\fB\-rd\fR]\fB \fR[\fB\-tr\fR]\fB \fR[\fB\-rnd\fR]\fB \fR[\fB\-dk\fR|\fB\-dc\fR|\fB\-dai\fR|\fB\-dad\fR|\fB\-dpr\fR]\fB \fIrnum\fB\fR
.RS
Perform test of ordered tree.
.RE
.br
\fBtcutest mdb \fR[\fB\-rd\fR]\fB \fR[\fB\-tr\fR]\fB \fR[\fB\-rnd\fR]\fB \fR[\fB\-dk\fR|\fB\-dc\fR|\fB\-dai\fR|\fB\-dad\fR|\fB\-dpr\fR]\fB \fIrnum\fB \fR[\fB\fIbnum\fB\fR]\fB\fR
.RS
Perform test of on\-memory hash database.
.RE
.br
\fBtcutest ndb \fR[\fB\-rd\fR]\fB \fR[\fB\-tr\fR]\fB \fR[\fB\-rnd\fR]\fB \fR[\fB\-dk\fR|\fB\-dc\fR|\fB\-dai\fR|\fB\-dad\fR|\fB\-dpr\fR]\fB \fIrnum\fB\fR
.RS
Perform test of on\-memory tree database.
.RE
.br
\fBtcutest misc \fIrnum\fB\fR
.RS
Perform test of miscellaneous routines.
.RE
.br
\fBtcutest wicked \fIrnum\fB\fR
.RS
Perform updating operations of list and map selected at random.
.RE
.RE
.PP
Options feature the following.
.PP
.RS
\fB\-rd\fR : perform the reading test also.
.br
\fB\-tr\fR : perform the iterator test also.
.br
\fB\-rnd\fR : select keys at random.
.br
\fB\-dk\fR : use the function `tcxxxputkeep' instead of `tcxxxput'.
.br
\fB\-dc\fR : use the function `tcxxxputcat' instead of `tcxxxput'.
.br
\fB\-dai\fR : use the function `tcxxxaddint' instead of `tcxxxput'.
.br
\fB\-dad\fR : use the function `tcxxxadddouble' instead of `tcxxxput'.
.br
\fB\-dpr\fR : use the function `tcxxxputproc' instead of `tcxxxput'.
.br
.RE
.PP
This command returns 0 on success, another on failure.
.PP
The command `\fBtcumttest\fR' is a utility for facility test under multi\-thread situation.  This command is used in the following format.  `\fItnum\fR' specifies the number of running threads.  `\fIrnum\fR' specifies the number of iterations.  `\fIbnum\fR' specifies the number of buckets.
.PP
.RS
.br
\fBtcumttest combo \fR[\fB\-rnd\fR]\fB \fItnum\fB \fIrnum\fB \fR[\fB\fIbnum\fB\fR]\fB\fR
.RS
Peform storing, retrieving, and removing in turn.
.RE
.br
\fBtcumttest typical \fR[\fB\-nc\fR]\fB \fR[\fB\-rr \fInum\fB\fR]\fB \fItnum\fB \fIrnum\fB \fR[\fB\fIbnum\fB\fR]\fB\fR
.RS
Perform typical operations selected at random.
.RE
.RE
.PP
Options feature the following.
.PP
.RS
\fB\-rnd\fR : select keys at random.
.br
\fB\-nc\fR : omit the comparison test.
.br
\fB\-rr \fInum\fR\fR : specify the ratio of reading operation by percentage.
.br
.RE
.PP
This command returns 0 on success, another on failure.
.PP
The command `\fBtcucodec\fR' is a tool to use encoding and decoding features.  This command is used in the following format.  `\fIfile\fR' specifies a input file.  If it is omitted, the standard input is read.
.PP
.RS
.br
\fBtcucodec url \fR[\fB\-d\fR]\fB \fR[\fB\-br\fR]\fB \fR[\fB\-rs \fIbase\fB\fR]\fB \fR[\fB\fIfile\fB\fR]\fB\fR
.RS
Perform URL encoding and its decoding.
.RE
.br
\fBtcucodec base \fR[\fB\-d\fR]\fB \fR[\fB\fIfile\fB\fR]\fB\fR
.RS
Perform Base64 encoding and its decoding.
.RE
.br
\fBtcucodec quote \fR[\fB\-d\fR]\fB \fR[\fB\fIfile\fB\fR]\fB\fR
.RS
Perform quoted\-printable encoding and its decoding.
.RE
.br
\fBtcucodec mime \fR[\fB\-d\fR]\fB \fR[\fB\-en \fIname\fB\fR]\fB \fR[\fB\-q\fR]\fB \fR[\fB\-on\fR]\fB \fR[\fB\-hd\fR]\fB \fR[\fB\-bd\fR]\fB \fR[\fB\-part \fInum\fB\fR]\fB \fR[\fB\fIfile\fB\fR]\fB\fR
.RS
Perform MIME encoding and its decoding.
.RE
.br
\fBtcucodec hex \fR[\fB\-d\fR]\fB \fR[\fB\fIfile\fB\fR]\fB\fR
.RS
Perform hexadecimal encoding and its decoding.
.RE
.br
\fBtcucodec pack \fR[\fB\-d\fR]\fB \fR[\fB\-bwt\fR]\fB \fR[\fB\fIfile\fB\fR]\fB\fR
.RS
Perform Packbits encoding and its decoding.
.RE
.br
\fBtcucodec tcbs \fR[\fB\-d\fR]\fB \fR[\fB\fIfile\fB\fR]\fB\fR
.RS
Perform TCBS encoding and its decoding.
.RE
.br
\fBtcucodec zlib \fR[\fB\-d\fR]\fB \fR[\fB\-gz\fR]\fB \fR[\fB\fIfile\fB\fR]\fB\fR
.RS
Perform ZLIB encoding and its decoding.
.RE
.br
\fBtcucodec bzip \fR[\fB\-d\fR]\fB \fR[\fB\fIfile\fB\fR]\fB\fR
.RS
Perform BZIP2 encoding and its decoding.
.RE
.br
\fBtcucodec xml \fR[\fB\-d\fR]\fB \fR[\fB\-br\fR]\fB \fR[\fB\fIfile\fB\fR]\fB\fR
.RS
Process XML.  By default, escape meta characters.
.RE
.br
\fBtcucodec ucs \fR[\fB\-d\fR]\fB \fR[\fB\fIfile\fB\fR]\fB\fR
.RS
Convert UTF\-8 string into UCS\-2 array.
.RE
.br
\fBtcucodec hash \fR[\fB\-crc\fR]\fB \fR[\fB\-ch \fInum\fB\fR]\fB \fR[\fB\fIfile\fB\fR]\fB\fR
.RS
Calculate the hash value.  By default, use MD5 function.
.RE
.br
\fBtcucodec date \fR[\fB\-ds \fIstr\fB\fR]\fB \fR[\fB\-jl \fInum\fB\fR]\fB \fR[\fB\-wf\fR]\fB \fR[\fB\-rf\fR]\fB\fR
.RS
Process date string.  By default, print the current UNIX time.
.RE
.br
\fBtcucodec conf \fR[\fB\-v\fR|\fB\-i\fR|\fB\-l\fR|\fB\-p\fR]\fB\fR
.RS
Print some configurations.
.RE
.RE
.PP
Options feature the following.
.PP
.RS
\fB\-d\fR : perform decoding (unescaping), not encoding (escaping).
.br
\fB\-br\fR : break up URL or XML into elements.
.br
\fB\-rs \fIbase\fR\fR : specify the base URL and resolve the relative URL.
.br
\fB\-en \fIname\fR\fR : specify the input encoding, which is UTF\-8 by default.
.br
\fB\-q\fR : use quoted\-printable encoding, which is Base64 by default.
.br
\fB\-on\fR : output the charset name when decoding.
.br
\fB\-bd\fR : perform MIME parsing and output the body.
.br
\fB\-hd\fR : perform MIME parsing and output the headers.
.br
\fB\-part \fInum\fR\fR : perform MIME parsing and output the specified part.
.br
\fB\-bwt\fR : convert by BWT as preprocessing.
.br
\fB\-gz\fR : use GZIP format.
.br
\fB\-crc\fR : use CRC32 function.
.br
\fB\-ch \fInum\fR\fR : use consistent hashing function.
.br
\fB\-ds \fIstr\fR\fR : specify the time.
.br
\fB\-jl \fInum\fR\fR : specify the jet lag.
.br
\fB\-wf\fR : format the output in W3CDTF.
.br
\fB\-rf\fR : format the output in RFC 1123 format.
.br
\fB\-v\fR : show the version number of Tokyo Cabinet.
.br
\fB\-i\fR : show options to include the headers of Tokyo Cabinet.
.br
\fB\-l\fR : show options to link the library of Tokyo Cabinet.
.br
\fB\-p\fR : show the directory path of the commands of Tokyo Cabinet.
.br
.RE
.PP
This command returns 0 on success, another on failure.

.SH THE HASH DATABASE API
.PP
Hash database is a file containing a hash table and is handled with the hash database API.  See `\fBtchdb.h\fR' for the entire specification.

.SH DESCRIPTION
.PP
To use the hash database API, include `\fBtcutil.h\fR', `\fBtchdb.h\fR', and related standard header files.  Usually, write the following description near the front of a source file.
.PP
.RS
.br
\fB#include <tcutil.h>\fR
.br
\fB#include <tchdb.h>\fR
.br
\fB#include <stdlib.h>\fR
.br
\fB#include <stdbool.h>\fR
.br
\fB#include <stdint.h>\fR
.RE
.PP
Objects whose type is pointer to `\fBTCHDB\fR' are used to handle hash databases.  A hash database object is created with the function `\fBtchdbnew\fR' and is deleted with the function `\fBtchdbdel\fR'.  To avoid memory leak, it is important to delete every object when it is no longer in use.
.PP
Before operations to store or retrieve records, it is necessary to open a database file and connect the hash database object to it.  The function `\fBtchdbopen\fR' is used to open a database file and the function `\fBtchdbclose\fR' is used to close the database file.  To avoid data missing or corruption, it is important to close every database file when it is no longer in use.

.SH API
.PP
The function `tchdberrmsg' is used in order to get the message string corresponding to an error code.
.PP
.RS
.br
\fBconst char *tchdberrmsg(int \fIecode\fB);\fR
.RS
`\fIecode\fR' specifies the error code.
.RE
.RS
The return value is the message string of the error code.
.RE
.RE
.PP
The function `tchdbnew' is used in order to create a hash database object.
.PP
.RS
.br
\fBTCHDB *tchdbnew(void);\fR
.RS
The return value is the new hash database object.
.RE
.RE
.PP
The function `tchdbdel' is used in order to delete a hash database object.
.PP
.RS
.br
\fBvoid tchdbdel(TCHDB *\fIhdb\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object.
.RE
.RS
If the database is not closed, it is closed implicitly.  Note that the deleted object and its derivatives can not be used anymore.
.RE
.RE
.PP
The function `tchdbecode' is used in order to get the last happened error code of a hash database object.
.PP
.RS
.br
\fBint tchdbecode(TCHDB *\fIhdb\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object.
.RE
.RS
The return value is the last happened error code.
.RE
.RS
The following error codes are defined: `TCESUCCESS' for success, `TCETHREAD' for threading error, `TCEINVALID' for invalid operation, `TCENOFILE' for file not found, `TCENOPERM' for no permission, `TCEMETA' for invalid meta data, `TCERHEAD' for invalid record header, `TCEOPEN' for open error, `TCECLOSE' for close error, `TCETRUNC' for trunc error, `TCESYNC' for sync error, `TCESTAT' for stat error, `TCESEEK' for seek error, `TCEREAD' for read error, `TCEWRITE' for write error, `TCEMMAP' for mmap error, `TCELOCK' for lock error, `TCEUNLINK' for unlink error, `TCERENAME' for rename error, `TCEMKDIR' for mkdir error, `TCERMDIR' for rmdir error, `TCEKEEP' for existing record, `TCENOREC' for no record found, and `TCEMISC' for miscellaneous error.
.RE
.RE
.PP
The function `tchdbsetmutex' is used in order to set mutual exclusion control of a hash database object for threading.
.PP
.RS
.br
\fBbool tchdbsetmutex(TCHDB *\fIhdb\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object which is not opened.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
Note that the mutual exclusion control of the database should be set before the database is opened.
.RE
.RE
.PP
The function `tchdbtune' is used in order to set the tuning parameters of a hash database object.
.PP
.RS
.br
\fBbool tchdbtune(TCHDB *\fIhdb\fB, int64_t \fIbnum\fB, int8_t \fIapow\fB, int8_t \fIfpow\fB, uint8_t \fIopts\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object which is not opened.
.RE
.RS
`\fIbnum\fR' specifies the number of elements of the bucket array.  If it is not more than 0, the default value is specified.  The default value is 131071.  Suggested size of the bucket array is about from 0.5 to 4 times of the number of all records to be stored.
.RE
.RS
`\fIapow\fR' specifies the size of record alignment by power of 2.  If it is negative, the default value is specified.  The default value is 4 standing for 2^4=16.
.RE
.RS
`\fIfpow\fR' specifies the maximum number of elements of the free block pool by power of 2.  If it is negative, the default value is specified.  The default value is 10 standing for 2^10=1024.
.RE
.RS
`\fIopts\fR' specifies options by bitwise\-or: `HDBTLARGE' specifies that the size of the database can be larger than 2GB by using 64\-bit bucket array, `HDBTDEFLATE' specifies that each record is compressed with Deflate encoding, `HDBTBZIP' specifies that each record is compressed with BZIP2 encoding, `HDBTTCBS' specifies that each record is compressed with TCBS encoding.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
Note that the tuning parameters should be set before the database is opened.
.RE
.RE
.PP
The function `tchdbsetcache' is used in order to set the caching parameters of a hash database object.
.PP
.RS
.br
\fBbool tchdbsetcache(TCHDB *\fIhdb\fB, int32_t \fIrcnum\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object which is not opened.
.RE
.RS
`\fIrcnum\fR' specifies the maximum number of records to be cached.  If it is not more than 0, the record cache is disabled.  It is disabled by default.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
Note that the caching parameters should be set before the database is opened.
.RE
.RE
.PP
The function `tchdbsetxmsiz' is used in order to set the size of the extra mapped memory of a hash database object.
.PP
.RS
.br
\fBbool tchdbsetxmsiz(TCHDB *\fIhdb\fB, int64_t \fIxmsiz\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object which is not opened.
.RE
.RS
`\fIxmsiz\fR' specifies the size of the extra mapped memory.  If it is not more than 0, the extra mapped memory is disabled.  The default size is 67108864.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
Note that the mapping parameters should be set before the database is opened.
.RE
.RE
.PP
The function `tchdbopen' is used in order to open a database file and connect a hash database object.
.PP
.RS
.br
\fBbool tchdbopen(TCHDB *\fIhdb\fB, const char *\fIpath\fB, int \fIomode\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object which is not opened.
.RE
.RS
`\fIpath\fR' specifies the path of the database file.
.RE
.RS
`\fIomode\fR' specifies the connection mode: `HDBOWRITER' as a writer, `HDBOREADER' as a reader.  If the mode is `HDBOWRITER', the following may be added by bitwise\-or: `HDBOCREAT', which means it creates a new database if not exist, `HDBOTRUNC', which means it creates a new database regardless if one exists, `HDBOTSYNC', which means every transaction synchronizes updated contents with the device.  Both of `HDBOREADER' and `HDBOWRITER' can be added to by bitwise\-or: `HDBONOLCK', which means it opens the database file without file locking, or `HDBOLCKNB', which means locking is performed without blocking.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tchdbclose' is used in order to close a hash database object.
.PP
.RS
.br
\fBbool tchdbclose(TCHDB *\fIhdb\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
Update of a database is assured to be written when the database is closed.  If a writer opens a database but does not close it appropriately, the database will be broken.
.RE
.RE
.PP
The function `tchdbput' is used in order to store a record into a hash database object.
.PP
.RS
.br
\fBbool tchdbput(TCHDB *\fIhdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, const void *\fIvbuf\fB, int \fIvsiz\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object connected as a writer.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, it is overwritten.
.RE
.RE
.PP
The function `tchdbput2' is used in order to store a string record into a hash database object.
.PP
.RS
.br
\fBbool tchdbput2(TCHDB *\fIhdb\fB, const char *\fIkstr\fB, const char *\fIvstr\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object connected as a writer.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
`\fIvstr\fR' specifies the string of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, it is overwritten.
.RE
.RE
.PP
The function `tchdbputkeep' is used in order to store a new record into a hash database object.
.PP
.RS
.br
\fBbool tchdbputkeep(TCHDB *\fIhdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, const void *\fIvbuf\fB, int \fIvsiz\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object connected as a writer.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, this function has no effect.
.RE
.RE
.PP
The function `tchdbputkeep2' is used in order to store a new string record into a hash database object.
.PP
.RS
.br
\fBbool tchdbputkeep2(TCHDB *\fIhdb\fB, const char *\fIkstr\fB, const char *\fIvstr\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object connected as a writer.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
`\fIvstr\fR' specifies the string of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, this function has no effect.
.RE
.RE
.PP
The function `tchdbputcat' is used in order to concatenate a value at the end of the existing record in a hash database object.
.PP
.RS
.br
\fBbool tchdbputcat(TCHDB *\fIhdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, const void *\fIvbuf\fB, int \fIvsiz\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object connected as a writer.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If there is no corresponding record, a new record is created.
.RE
.RE
.PP
The function `tchdbputcat2' is used in order to concatenate a string value at the end of the existing record in a hash database object.
.PP
.RS
.br
\fBbool tchdbputcat2(TCHDB *\fIhdb\fB, const char *\fIkstr\fB, const char *\fIvstr\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object connected as a writer.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
`\fIvstr\fR' specifies the string of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If there is no corresponding record, a new record is created.
.RE
.RE
.PP
The function `tchdbputasync' is used in order to store a record into a hash database object in asynchronous fashion.
.PP
.RS
.br
\fBbool tchdbputasync(TCHDB *\fIhdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, const void *\fIvbuf\fB, int \fIvsiz\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object connected as a writer.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, it is overwritten.  Records passed to this function are accumulated into the inner buffer and wrote into the file at a blast.
.RE
.RE
.PP
The function `tchdbputasync2' is used in order to store a string record into a hash database object in asynchronous fashion.
.PP
.RS
.br
\fBbool tchdbputasync2(TCHDB *\fIhdb\fB, const char *\fIkstr\fB, const char *\fIvstr\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object connected as a writer.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
`\fIvstr\fR' specifies the string of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, it is overwritten.  Records passed to this function are accumulated into the inner buffer and wrote into the file at a blast.
.RE
.RE
.PP
The function `tchdbout' is used in order to remove a record of a hash database object.
.PP
.RS
.br
\fBbool tchdbout(TCHDB *\fIhdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object connected as a writer.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tchdbout2' is used in order to remove a string record of a hash database object.
.PP
.RS
.br
\fBbool tchdbout2(TCHDB *\fIhdb\fB, const char *\fIkstr\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object connected as a writer.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tchdbget' is used in order to retrieve a record in a hash database object.
.PP
.RS
.br
\fBvoid *tchdbget(TCHDB *\fIhdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, int *\fIsp\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned if no record corresponds.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tchdbget2' is used in order to retrieve a string record in a hash database object.
.PP
.RS
.br
\fBchar *tchdbget2(TCHDB *\fIhdb\fB, const char *\fIkstr\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned if no record corresponds.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tchdbget3' is used in order to retrieve a record in a hash database object and write the value into a buffer.
.PP
.RS
.br
\fBint tchdbget3(TCHDB *\fIhdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, void *\fIvbuf\fB, int \fImax\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the buffer into which the value of the corresponding record is written.
.RE
.RS
`\fImax\fR' specifies the size of the buffer.
.RE
.RS
If successful, the return value is the size of the written data, else, it is \-1.  \-1 is returned if no record corresponds to the specified key.
.RE
.RS
Note that an additional zero code is not appended at the end of the region of the writing buffer.
.RE
.RE
.PP
The function `tchdbvsiz' is used in order to get the size of the value of a record in a hash database object.
.PP
.RS
.br
\fBint tchdbvsiz(TCHDB *\fIhdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
If successful, the return value is the size of the value of the corresponding record, else, it is \-1.
.RE
.RE
.PP
The function `tchdbvsiz2' is used in order to get the size of the value of a string record in a hash database object.
.PP
.RS
.br
\fBint tchdbvsiz2(TCHDB *\fIhdb\fB, const char *\fIkstr\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
If successful, the return value is the size of the value of the corresponding record, else, it is \-1.
.RE
.RE
.PP
The function `tchdbiterinit' is used in order to initialize the iterator of a hash database object.
.PP
.RS
.br
\fBbool tchdbiterinit(TCHDB *\fIhdb\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
The iterator is used in order to access the key of every record stored in a database.
.RE
.RE
.PP
The function `tchdbiternext' is used in order to get the next key of the iterator of a hash database object.
.PP
.RS
.br
\fBvoid *tchdbiternext(TCHDB *\fIhdb\fB, int *\fIsp\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  It is possible to access every record by iteration of calling this function.  It is allowed to update or remove records whose keys are fetched while the iteration.  However, it is not assured if updating the database is occurred while the iteration.  Besides, the order of this traversal access method is arbitrary, so it is not assured that the order of storing matches the one of the traversal access.
.RE
.RE
.PP
The function `tchdbiternext2' is used in order to get the next key string of the iterator of a hash database object.
.PP
.RS
.br
\fBchar *tchdbiternext2(TCHDB *\fIhdb\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object.
.RE
.RS
If successful, the return value is the string of the next key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  It is possible to access every record by iteration of calling this function.  However, it is not assured if updating the database is occurred while the iteration.  Besides, the order of this traversal access method is arbitrary, so it is not assured that the order of storing matches the one of the traversal access.
.RE
.RE
.PP
The function `tchdbiternext3' is used in order to get the next extensible objects of the iterator of a hash database object.
.PP
.RS
.br
\fBbool tchdbiternext3(TCHDB *\fIhdb\fB, TCXSTR *\fIkxstr\fB, TCXSTR *\fIvxstr\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object.
.RE
.RS
`\fIkxstr\fR' specifies the object into which the next key is wrote down.
.RE
.RS
`\fIvxstr\fR' specifies the object into which the next value is wrote down.
.RE
.RS
If successful, the return value is true, else, it is false.  False is returned when no record is to be get out of the iterator.
.RE
.RE
.PP
The function `tchdbfwmkeys' is used in order to get forward matching keys in a hash database object.
.PP
.RS
.br
\fBTCLIST *tchdbfwmkeys(TCHDB *\fIhdb\fB, const void *\fIpbuf\fB, int \fIpsiz\fB, int \fImax\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object.
.RE
.RS
`\fIpbuf\fR' specifies the pointer to the region of the prefix.
.RE
.RS
`\fIpsiz\fR' specifies the size of the region of the prefix.
.RE
.RS
`\fImax\fR' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.
.RE
.RS
The return value is a list object of the corresponding keys.  This function does never fail and return an empty list even if no key corresponds.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.
.RE
.RE
.PP
The function `tchdbfwmkeys2' is used in order to get forward matching string keys in a hash database object.
.PP
.RS
.br
\fBTCLIST *tchdbfwmkeys2(TCHDB *\fIhdb\fB, const char *\fIpstr\fB, int \fImax\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object.
.RE
.RS
`\fIpstr\fR' specifies the string of the prefix.
.RE
.RS
`\fImax\fR' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.
.RE
.RS
The return value is a list object of the corresponding keys.  This function does never fail and return an empty list even if no key corresponds.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.
.RE
.RE
.PP
The function `tchdbaddint' is used in order to add an integer to a record in a hash database object.
.PP
.RS
.br
\fBint tchdbaddint(TCHDB *\fIhdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, int \fInum\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object connected as a writer.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fInum\fR' specifies the additional value.
.RE
.RS
If successful, the return value is the summation value, else, it is `INT_MIN'.
.RE
.RS
If the corresponding record exists, the value is treated as an integer and is added to.  If no record corresponds, a new record of the additional value is stored.
.RE
.RE
.PP
The function `tchdbdbadddouble' is used in order to add a real number to a record in a hash database object.
.PP
.RS
.br
\fBdouble tchdbadddouble(TCHDB *\fIhdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, double \fInum\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object connected as a writer.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fInum\fR' specifies the additional value.
.RE
.RS
If successful, the return value is the summation value, else, it is Not\-a\-Number.
.RE
.RS
If the corresponding record exists, the value is treated as a real number and is added to.  If no record corresponds, a new record of the additional value is stored.
.RE
.RE
.PP
The function `tchdbsync' is used in order to synchronize updated contents of a hash database object with the file and the device.
.PP
.RS
.br
\fBbool tchdbsync(TCHDB *\fIhdb\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object connected as a writer.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
This function is useful when another process connects to the same database file.
.RE
.RE
.PP
The function `tchdboptimize' is used in order to optimize the file of a hash database object.
.PP
.RS
.br
\fBbool tchdboptimize(TCHDB *\fIhdb\fB, int64_t \fIbnum\fB, int8_t \fIapow\fB, int8_t \fIfpow\fB, uint8_t \fIopts\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object connected as a writer.
.RE
.RS
`\fIbnum\fR' specifies the number of elements of the bucket array.  If it is not more than 0, the default value is specified.  The default value is two times of the number of records.
.RE
.RS
`\fIapow\fR' specifies the size of record alignment by power of 2.  If it is negative, the current setting is not changed.
.RE
.RS
`\fIfpow\fR' specifies the maximum number of elements of the free block pool by power of 2.  If it is negative, the current setting is not changed.
.RE
.RS
`\fIopts\fR' specifies options by bitwise\-or: `HDBTLARGE' specifies that the size of the database can be larger than 2GB by using 64\-bit bucket array, `HDBTDEFLATE' specifies that each record is compressed with Deflate encoding, `HDBTBZIP' specifies that each record is compressed with BZIP2 encoding, `HDBTTCBS' specifies that each record is compressed with TCBS encoding.  If it is `UINT8_MAX', the current setting is not changed.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
This function is useful to reduce the size of the database file with data fragmentation by successive updating.
.RE
.RE
.PP
The function `tchdbvanish' is used in order to remove all records of a hash database object.
.PP
.RS
.br
\fBbool tchdbvanish(TCHDB *\fIhdb\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object connected as a writer.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tchdbcopy' is used in order to copy the database file of a hash database object.
.PP
.RS
.br
\fBbool tchdbcopy(TCHDB *\fIhdb\fB, const char *\fIpath\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object.
.RE
.RS
`\fIpath\fR' specifies the path of the destination file.  If it begins with `@', the trailing substring is executed as a command line.
.RE
.RS
If successful, the return value is true, else, it is false.  False is returned if the executed command returns non\-zero code.
.RE
.RS
The database file is assured to be kept synchronized and not modified while the copying or executing operation is in progress.  So, this function is useful to create a backup file of the database file.
.RE
.RE
.PP
The function `tchdbtranbegin' is used in order to begin the transaction of a hash database object.
.PP
.RS
.br
\fBbool tchdbtranbegin(TCHDB *\fIhdb\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object connected as a writer.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
The database is locked by the thread while the transaction so that only one transaction can be activated with a database object at the same time.  Thus, the serializable isolation level is assumed if every database operation is performed in the transaction.  All updated regions are kept track of by write ahead logging while the transaction.  If the database is closed during transaction, the transaction is aborted implicitly.
.RE
.RE
.PP
The function `tchdbtrancommit' is used in order to commit the transaction of a hash database object.
.PP
.RS
.br
\fBbool tchdbtrancommit(TCHDB *\fIhdb\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object connected as a writer.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
Update in the transaction is fixed when it is committed successfully.
.RE
.RE
.PP
The function `tchdbtranabort' is used in order to abort the transaction of a hash database object.
.PP
.RS
.br
\fBbool tchdbtranabort(TCHDB *\fIhdb\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object connected as a writer.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
Update in the transaction is discarded when it is aborted.  The state of the database is rollbacked to before transaction.
.RE
.RE
.PP
The function `tchdbpath' is used in order to get the file path of a hash database object.
.PP
.RS
.br
\fBconst char *tchdbpath(TCHDB *\fIhdb\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object.
.RE
.RS
The return value is the path of the database file or `NULL' if the object does not connect to any database file.
.RE
.RE
.PP
The function `tchdbrnum' is used in order to get the number of records of a hash database object.
.PP
.RS
.br
\fBuint64_t tchdbrnum(TCHDB *\fIhdb\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object.
.RE
.RS
The return value is the number of records or 0 if the object does not connect to any database file.
.RE
.RE
.PP
The function `tchdbfsiz' is used in order to get the size of the database file of a hash database object.
.PP
.RS
.br
\fBuint64_t tchdbfsiz(TCHDB *\fIhdb\fB);\fR
.RS
`\fIhdb\fR' specifies the hash database object.
.RE
.RS
The return value is the size of the database file or 0 if the object does not connect to any database file.
.RE
.RE

.SH EXAMPLE CODE
.PP
The following code is an example to use a hash database.

.SH CLI
.PP
To use the hash database API easily, the commands `\fBtchtest\fR', `\fBtchmttest\fR', and `\fBtchmgr\fR' are provided.
.PP
The command `\fBtchtest\fR' is a utility for facility test and performance test.  This command is used in the following format.  `\fIpath\fR' specifies the path of a database file.  `\fIrnum\fR' specifies the number of iterations.  `\fIbnum\fR' specifies the number of buckets.  `\fIapow\fR' specifies the power of the alignment.  `\fIfpow\fR' specifies the power of the free block pool.
.PP
.RS
.br
\fBtchtest write \fR[\fB\-mt\fR]\fB \fR[\fB\-tl\fR]\fB \fR[\fB\-td\fR|\fB\-tb\fR|\fB\-tt\fR|\fB\-tx\fR]\fB \fR[\fB\-rc \fInum\fB\fR]\fB \fR[\fB\-xm \fInum\fB\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-as\fR]\fB \fR[\fB\-rnd\fR]\fB \fIpath\fB \fIrnum\fB \fR[\fB\fIbnum\fB \fR[\fB\fIapow\fB \fR[\fB\fIfpow\fB\fR]\fB\fR]\fB\fR]\fB\fR
.RS
Store records with keys of 8 bytes.  They change as `00000001', `00000002'...
.RE
.br
\fBtchtest read \fR[\fB\-mt\fR]\fB \fR[\fB\-rc \fInum\fB\fR]\fB \fR[\fB\-xm \fInum\fB\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-wb\fR]\fB \fR[\fB\-rnd\fR]\fB \fIpath\fB\fR
.RS
Retrieve all records of the database above.
.RE
.br
\fBtchtest remove \fR[\fB\-mt\fR]\fB \fR[\fB\-rc \fInum\fB\fR]\fB \fR[\fB\-xm \fInum\fB\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-rnd\fR]\fB \fIpath\fB\fR
.RS
Remove all records of the database above.
.RE
.br
\fBtchtest rcat \fR[\fB\-mt\fR]\fB \fR[\fB\-tl\fR]\fB \fR[\fB\-td\fR|\fB\-tb\fR|\fB\-tt\fR|\fB\-tx\fR]\fB \fR[\fB\-rc \fInum\fB\fR]\fB \fR[\fB\-xm \fInum\fB\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-pn \fInum\fB\fR]\fB \fR[\fB\-dai\fR|\fB\-dad\fR|\fB\-rl\fR|\fB\-ru\fR]\fB \fIpath\fB \fIrnum\fB \fR[\fB\fIbnum\fB \fR[\fB\fIapow\fB \fR[\fB\fIfpow\fB\fR]\fB\fR]\fB\fR]\fB\fR
.RS
Store records with partway duplicated keys using concatenate mode.
.RE
.br
\fBtchtest misc \fR[\fB\-mt\fR]\fB \fR[\fB\-tl\fR]\fB \fR[\fB\-td\fR|\fB\-tb\fR|\fB\-tt\fR|\fB\-tx\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fIpath\fB \fIrnum\fB\fR
.RS
Perform miscellaneous test of various operations.
.RE
.br
\fBtchtest wicked \fR[\fB\-mt\fR]\fB \fR[\fB\-tl\fR]\fB \fR[\fB\-td\fR|\fB\-tb\fR|\fB\-tt\fR|\fB\-tx\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fIpath\fB \fIrnum\fB\fR
.RS
Perform updating operations selected at random.
.RE
.RE
.PP
Options feature the following.
.PP
.RS
\fB\-mt\fR : call the function `tchdbsetmutex'.
.br
\fB\-tl\fR : enable the option `HDBTLARGE'.
.br
\fB\-td\fR : enable the option `HDBTDEFLATE'.
.br
\fB\-tb\fR : enable the option `HDBTBZIP'.
.br
\fB\-tt\fR : enable the option `HDBTTCBS'.
.br
\fB\-tx\fR : enable the option `HDBTEXCODEC'.
.br
\fB\-rc \fInum\fR\fR : specify the number of cached records.
.br
\fB\-xm \fInum\fR\fR : specify the size of the extra mapped memory.
.br
\fB\-nl\fR : enable the option `HDBNOLCK'.
.br
\fB\-nb\fR : enable the option `HDBLCKNB'.
.br
\fB\-as\fR : use the function `tchdbputasync' instead of `tchdbput'.
.br
\fB\-rnd\fR : select keys at random.
.br
\fB\-wb\fR : use the function `tchdbget3' instead of `tchdbget'.
.br
\fB\-pn \fInum\fR\fR : specify the number of patterns.
.br
\fB\-dai\fR : use the function `tchdbaddint' instead of `tchdbputcat'.
.br
\fB\-dad\fR : use the function `tchdbadddouble' instead of `tchdbputcat'.
.br
\fB\-rl\fR : set the length of values at random.
.br
\fB\-ru\fR : select update operations at random.
.br
.RE
.PP
This command returns 0 on success, another on failure.
.PP
The command `\fBtchmttest\fR' is a utility for facility test under multi\-thread situation.  This command is used in the following format.  `\fIpath\fR' specifies the path of a database file.  `\fItnum\fR' specifies the number of running threads.  `\fIrnum\fR' specifies the number of iterations.  `\fIbnum\fR' specifies the number of buckets.  `\fIapow\fR' specifies the power of the alignment.  `\fIfpow\fR' specifies the power of the free block pool.
.PP
.RS
.br
\fBtchmttest write \fR[\fB\-tl\fR]\fB \fR[\fB\-td\fR|\fB\-tb\fR|\fB\-tt\fR|\fB\-tx\fR]\fB \fR[\fB\-rc \fInum\fB\fR]\fB \fR[\fB\-xm \fInum\fB\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-as\fR]\fB \fR[\fB\-rnd\fR]\fB \fIpath\fB \fItnum\fB \fIrnum\fB \fR[\fB\fIbnum\fB \fR[\fB\fIapow\fB \fR[\fB\fIfpow\fB\fR]\fB\fR]\fB\fR]\fB\fR
.RS
Store records with keys of 8 bytes.  They change as `00000001', `00000002'...
.RE
.br
\fBtchmttest read \fR[\fB\-rc \fInum\fB\fR]\fB \fR[\fB\-xm \fInum\fB\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-wb\fR]\fB \fR[\fB\-rnd\fR]\fB \fIpath\fB \fItnum\fB\fR
.RS
Retrieve all records of the database above.
.RE
.br
\fBtchmttest remove \fR[\fB\-rc \fInum\fB\fR]\fB \fR[\fB\-xm \fInum\fB\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-rnd\fR]\fB \fIpath\fB \fItnum\fB\fR
.RS
Remove all records of the database above.
.RE
.br
\fBtchmttest wicked \fR[\fB\-tl\fR]\fB \fR[\fB\-td\fR|\fB\-tb\fR|\fB\-tt\fR|\fB\-tx\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-nc\fR]\fB \fIpath\fB \fItnum\fB \fIrnum\fB\fR
.RS
Perform updating operations selected at random.
.RE
.br
\fBtchmttest typical \fR[\fB\-tl\fR]\fB \fR[\fB\-td\fR|\fB\-tb\fR|\fB\-tt\fR|\fB\-tx\fR]\fB \fR[\fB\-rc \fInum\fB\fR]\fB \fR[\fB\-xm \fInum\fB\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-nc\fR]\fB \fR[\fB\-rr \fInum\fB\fR]\fB \fIpath\fB \fItnum\fB \fIrnum\fB \fR[\fB\fIbnum\fB \fR[\fB\fIapow\fB \fR[\fB\fIfpow\fB\fR]\fB\fR]\fB\fR
.RS
Perform typical operations selected at random.
.RE
.br
\fBtchmttest race \fR[\fB\-tl\fR]\fB \fR[\fB\-td\fR|\fB\-tb\fR|\fB\-tt\fR|\fB\-tx\fR]\fB \fR[\fB\-xm \fInum\fB\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fIpath\fB \fItnum\fB \fIrnum\fB \fR[\fB\fIbnum\fB \fR[\fB\fIapow\fB \fR[\fB\fIfpow\fB\fR]\fB\fR]\fB\fR
.RS
Perform race condition test.
.RE
.RE
.PP
Options feature the following.
.PP
.RS
\fB\-tl\fR : enable the option `HDBTLARGE'.
.br
\fB\-td\fR : enable the option `HDBTDEFLATE'.
.br
\fB\-tb\fR : enable the option `HDBTBZIP'.
.br
\fB\-tt\fR : enable the option `HDBTTCBS'.
.br
\fB\-tx\fR : enable the option `HDBTEXCODEC'.
.br
\fB\-rc \fInum\fR\fR : specify the number of cached records.
.br
\fB\-xm \fInum\fR\fR : specify the size of the extra mapped memory.
.br
\fB\-nl\fR : enable the option `HDBNOLCK'.
.br
\fB\-nb\fR : enable the option `HDBLCKNB'.
.br
\fB\-as\fR : use the function `tchdbputasync' instead of `tchdbput'.
.br
\fB\-rnd\fR : select keys at random.
.br
\fB\-wb\fR : use the function `tchdbget3' instead of `tchdbget'.
.br
\fB\-nc\fR : omit the comparison test.
.br
\fB\-rr \fInum\fR\fR : specify the ratio of reading operation by percentage.
.br
.RE
.PP
This command returns 0 on success, another on failure.
.PP
The command `\fBtchmgr\fR' is a utility for test and debugging of the hash database API and its applications.  `\fIpath\fR' specifies the path of a database file.  `\fIbnum\fR' specifies the number of buckets.  `\fIapow\fR' specifies the power of the alignment.  `\fIfpow\fR' specifies the power of the free block pool.  `\fIkey\fR' specifies the key of a record.  `\fIvalue\fR' specifies the value of a record.  `\fIfile\fR' specifies the input file.
.PP
.RS
.br
\fBtchmgr create \fR[\fB\-tl\fR]\fB \fR[\fB\-td\fR|\fB\-tb\fR|\fB\-tt\fR|\fB\-tx\fR]\fB \fIpath\fB \fR[\fB\fIbnum\fB \fR[\fB\fIapow\fB \fR[\fB\fIfpow\fB\fR]\fB\fR]\fB\fR]\fB\fR
.RS
Create a database file.
.RE
.br
\fBtchmgr inform \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fIpath\fB\fR
.RS
Print miscellaneous information to the standard output.
.RE
.br
\fBtchmgr put \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-sx\fR]\fB \fR[\fB\-dk\fR|\fB\-dc\fR|\fB\-dai\fR|\fB\-dad\fR]\fB \fIpath\fB \fIkey\fB \fIvalue\fB\fR
.RS
Store a record.
.RE
.br
\fBtchmgr out \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-sx\fR]\fB \fIpath\fB \fIkey\fB\fR
.RS
Remove a record.
.RE
.br
\fBtchmgr get \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-sx\fR]\fB \fR[\fB\-px\fR]\fB \fR[\fB\-pz\fR]\fB \fIpath\fB \fIkey\fB\fR
.RS
Print the value of a record.
.RE
.br
\fBtchmgr list \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-m \fInum\fB\fR]\fB \fR[\fB\-pv\fR]\fB \fR[\fB\-px\fR]\fB \fR[\fB\-fm \fIstr\fB\fR]\fB \fIpath\fB\fR
.RS
Print keys of all records, separated by line feeds.
.RE
.br
\fBtchmgr optimize \fR[\fB\-tl\fR]\fB \fR[\fB\-td\fR|\fB\-tb\fR|\fB\-tt\fR|\fB\-tx\fR]\fB \fR[\fB\-tz\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fIpath\fB \fR[\fB\fIbnum\fB \fR[\fB\fIapow\fB \fR[\fB\fIfpow\fB\fR]\fB\fR]\fB\fR]\fB\fR
.RS
Optimize a database file.
.RE
.br
\fBtchmgr importtsv \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-sc\fR]\fB \fIpath\fB \fR[\fB\fIfile\fB\fR]\fB\fR
.RS
Store records of TSV in each line of a file.
.RE
.br
\fBtchmgr version\fR
.RS
Print the version information of Tokyo Cabinet.
.RE
.RE
.PP
Options feature the following.
.PP
.RS
\fB\-tl\fR : enable the option `HDBTLARGE'.
.br
\fB\-td\fR : enable the option `HDBTDEFLATE'.
.br
\fB\-tb\fR : enable the option `HDBTBZIP'.
.br
\fB\-tt\fR : enable the option `HDBTTCBS'.
.br
\fB\-tx\fR : enable the option `HDBTEXCODEC'.
.br
\fB\-nl\fR : enable the option `HDBNOLCK'.
.br
\fB\-nb\fR : enable the option `HDBLCKNB'.
.br
\fB\-sx\fR : the input data is evaluated as a hexadecimal data string.
.br
\fB\-dk\fR : use the function `tchdbputkeep' instead of `tchdbput'.
.br
\fB\-dc\fR : use the function `tchdbputcat' instead of `tchdbput'.
.br
\fB\-dai\fR : use the function `tchdbaddint' instead of `tchdbput'.
.br
\fB\-dad\fR : use the function `tchdbadddouble' instead of `tchdbput'.
.br
\fB\-px\fR : the output data is converted into a hexadecimal data string.
.br
\fB\-pz\fR : do not append line feed at the end of the output.
.br
\fB\-m \fInum\fR\fR : specify the maximum number of the output.
.br
\fB\-pv\fR : print values of records also.
.br
\fB\-fm \fIstr\fR\fR : specify the prefix of keys.
.br
\fB\-tz\fR : enable the option `UINT8_MAX'.
.br
\fB\-sc\fR : normalize keys as lower cases.
.br
.RE
.PP
This command returns 0 on success, another on failure.

.SH THE B+ TREE DATABASE API
.PP
B+ tree database is a file containing a B+ tree and is handled with the B+ tree database API.  See `\fBtcbdb.h\fR' for the entire specification.

.SH DESCRIPTION
.PP
To use the B+ tree database API, include `\fBtcutil.h\fR', `\fBtcbdb.h\fR', and related standard header files.  Usually, write the following description near the front of a source file.
.PP
.RS
.br
\fB#include <tcutil.h>\fR
.br
\fB#include <tcbdb.h>\fR
.br
\fB#include <stdlib.h>\fR
.br
\fB#include <stdbool.h>\fR
.br
\fB#include <stdint.h>\fR
.RE
.PP
Objects whose type is pointer to `\fBTCBDB\fR' are used to handle B+ tree databases.  A B+ tree database object is created with the function `\fBtcbdbnew\fR' and is deleted with the function `\fBtcbdbdel\fR'.  To avoid memory leak, it is important to delete every object when it is no longer in use.
.PP
Before operations to store or retrieve records, it is necessary to open a database file and connect the B+ tree database object to it.  The function `\fBtcbdbopen\fR' is used to open a database file and the function `\fBtcbdbclose\fR' is used to close the database file.  To avoid data missing or corruption, it is important to close every database file when it is no longer in use.

.SH API
.PP
The function `tcbdberrmsg' is used in order to get the message string corresponding to an error code.
.PP
.RS
.br
\fBconst char *tcbdberrmsg(int \fIecode\fB);\fR
.RS
`\fIecode\fR' specifies the error code.
.RE
.RS
The return value is the message string of the error code.
.RE
.RE
.PP
The function `tcbdbnew' is used in order to create a B+ tree database object.
.PP
.RS
.br
\fBTCBDB *tcbdbnew(void);\fR
.RS
The return value is the new B+ tree database object.
.RE
.RE
.PP
The function `tcbdbdel' is used in order to delete a B+ tree database object.
.PP
.RS
.br
\fBvoid tcbdbdel(TCBDB *\fIbdb\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object.
.RE
.RS
If the database is not closed, it is closed implicitly.  Note that the deleted object and its derivatives can not be used anymore.
.RE
.RE
.PP
The function `tcbdbecode' is used in order to get the last happened error code of a B+ tree database object.
.PP
.RS
.br
\fBint tcbdbecode(TCBDB *\fIbdb\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object.
.RE
.RS
The return value is the last happened error code.
.RE
.RS
The following error codes are defined: `TCESUCCESS' for success, `TCETHREAD' for threading error, `TCEINVALID' for invalid operation, `TCENOFILE' for file not found, `TCENOPERM' for no permission, `TCEMETA' for invalid meta data, `TCERHEAD' for invalid record header, `TCEOPEN' for open error, `TCECLOSE' for close error, `TCETRUNC' for trunc error, `TCESYNC' for sync error, `TCESTAT' for stat error, `TCESEEK' for seek error, `TCEREAD' for read error, `TCEWRITE' for write error, `TCEMMAP' for mmap error, `TCELOCK' for lock error, `TCEUNLINK' for unlink error, `TCERENAME' for rename error, `TCEMKDIR' for mkdir error, `TCERMDIR' for rmdir error, `TCEKEEP' for existing record, `TCENOREC' for no record found, and `TCEMISC' for miscellaneous error.
.RE
.RE
.PP
The function `tcbdbsetmutex' is used in order to set mutual exclusion control of a B+ tree database object for threading.
.PP
.RS
.br
\fBbool tcbdbsetmutex(TCBDB *\fIbdb\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object which is not opened.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
Note that the mutual exclusion control of the database should be set before the database is opened.
.RE
.RE
.PP
The function `tcbdbsetcmpfunc' is used in order to set the custom comparison function of a B+ tree database object.
.PP
.RS
.br
\fBbool tcbdbsetcmpfunc(TCBDB *\fIbdb\fB, TCCMP \fIcmp\fB, void *\fIcmpop\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object which is not opened.
.RE
.RS
`\fIcmp\fR' specifies the pointer to the custom comparison function.  It receives five parameters.  The first parameter is the pointer to the region of one key.  The second parameter is the size of the region of one key.  The third parameter is the pointer to the region of the other key.  The fourth parameter is the size of the region of the other key.  The fifth parameter is the pointer to the optional opaque object.  It returns positive if the former is big, negative if the latter is big, 0 if both are equivalent.
.RE
.RS
`\fIcmpop\fR' specifies an arbitrary pointer to be given as a parameter of the comparison function.  If it is not needed, `NULL' can be specified.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
The default comparison function compares keys of two records by lexical order.  The functions `tccmplexical' (dafault), `tccmpdecimal', `tccmpint32', and `tccmpint64' are built\-in.  Note that the comparison function should be set before the database is opened.  Moreover, user\-defined comparison functions should be set every time the database is being opened.
.RE
.RE
.PP
The function `tcbdbtune' is used in order to set the tuning parameters of a B+ tree database object.
.PP
.RS
.br
\fBbool tcbdbtune(TCBDB *\fIbdb\fB, int32_t \fIlmemb\fB, int32_t \fInmemb\fB, int64_t \fIbnum\fB, int8_t \fIapow\fB, int8_t \fIfpow\fB, uint8_t \fIopts\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object which is not opened.
.RE
.RS
`\fIlmemb\fR' specifies the number of members in each leaf page.  If it is not more than 0, the default value is specified.  The default value is 128.
.RE
.RS
`\fInmemb\fR' specifies the number of members in each non\-leaf page.  If it is not more than 0, the default value is specified.  The default value is 256.
.RE
.RS
`\fIbnum\fR' specifies the number of elements of the bucket array.  If it is not more than 0, the default value is specified.  The default value is 32749.  Suggested size of the bucket array is about from 1 to 4 times of the number of all pages to be stored.
.RE
.RS
`\fIapow\fR' specifies the size of record alignment by power of 2.  If it is negative, the default value is specified.  The default value is 8 standing for 2^8=256.
.RE
.RS
`\fIfpow\fR' specifies the maximum number of elements of the free block pool by power of 2.  If it is negative, the default value is specified.  The default value is 10 standing for 2^10=1024.
.RE
.RS
`\fIopts\fR' specifies options by bitwise\-or: `BDBTLARGE' specifies that the size of the database can be larger than 2GB by using 64\-bit bucket array, `BDBTDEFLATE' specifies that each page is compressed with Deflate encoding, `BDBTBZIP' specifies that each page is compressed with BZIP2 encoding, `BDBTTCBS' specifies that each page is compressed with TCBS encoding.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
Note that the tuning parameters should be set before the database is opened.
.RE
.RE
.PP
The function `tcbdbsetcache' is used in order to set the caching parameters of a B+ tree database object.
.PP
.RS
.br
\fBbool tcbdbsetcache(TCBDB *\fIbdb\fB, int32_t \fIlcnum\fB, int32_t \fIncnum\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object which is not opened.
.RE
.RS
`\fIlcnum\fR' specifies the maximum number of leaf nodes to be cached.  If it is not more than 0, the default value is specified.  The default value is 1024.
.RE
.RS
`\fIncnum\fR' specifies the maximum number of non\-leaf nodes to be cached.  If it is not more than 0, the default value is specified.  The default value is 512.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
Note that the caching parameters should be set before the database is opened.
.RE
.RE
.PP
The function `tcbdbsetxmsiz' is used in order to set the size of the extra mapped memory of a B+ tree database object.
.PP
.RS
.br
\fBbool tcbdbsetxmsiz(TCBDB *\fIbdb\fB, int64_t \fIxmsiz\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object which is not opened.
.RE
.RS
`\fIxmsiz\fR' specifies the size of the extra mapped memory.  If it is not more than 0, the extra mapped memory is disabled.  It is disabled by default.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
Note that the mapping parameters should be set before the database is opened.
.RE
.RE
.PP
The function `tcbdbopen' is used in order to open a database file and connect a B+ tree database object.
.PP
.RS
.br
\fBbool tcbdbopen(TCBDB *\fIbdb\fB, const char *\fIpath\fB, int \fIomode\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object which is not opened.
.RE
.RS
`\fIpath\fR' specifies the path of the database file.
.RE
.RS
`\fIomode\fR' specifies the connection mode: `BDBOWRITER' as a writer, `BDBOREADER' as a reader.  If the mode is `BDBOWRITER', the following may be added by bitwise\-or: `BDBOCREAT', which means it creates a new database if not exist, `BDBOTRUNC', which means it creates a new database regardless if one exists, `BDBOTSYNC', which means every transaction synchronizes updated contents with the device.  Both of `BDBOREADER' and `BDBOWRITER' can be added to by bitwise\-or: `BDBONOLCK', which means it opens the database file without file locking, or `BDBOLCKNB', which means locking is performed without blocking.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tcbdbclose' is used in order to close a B+ tree database object.
.PP
.RS
.br
\fBbool tcbdbclose(TCBDB *\fIbdb\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
Update of a database is assured to be written when the database is closed.  If a writer opens a database but does not close it appropriately, the database will be broken.
.RE
.RE
.PP
The function `tcbdbput' is used in order to store a record into a B+ tree database object.
.PP
.RS
.br
\fBbool tcbdbput(TCBDB *\fIbdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, const void *\fIvbuf\fB, int \fIvsiz\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object connected as a writer.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, it is overwritten.
.RE
.RE
.PP
The function `tcbdbput2' is used in order to store a string record into a B+ tree database object.
.PP
.RS
.br
\fBbool tcbdbput2(TCBDB *\fIbdb\fB, const char *\fIkstr\fB, const char *\fIvstr\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object connected as a writer.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
`\fIvstr\fR' specifies the string of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, it is overwritten.
.RE
.RE
.PP
The function `tcbdbputkeep' is used in order to store a new record into a B+ tree database object.
.PP
.RS
.br
\fBbool tcbdbputkeep(TCBDB *\fIbdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, const void *\fIvbuf\fB, int \fIvsiz\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object connected as a writer.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, this function has no effect.
.RE
.RE
.PP
The function `tcbdbputkeep2' is used in order to store a new string record into a B+ tree database object.
.PP
.RS
.br
\fBbool tcbdbputkeep2(TCBDB *\fIbdb\fB, const char *\fIkstr\fB, const char *\fIvstr\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object connected as a writer.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
`\fIvstr\fR' specifies the string of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, this function has no effect.
.RE
.RE
.PP
The function `tcbdbputcat' is used in order to concatenate a value at the end of the existing record in a B+ tree database object.
.PP
.RS
.br
\fBbool tcbdbputcat(TCBDB *\fIbdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, const void *\fIvbuf\fB, int \fIvsiz\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object connected as a writer.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If there is no corresponding record, a new record is created.
.RE
.RE
.PP
The function `tcbdbputcat2' is used in order to concatenate a string value at the end of the existing record in a B+ tree database object.
.PP
.RS
.br
\fBbool tcbdbputcat2(TCBDB *\fIbdb\fB, const char *\fIkstr\fB, const char *\fIvstr\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object connected as a writer.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
`\fIvstr\fR' specifies the string of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If there is no corresponding record, a new record is created.
.RE
.RE
.PP
The function `tcbdbputdup' is used in order to store a record into a B+ tree database object with allowing duplication of keys.
.PP
.RS
.br
\fBbool tcbdbputdup(TCBDB *\fIbdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, const void *\fIvbuf\fB, int \fIvsiz\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object connected as a writer.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, the new record is placed after the existing one.
.RE
.RE
.PP
The function `tcbdbputdup2' is used in order to store a string record into a B+ tree database object with allowing duplication of keys.
.PP
.RS
.br
\fBbool tcbdbputdup2(TCBDB *\fIbdb\fB, const char *\fIkstr\fB, const char *\fIvstr\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object connected as a writer.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
`\fIvstr\fR' specifies the string of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, the new record is placed after the existing one.
.RE
.RE
.PP
The function `tcbdbputdup3' is used in order to store records into a B+ tree database object with allowing duplication of keys.
.PP
.RS
.br
\fBbool tcbdbputdup3(TCBDB *\fIbdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, const TCLIST *\fIvals\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object connected as a writer.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the common key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the common key.
.RE
.RS
`\fIvals\fR' specifies a list object containing values.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, the new records are placed after the existing one.
.RE
.RE
.PP
The function `tcbdbout' is used in order to remove a record of a B+ tree database object.
.PP
.RS
.br
\fBbool tcbdbout(TCBDB *\fIbdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object connected as a writer.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If the key of duplicated records is specified, the first one is selected.
.RE
.RE
.PP
The function `tcbdbout2' is used in order to remove a string record of a B+ tree database object.
.PP
.RS
.br
\fBbool tcbdbout2(TCBDB *\fIbdb\fB, const char *\fIkstr\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object connected as a writer.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If the key of duplicated records is specified, the first one is selected.
.RE
.RE
.PP
The function `tcbdbout3' is used in order to remove records of a B+ tree database object.
.PP
.RS
.br
\fBbool tcbdbout3(TCBDB *\fIbdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object connected as a writer.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If the key of duplicated records is specified, all of them are removed.
.RE
.RE
.PP
The function `tcbdbget' is used in order to retrieve a record in a B+ tree database object.
.PP
.RS
.br
\fBvoid *tcbdbget(TCBDB *\fIbdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, int *\fIsp\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned if no record corresponds.
.RE
.RS
If the key of duplicated records is specified, the first one is selected.  Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcbdbget2' is used in order to retrieve a string record in a B+ tree database object.
.PP
.RS
.br
\fBchar *tcbdbget2(TCBDB *\fIbdb\fB, const char *\fIkstr\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned if no record corresponds.
.RE
.RS
If the key of duplicated records is specified, the first one is selected.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcbdbget3' is used in order to retrieve a record in a B+ tree database object as a volatile buffer.
.PP
.RS
.br
\fBconst void *tcbdbget3(TCBDB *\fIbdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, int *\fIsp\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned if no record corresponds.
.RE
.RS
If the key of duplicated records is specified, the first one is selected.  Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is volatile and it may be spoiled by another operation of the database, the data should be copied into another involatile buffer immediately.
.RE
.RE
.PP
The function `tcbdbget4' is used in order to retrieve records in a B+ tree database object.
.PP
.RS
.br
\fBTCLIST *tcbdbget4(TCBDB *\fIbdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
If successful, the return value is a list object of the values of the corresponding records.  `NULL' is returned if no record corresponds.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.
.RE
.RE
.PP
The function `tcbdbvnum' is used in order to get the number of records corresponding a key in a B+ tree database object.
.PP
.RS
.br
\fBint tcbdbvnum(TCBDB *\fIbdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
If successful, the return value is the number of the corresponding records, else, it is 0.
.RE
.RE
.PP
The function `tcbdbvnum2' is used in order to get the number of records corresponding a string key in a B+ tree database object.
.PP
.RS
.br
\fBint tcbdbvnum2(TCBDB *\fIbdb\fB, const char *\fIkstr\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
If successful, the return value is the number of the corresponding records, else, it is 0.
.RE
.RE
.PP
The function `tcbdbvsiz' is used in order to get the size of the value of a record in a B+ tree database object.
.PP
.RS
.br
\fBint tcbdbvsiz(TCBDB *\fIbdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
If successful, the return value is the size of the value of the corresponding record, else, it is \-1.
.RE
.RS
If the key of duplicated records is specified, the first one is selected.
.RE
.RE
.PP
The function `tcbdbvsiz2' is used in order to get the size of the value of a string record in a B+ tree database object.
.PP
.RS
.br
\fBint tcbdbvsiz2(TCBDB *\fIbdb\fB, const char *\fIkstr\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
If successful, the return value is the size of the value of the corresponding record, else, it is \-1.
.RE
.RS
If the key of duplicated records is specified, the first one is selected.
.RE
.RE
.PP
The function `tcbdbrange' is used in order to get keys of ranged records in a B+ tree database object.
.PP
.RS
.br
\fBTCLIST *tcbdbrange(TCBDB *\fIbdb\fB, const void *\fIbkbuf\fB, int \fIbksiz\fB, bool \fIbinc\fB, const void *\fIekbuf\fB, int \fIeksiz\fB, bool \fIeinc\fB, int \fImax\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object.
.RE
.RS
`\fIbkbuf\fR' specifies the pointer to the region of the key of the beginning border.  If it is `NULL', the first record is specified.
.RE
.RS
`\fIbksiz\fR' specifies the size of the region of the beginning key.
.RE
.RS
`\fIbinc\fR' specifies whether the beginning border is inclusive or not.
.RE
.RS
`\fIekbuf\fR' specifies the pointer to the region of the key of the ending border.  If it is `NULL', the last record is specified.
.RE
.RS
`\fIeksiz\fR' specifies the size of the region of the ending key.
.RE
.RS
`\fIeinc\fR' specifies whether the ending border is inclusive or not.
.RE
.RS
`\fImax\fR' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.
.RE
.RS
The return value is a list object of the keys of the corresponding records.  This function does never fail and return an empty list even if no record corresponds.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.
.RE
.RE
.PP
The function `tcbdbrange2' is used in order to get string keys of ranged records in a B+ tree database object.
.PP
.RS
.br
\fBTCLIST *tcbdbrange2(TCBDB *\fIbdb\fB, const char *\fIbkstr\fB, bool \fIbinc\fB, const char *\fIekstr\fB, bool \fIeinc\fB, int \fImax\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object.
.RE
.RS
`\fIbkstr\fR' specifies the string of the key of the beginning border.  If it is `NULL', the first record is specified.
.RE
.RS
`\fIbinc\fR' specifies whether the beginning border is inclusive or not.
.RE
.RS
`\fIekstr\fR' specifies the string of the key of the ending border.  If it is `NULL', the last record is specified.
.RE
.RS
`\fIeinc\fR' specifies whether the ending border is inclusive or not.
.RE
.RS
`\fImax\fR' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.
.RE
.RS
The return value is a list object of the keys of the corresponding records.  This function does never fail and return an empty list even if no record corresponds.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.
.RE
.RE
.PP
The function `tcbdbfwmkeys' is used in order to get forward matching keys in a B+ tree database object.
.PP
.RS
.br
\fBTCLIST *tcbdbfwmkeys(TCBDB *\fIbdb\fB, const void *\fIpbuf\fB, int \fIpsiz\fB, int \fImax\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object.
.RE
.RS
`\fIpbuf\fR' specifies the pointer to the region of the prefix.
.RE
.RS
`\fIpsiz\fR' specifies the size of the region of the prefix.
.RE
.RS
`\fImax\fR' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.
.RE
.RS
The return value is a list object of the corresponding keys.  This function does never fail and return an empty list even if no key corresponds.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.
.RE
.RE
.PP
The function `tcbdbfwmkeys2' is used in order to get forward matching string keys in a B+ tree database object.
.PP
.RS
.br
\fBTCLIST *tcbdbfwmkeys2(TCBDB *\fIbdb\fB, const char *\fIpstr\fB, int \fImax\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object.
.RE
.RS
`\fIpstr\fR' specifies the string of the prefix.
.RE
.RS
`\fImax\fR' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.
.RE
.RS
The return value is a list object of the corresponding keys.  This function does never fail and return an empty list even if no key corresponds.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.
.RE
.RE
.PP
The function `tcbdbaddint' is used in order to add an integer to a record in a B+ tree database object.
.PP
.RS
.br
\fBint tcbdbaddint(TCBDB *\fIbdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, int \fInum\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object connected as a writer.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fInum\fR' specifies the additional value.
.RE
.RS
If successful, the return value is the summation value, else, it is `INT_MIN'.
.RE
.RS
If the corresponding record exists, the value is treated as an integer and is added to.  If no record corresponds, a new record of the additional value is stored.
.RE
.RE
.PP
The function `tcbdbadddouble' is used in order to add a real number to a record in a B+ tree database object.
.PP
.RS
.br
\fBdouble tcbdbadddouble(TCBDB *\fIbdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, double \fInum\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object connected as a writer.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fInum\fR' specifies the additional value.
.RE
.RS
If successful, the return value is the summation value, else, it is Not\-a\-Number.
.RE
.RS
If the corresponding record exists, the value is treated as a real number and is added to.  If no record corresponds, a new record of the additional value is stored.
.RE
.RE
.PP
The function `tcbdbsync' is used in order to synchronize updated contents of a B+ tree database object with the file and the device.
.PP
.RS
.br
\fBbool tcbdbsync(TCBDB *\fIbdb\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object connected as a writer.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
This function is useful when another process connects to the same database file.
.RE
.RE
.PP
The function `tcbdboptimize' is used in order to optimize the file of a B+ tree database object.
.PP
.RS
.br
\fBbool tcbdboptimize(TCBDB *\fIbdb\fB, int32_t \fIlmemb\fB, int32_t \fInmemb\fB, int64_t \fIbnum\fB, int8_t \fIapow\fB, int8_t \fIfpow\fB, uint8_t \fIopts\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object connected as a writer.
.RE
.RS
`\fIlmemb\fR' specifies the number of members in each leaf page.  If it is not more than 0, the current setting is not changed.
.RE
.RS
`\fInmemb\fR' specifies the number of members in each non\-leaf page.  If it is not more than 0, the current setting is not changed.
.RE
.RS
`\fIbnum\fR' specifies the number of elements of the bucket array.  If it is not more than 0, the default value is specified.  The default value is two times of the number of pages.
.RE
.RS
`\fIapow\fR' specifies the size of record alignment by power of 2.  If it is negative, the current setting is not changed.
.RE
.RS
`\fIfpow\fR' specifies the maximum number of elements of the free block pool by power of 2.  If it is negative, the current setting is not changed.
.RE
.RS
`\fIopts\fR' specifies options by bitwise\-or: `BDBTLARGE' specifies that the size of the database can be larger than 2GB by using 64\-bit bucket array, `BDBTDEFLATE' specifies that each record is compressed with Deflate encoding, `BDBTBZIP' specifies that each page is compressed with BZIP2 encoding, `BDBTTCBS' specifies that each page is compressed with TCBS encoding.  If it is `UINT8_MAX', the current setting is not changed.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
This function is useful to reduce the size of the database file with data fragmentation by successive updating.
.RE
.RE
.PP
The function `tcbdbvanish' is used in order to remove all records of a B+ tree database object.
.PP
.RS
.br
\fBbool tcbdbvanish(TCBDB *\fIbdb\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object connected as a writer.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tcbdbcopy' is used in order to copy the database file of a B+ tree database object.
.PP
.RS
.br
\fBbool tcbdbcopy(TCBDB *\fIbdb\fB, const char *\fIpath\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object.
.RE
.RS
`\fIpath\fR' specifies the path of the destination file.  If it begins with `@', the trailing substring is executed as a command line.
.RE
.RS
If successful, the return value is true, else, it is false.  False is returned if the executed command returns non\-zero code.
.RE
.RS
The database file is assured to be kept synchronized and not modified while the copying or executing operation is in progress.  So, this function is useful to create a backup file of the database file.
.RE
.RE
.PP
The function `tcbdbtranbegin' is used in order to begin the transaction of a B+ tree database object.
.PP
.RS
.br
\fBbool tcbdbtranbegin(TCBDB *\fIbdb\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object connected as a writer.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
The database is locked by the thread while the transaction so that only one transaction can be activated with a database object at the same time.  Thus, the serializable isolation level is assumed if every database operation is performed in the transaction.  Because all pages are cached on memory while the transaction, the amount of referred records is limited by the memory capacity.  If the database is closed during transaction, the transaction is aborted implicitly.
.RE
.RE
.PP
The function `tcbdbtrancommit' is used in order to commit the transaction of a B+ tree database object.
.PP
.RS
.br
\fBbool tcbdbtrancommit(TCBDB *\fIbdb\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object connected as a writer.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
Update in the transaction is fixed when it is committed successfully.
.RE
.RE
.PP
The function `tcbdbtranabort' is used in order to abort the transaction of a B+ tree database object.
.PP
.RS
.br
\fBbool tcbdbtranabort(TCBDB *\fIbdb\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object connected as a writer.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
Update in the transaction is discarded when it is aborted.  The state of the database is rollbacked to before transaction.
.RE
.RE
.PP
The function `tcbdbpath' is used in order to get the file path of a B+ tree database object.
.PP
.RS
.br
\fBconst char *tcbdbpath(TCBDB *\fIbdb\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object.
.RE
.RS
The return value is the path of the database file or `NULL' if the object does not connect to any database file.
.RE
.RE
.PP
The function `tcbdbrnum' is used in order to get the number of records of a B+ tree database object.
.PP
.RS
.br
\fBuint64_t tcbdbrnum(TCBDB *\fIbdb\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object.
.RE
.RS
The return value is the number of records or 0 if the object does not connect to any database file.
.RE
.RE
.PP
The function `tcbdbfsiz' is used in order to get the size of the database file of a B+ tree database object.
.PP
.RS
.br
\fBuint64_t tcbdbfsiz(TCBDB *\fIbdb\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object.
.RE
.RS
The return value is the size of the database file or 0 if the object does not connect to any database file.
.RE
.RE
.PP
The function `tcbdbcurnew' is used in order to create a cursor object.
.PP
.RS
.br
\fBBDBCUR *tcbdbcurnew(TCBDB *\fIbdb\fB);\fR
.RS
`\fIbdb\fR' specifies the B+ tree database object.
.RE
.RS
The return value is the new cursor object.
.RE
.RS
Note that the cursor is available only after initialization with the `tcbdbcurfirst' or the `tcbdbcurjump' functions and so on.  Moreover, the position of the cursor will be indefinite when the database is updated after the initialization of the cursor.
.RE
.RE
.PP
The function `tcbdbcurdel' is used in order to delete a cursor object.
.PP
.RS
.br
\fBvoid tcbdbcurdel(BDBCUR *\fIcur\fB);\fR
.RS
`\fIcur\fR' specifies the cursor object.
.RE
.RE
.PP
The function `tcbdbcurfirst' is used in order to move a cursor object to the first record.
.PP
.RS
.br
\fBbool tcbdbcurfirst(BDBCUR *\fIcur\fB);\fR
.RS
`\fIcur\fR' specifies the cursor object.
.RE
.RS
If successful, the return value is true, else, it is false.  False is returned if there is no record in the database.
.RE
.RE
.PP
The function `tcbdbcurlast' is used in order to move a cursor object to the last record.
.PP
.RS
.br
\fBbool tcbdbcurlast(BDBCUR *\fIcur\fB);\fR
.RS
`\fIcur\fR' specifies the cursor object.
.RE
.RS
If successful, the return value is true, else, it is false.  False is returned if there is no record in the database.
.RE
.RE
.PP
The function `tcbdbcurjump' is used in order to move a cursor object to the front of records corresponding a key.
.PP
.RS
.br
\fBbool tcbdbcurjump(BDBCUR *\fIcur\fB, const void *\fIkbuf\fB, int \fIksiz\fB);\fR
.RS
`\fIcur\fR' specifies the cursor object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
If successful, the return value is true, else, it is false.  False is returned if there is no record corresponding the condition.
.RE
.RS
The cursor is set to the first record corresponding the key or the next substitute if completely matching record does not exist.
.RE
.RE
.PP
The function `tcbdbcurjump2' is used in order to move a cursor object to the front of records corresponding a key string.
.PP
.RS
.br
\fBbool tcbdbcurjump2(BDBCUR *\fIcur\fB, const char *\fIkstr\fB);\fR
.RS
`\fIcur\fR' specifies the cursor object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
If successful, the return value is true, else, it is false.  False is returned if there is no record corresponding the condition.
.RE
.RS
The cursor is set to the first record corresponding the key or the next substitute if completely matching record does not exist.
.RE
.RE
.PP
The function `tcbdbcurprev' is used in order to move a cursor object to the previous record.
.PP
.RS
.br
\fBbool tcbdbcurprev(BDBCUR *\fIcur\fB);\fR
.RS
`\fIcur\fR' specifies the cursor object.
.RE
.RS
If successful, the return value is true, else, it is false.  False is returned if there is no previous record.
.RE
.RE
.PP
The function `tcbdbcurnext' is used in order to move a cursor object to the next record.
.PP
.RS
.br
\fBbool tcbdbcurnext(BDBCUR *\fIcur\fB);\fR
.RS
`\fIcur\fR' specifies the cursor object.
.RE
.RS
If successful, the return value is true, else, it is false.  False is returned if there is no next record.
.RE
.RE
.PP
The function `tcbdbcurput' is used in order to insert a record around a cursor object.
.PP
.RS
.br
\fBbool tcbdbcurput(BDBCUR *\fIcur\fB, const void *\fIvbuf\fB, int \fIvsiz\fB, int \fIcpmode\fB);\fR
.RS
`\fIcur\fR' specifies the cursor object of writer connection.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.
.RE
.RS
`\fIcpmode\fR' specifies detail adjustment: `BDBCPCURRENT', which means that the value of the current record is overwritten, `BDBCPBEFORE', which means that the new record is inserted before the current record, `BDBCPAFTER', which means that the new record is inserted after the current record.
.RE
.RS
If successful, the return value is true, else, it is false.  False is returned when the cursor is at invalid position.
.RE
.RS
After insertion, the cursor is moved to the inserted record.
.RE
.RE
.PP
The function `tcbdbcurput2' is used in order to insert a string record around a cursor object.
.PP
.RS
.br
\fBbool tcbdbcurput2(BDBCUR *\fIcur\fB, const char *\fIvstr\fB, int \fIcpmode\fB);\fR
.RS
`\fIcur\fR' specifies the cursor object of writer connection.
.RE
.RS
`\fIvstr\fR' specifies the string of the value.
.RE
.RS
`\fIcpmode\fR' specifies detail adjustment: `BDBCPCURRENT', which means that the value of the current record is overwritten, `BDBCPBEFORE', which means that the new record is inserted before the current record, `BDBCPAFTER', which means that the new record is inserted after the current record.
.RE
.RS
If successful, the return value is true, else, it is false.  False is returned when the cursor is at invalid position.
.RE
.RS
After insertion, the cursor is moved to the inserted record.
.RE
.RE
.PP
The function `tcbdbcurout' is used in order to remove the record where a cursor object is.
.PP
.RS
.br
\fBbool tcbdbcurout(BDBCUR *\fIcur\fB);\fR
.RS
`\fIcur\fR' specifies the cursor object of writer connection.
.RE
.RS
If successful, the return value is true, else, it is false.  False is returned when the cursor is at invalid position.
.RE
.RS
After deletion, the cursor is moved to the next record if possible.
.RE
.RE
.PP
The function `tcbdbcurkey' is used in order to get the key of the record where the cursor object is.
.PP
.RS
.br
\fBvoid *tcbdbcurkey(BDBCUR *\fIcur\fB, int *\fIsp\fB);\fR
.RS
`\fIcur\fR' specifies the cursor object.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the region of the key, else, it is `NULL'.  `NULL' is returned when the cursor is at invalid position.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcbdbcurkey2' is used in order to get the key string of the record where the cursor object is.
.PP
.RS
.br
\fBchar *tcbdbcurkey2(BDBCUR *\fIcur\fB);\fR
.RS
`\fIcur\fR' specifies the cursor object.
.RE
.RS
If successful, the return value is the string of the key, else, it is `NULL'.  `NULL' is returned when the cursor is at invalid position.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcbdbcurkey3' is used in order to get the key of the record where the cursor object is, as a volatile buffer.
.PP
.RS
.br
\fBconst void *tcbdbcurkey3(BDBCUR *\fIcur\fB, int *\fIsp\fB);\fR
.RS
`\fIcur\fR' specifies the cursor object.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the region of the key, else, it is `NULL'.  `NULL' is returned when the cursor is at invalid position.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is volatile and it may be spoiled by another operation of the database, the data should be copied into another involatile buffer immediately.
.RE
.RE
.PP
The function `tcbdbcurval' is used in order to get the value of the record where the cursor object is.
.PP
.RS
.br
\fBvoid *tcbdbcurval(BDBCUR *\fIcur\fB, int *\fIsp\fB);\fR
.RS
`\fIcur\fR' specifies the cursor object.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the region of the value, else, it is `NULL'.  `NULL' is returned when the cursor is at invalid position.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcbdbcurval2' is used in order to get the value string of the record where the cursor object is.
.PP
.RS
.br
\fBchar *tcbdbcurval2(BDBCUR *\fIcur\fB);\fR
.RS
`\fIcur\fR' specifies the cursor object.
.RE
.RS
If successful, the return value is the string of the value, else, it is `NULL'.  `NULL' is returned when the cursor is at invalid position.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcbdbcurval3' is used in order to get the value of the record where the cursor object is, as a volatile buffer.
.PP
.RS
.br
\fBconst void *tcbdbcurval3(BDBCUR *\fIcur\fB, int *\fIsp\fB);\fR
.RS
`\fIcur\fR' specifies the cursor object.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the region of the value, else, it is `NULL'.  `NULL' is returned when the cursor is at invalid position.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is volatile and it may be spoiled by another operation of the database, the data should be copied into another involatile buffer immediately.
.RE
.RE
.PP
The function `tcbdbcurrec' is used in order to get the key and the value of the record where the cursor object is.
.PP
.RS
.br
\fBbool tcbdbcurrec(BDBCUR *\fIcur\fB, TCXSTR *\fIkxstr\fB, TCXSTR *\fIvxstr\fB);\fR
.RS
`\fIcur\fR' specifies the cursor object.
.RE
.RS
`\fIkxstr\fR' specifies the object into which the key is wrote down.
.RE
.RS
`\fIvxstr\fR' specifies the object into which the value is wrote down.
.RE
.RS
If successful, the return value is true, else, it is false.  False is returned when the cursor is at invalid position.
.RE
.RE

.SH EXAMPLE CODE
.PP
The following code is an example to use a B+ tree database.

.SH CLI
.PP
To use the B+ tree database API easily, the commands `\fBtcbtest\fR', `\fBtcbmttest\fR', and `\fBtcbmgr\fR' are provided.
.PP
The command `\fBtcbtest\fR' is a utility for facility test and performance test.  This command is used in the following format.  `\fIpath\fR' specifies the path of a database file.  `\fIrnum\fR' specifies the number of iterations.  `\fIlmemb\fR' specifies the number of members in each leaf page.  `\fInmemb\fR' specifies the number of members in each non\-leaf page.  `\fIbnum\fR' specifies the number of buckets.  `\fIapow\fR' specifies the power of the alignment.  `\fIfpow\fR' specifies the power of the free block pool.
.PP
.RS
.br
\fBtcbtest write \fR[\fB\-mt\fR]\fB \fR[\fB\-cd\fR|\fB\-ci\fR|\fB\-cj\fR]\fB \fR[\fB\-tl\fR]\fB \fR[\fB\-td\fR|\fB\-tb\fR|\fB\-tt\fR|\fB\-tx\fR]\fB \fR[\fB\-lc \fInum\fB\fR]\fB \fR[\fB\-nc \fInum\fB\fR]\fB \fR[\fB\-xm \fInum\fB\fR]\fB \fR[\fB\-ls \fInum\fB\fR]\fB \fR[\fB\-ca \fInum\fB\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-rnd\fR]\fB \fIpath\fB \fIrnum\fB \fR[\fB\fIlmemb\fB \fR[\fB\fInmemb\fB \fR[\fB\fIbnum\fB \fR[\fB\fIapow\fB \fR[\fB\fIfpow\fB\fR]\fB\fR]\fB\fR]\fB\fR]\fB\fR]\fB\fR
.RS
Store records with keys of 8 bytes.  They change as `00000001', `00000002'...
.RE
.br
\fBtcbtest read \fR[\fB\-mt\fR]\fB \fR[\fB\-cd\fR|\fB\-ci\fR|\fB\-cj\fR]\fB \fR[\fB\-lc \fInum\fB\fR]\fB \fR[\fB\-nc \fInum\fB\fR]\fB \fR[\fB\-xm \fInum\fB\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-wb\fR]\fB \fR[\fB\-rnd\fR]\fB \fIpath\fB\fR
.RS
Retrieve all records of the database above.
.RE
.br
\fBtcbtest remove \fR[\fB\-mt\fR]\fB \fR[\fB\-cd\fR|\fB\-ci\fR|\fB\-cj\fR]\fB \fR[\fB\-lc \fInum\fB\fR]\fB \fR[\fB\-nc \fInum\fB\fR]\fB \fR[\fB\-xm \fInum\fB\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-rnd\fR]\fB \fIpath\fB\fR
.RS
Remove all records of the database above.
.RE
.br
\fBtcbtest rcat \fR[\fB\-mt\fR]\fB \fR[\fB\-cd\fR|\fB\-ci\fR|\fB\-cj\fR]\fB \fR[\fB\-tl\fR]\fB \fR[\fB\-td\fR|\fB\-tb\fR|\fB\-tt\fR|\fB\-tx\fR]\fB \fR[\fB\-lc \fInum\fB\fR]\fB \fR[\fB\-nc \fInum\fB\fR]\fB \fR[\fB\-xm \fInum\fB\fR]\fB \fR[\fB\-ls \fInum\fB\fR]\fB \fR[\fB\-ca \fInum\fB\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-pn \fInum\fB\fR]\fB \fR[\fB\-dai\fR|\fB\-dad\fR|\fB\-rl\fR|\fB\-ru\fR]\fB \fIpath\fB \fIrnum\fB \fR[\fB\fIlmemb\fB \fR[\fB\fInmemb\fB \fR[\fB\fIbnum\fB \fR[\fB\fIapow\fB \fR[\fB\fIfpow\fB\fR]\fB\fR]\fB\fR]\fB\fR]\fB\fR]\fB\fR
.RS
Store records with partway duplicated keys using concatenate mode.
.RE
.br
\fBtcbtest queue \fR[\fB\-mt\fR]\fB \fR[\fB\-cd\fR|\fB\-ci\fR|\fB\-cj\fR]\fB \fR[\fB\-tl\fR]\fB \fR[\fB\-td\fR|\fB\-tb\fR|\fB\-tt\fR|\fB\-tx\fR]\fB \fR[\fB\-lc \fInum\fB\fR]\fB \fR[\fB\-nc \fInum\fB\fR]\fB \fR[\fB\-xm \fInum\fB\fR]\fB \fR[\fB\-ls \fInum\fB\fR]\fB \fR[\fB\-ca \fInum\fB\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fIpath\fB \fIrnum\fB \fR[\fB\fIlmemb\fB \fR[\fB\fInmemb\fB \fR[\fB\fIbnum\fB \fR[\fB\fIapow\fB \fR[\fB\fIfpow\fB\fR]\fB\fR]\fB\fR]\fB\fR]\fB\fR]\fB\fR
.RS
Perform queueing and dequeueing.
.RE
.br
\fBtcbtest misc \fR[\fB\-mt\fR]\fB \fR[\fB\-tl\fR]\fB \fR[\fB\-td\fR|\fB\-tb\fR|\fB\-tt\fR|\fB\-tx\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fIpath\fB \fIrnum\fB\fR
.RS
Perform miscellaneous test of various operations.
.RE
.br
\fBtcbtest wicked \fR[\fB\-mt\fR]\fB \fR[\fB\-tl\fR]\fB \fR[\fB\-td\fR|\fB\-tb\fR|\fB\-tt\fR|\fB\-tx\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fIpath\fB \fIrnum\fB\fR
.RS
Perform updating operations selected at random.
.RE
.RE
.PP
Options feature the following.
.PP
.RS
\fB\-mt\fR : call the function `tchdbsetmutex'.
.br
\fB\-cd\fR : use the comparison function `tccmpdecimal'.
.br
\fB\-ci\fR : use the comparison function  `tccmpint32'.
.br
\fB\-cj\fR : use the comparison function  `tccmpint64'.
.br
\fB\-tl\fR : enable the option `BDBTLARGE'.
.br
\fB\-td\fR : enable the option `BDBTDEFLATE'.
.br
\fB\-tb\fR : enable the option `BDBTBZIP'.
.br
\fB\-tt\fR : enable the option `BDBTTCBS'.
.br
\fB\-tx\fR : enable the option `BDBTEXCODEC'.
.br
\fB\-lc \fInum\fR\fR : specify the number of cached leaf pages.
.br
\fB\-nc \fInum\fR\fR : specify the number of cached non\-leaf pages.
.br
\fB\-xm \fInum\fR\fR : specify the size of the extra mapped memory.
.br
\fB\-ls \fInum\fR\fR : specify the maximum size of each leaf page.
.br
\fB\-ca \fInum\fR\fR : specify the capacity number of records.
.br
\fB\-nl\fR : enable the option `BDBNOLCK'.
.br
\fB\-nb\fR : enable the option `BDBLCKNB'.
.br
\fB\-rnd\fR : select keys at random.
.br
\fB\-wb\fR : use the function `tcbdbget3' instead of `tcbdbget'.
.br
\fB\-pn \fInum\fR\fR : specify the number of patterns.
.br
\fB\-dai\fR : use the function `tcbdbaddint' instead of `tcbdbputcat'.
.br
\fB\-dad\fR : use the function `tcbdbadddouble' instead of `tcbdbputcat'.
.br
\fB\-rl\fR : set the length of values at random.
.br
\fB\-ru\fR : select update operations at random.
.br
.RE
.PP
This command returns 0 on success, another on failure.
.PP
The command `\fBtcbmttest\fR' is a utility for facility test and performance test.  This command is used in the following format.  `\fIpath\fR' specifies the path of a database file.  `\fItnum\fR' specifies the number of running threads.  `\fIrnum\fR' specifies the number of iterations.  `\fIlmemb\fR' specifies the number of members in each leaf page.  `\fInmemb\fR' specifies the number of members in each non\-leaf page.  `\fIbnum\fR' specifies the number of buckets.  `\fIapow\fR' specifies the power of the alignment.  `\fIfpow\fR' specifies the power of the free block pool.
.PP
.RS
.br
\fBtcbmttest write \fR[\fB\-tl\fR]\fB \fR[\fB\-td\fR|\fB\-tb\fR|\fB\-tt\fR|\fB\-tx\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-rnd\fR]\fB \fIpath\fB \fItnum\fB \fIrnum\fB \fR[\fB\fIlmemb\fB \fR[\fB\fInmemb\fB \fR[\fB\fIbnum\fB \fR[\fB\fIapow\fB \fR[\fB\fIfpow\fB\fR]\fB\fR]\fB\fR]\fB\fR]\fB\fR]\fB\fR
.RS
Store records with keys of 8 bytes.  They change as `00000001', `00000002'...
.RE
.br
\fBtcbmttest read \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-wb\fR]\fB \fR[\fB\-rnd\fR]\fB \fIpath\fB \fItnum\fB\fR
.RS
Retrieve all records of the database above.
.RE
.br
\fBtcbmttest remove \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-rnd\fR]\fB \fIpath\fB \fItnum\fB\fR
.RS
Remove all records of the database above.
.RE
.br
\fBtcbmttest wicked \fR[\fB\-tl\fR]\fB \fR[\fB\-td\fR|\fB\-tb\fR|\fB\-tt\fR|\fB\-tx\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-nc\fR]\fB \fIpath\fB \fItnum\fB \fIrnum\fB\fR
.RS
Perform updating operations selected at random.
.RE
.br
\fBtcbmttest typical \fR[\fB\-tl\fR]\fB \fR[\fB\-td\fR|\fB\-tb\fR|\fB\-tt\fR|\fB\-tx\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-nc\fR]\fB \fR[\fB\-rr \fInum\fB\fR]\fB \fIpath\fB \fItnum\fB \fIrnum\fB \fR[\fB\fIlmemb\fB \fR[\fB\fInmemb\fB \fR[\fB\fIbnum\fB \fR[\fB\fIapow\fB \fR[\fB\fIfpow\fB\fR]\fB\fR]\fB\fR]\fB\fR]\fB\fR]\fB\fR
.RS
Perform typical operations selected at random.
.RE
.br
\fBtcbmttest race \fR[\fB\-tl\fR]\fB \fR[\fB\-td\fR|\fB\-tb\fR|\fB\-tt\fR|\fB\-tx\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fIpath\fB \fItnum\fB \fIrnum\fB \fR[\fB\fIlmemb\fB \fR[\fB\fInmemb\fB \fR[\fB\fIbnum\fB \fR[\fB\fIapow\fB \fR[\fB\fIfpow\fB\fR]\fB\fR]\fB\fR]\fB\fR]\fB\fR]\fB\fR
.RS
Perform race condition test.
.RE
.RE
.PP
Options feature the following.
.PP
.RS
\fB\-tl\fR : enable the option `BDBTLARGE'.
.br
\fB\-td\fR : enable the option `BDBTDEFLATE'.
.br
\fB\-tb\fR : enable the option `BDBTBZIP'.
.br
\fB\-tt\fR : enable the option `BDBTTCBS'.
.br
\fB\-tx\fR : enable the option `BDBTEXCODEC'.
.br
\fB\-nl\fR : enable the option `BDBNOLCK'.
.br
\fB\-nb\fR : enable the option `BDBLCKNB'.
.br
\fB\-rnd\fR : select keys at random.
.br
\fB\-wb\fR : use the function `tchdbget3' instead of `tchdbget'.
.br
\fB\-nc\fR : omit the comparison test.
.br
\fB\-rr \fInum\fR\fR : specify the ratio of reading operation by percentage.
.br
.RE
.PP
This command returns 0 on success, another on failure.
.PP
The command `\fBtcbmgr\fR' is a utility for test and debugging of the B+ tree database API and its applications.  `\fIpath\fR' specifies the path of a database file.  `\fIlmemb\fR' specifies the number of members in each leaf page.  `\fInmemb\fR' specifies the number of members in each non\-leaf page.  `\fIbnum\fR' specifies the number of buckets.  `\fIapow\fR' specifies the power of the alignment.  `\fIfpow\fR' specifies the power of the free block pool.  `\fIkey\fR' specifies the key of a record.  `\fIvalue\fR' specifies the value of a record.  `\fIfile\fR' specifies the input file.
.PP
.RS
.br
\fBtcbmgr create \fR[\fB\-cd\fR|\fB\-ci\fR|\fB\-cj\fR]\fB \fR[\fB\-tl\fR]\fB \fR[\fB\-td\fR|\fB\-tb\fR|\fB\-tt\fR|\fB\-tx\fR]\fB \fIpath\fB \fR[\fB\fIlmemb\fB \fR[\fB\fInmemb\fB \fR[\fB\fIbnum\fB \fR[\fB\fIapow\fB \fR[\fB\fIfpow\fB\fR]\fB\fR]\fB\fR]\fB\fR]\fB\fR]\fB\fR
.RS
Create a database file.
.RE
.br
\fBtcbmgr inform \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fIpath\fB\fR
.RS
Print miscellaneous information to the standard output.
.RE
.br
\fBtcbmgr put \fR[\fB\-cd\fR|\fB\-ci\fR|\fB\-cj\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-sx\fR]\fB \fR[\fB\-dk\fR|\fB\-dc\fR|\fB\-dd\fR|\fB\-db\fR|\fB\-dai\fR|\fB\-dad\fR]\fB \fIpath\fB \fIkey\fB \fIvalue\fB\fR
.RS
Store a record.
.RE
.br
\fBtcbmgr out \fR[\fB\-cd\fR|\fB\-ci\fR|\fB\-cj\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-sx\fR]\fB \fIpath\fB \fIkey\fB\fR
.RS
Remove a record.
.RE
.br
\fBtcbmgr get \fR[\fB\-cd\fR|\fB\-ci\fR|\fB\-cj\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-sx\fR]\fB \fR[\fB\-px\fR]\fB \fR[\fB\-pz\fR]\fB \fIpath\fB \fIkey\fB\fR
.RS
Print the value of a record.
.RE
.br
\fBtcbmgr list \fR[\fB\-cd\fR|\fB\-ci\fR|\fB\-cj\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-m \fInum\fB\fR]\fB \fR[\fB\-bk\fR]\fB \fR[\fB\-pv\fR]\fB \fR[\fB\-px\fR]\fB \fR[\fB\-j \fIstr\fB\fR]\fB \fR[\fB\-rb \fIbkey\fB \fIekey\fB\fR]\fB \fR[\fB\-fm \fIstr\fB\fR]\fB \fIpath\fB\fR
.RS
Print keys of all records, separated by line feeds.
.RE
.br
\fBtcbmgr optimize \fR[\fB\-cd\fR|\fB\-ci\fR|\fB\-cj\fR]\fB \fR[\fB\-tl\fR]\fB \fR[\fB\-td\fR|\fB\-tb\fR|\fB\-tt\fR|\fB\-tx\fR]\fB \fR[\fB\-tz\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fIpath\fB \fR[\fB\fIlmemb\fB \fR[\fB\fInmemb\fB \fR[\fB\fIbnum\fB \fR[\fB\fIapow\fB \fR[\fB\fIfpow\fB\fR]\fB\fR]\fB\fR]\fB\fR]\fB\fR]\fB\fR
.RS
Optimize a database file.
.RE
.br
\fBtcbmgr importtsv \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-sc\fR]\fB \fIpath\fB \fR[\fB\fIfile\fB\fR]\fB\fR
.RS
Store records of TSV in each line of a file.
.RE
.br
\fBtcbmgr version\fR
.RS
Print the version information of Tokyo Cabinet.
.RE
.RE
.PP
Options feature the following.
.PP
.RS
\fB\-cd\fR : use the comparison function `tccmpdecimal'.
.br
\fB\-ci\fR : use the comparison function  `tccmpint32'.
.br
\fB\-cj\fR : use the comparison function  `tccmpint64'.
.br
\fB\-tl\fR : enable the option `BDBTLARGE'.
.br
\fB\-td\fR : enable the option `BDBTDEFLATE'.
.br
\fB\-tb\fR : enable the option `BDBTBZIP'.
.br
\fB\-tt\fR : enable the option `BDBTTCBS'.
.br
\fB\-tx\fR : enable the option `BDBTEXCODEC'.
.br
\fB\-nl\fR : enable the option `BDBNOLCK'.
.br
\fB\-nb\fR : enable the option `BDBLCKNB'.
.br
\fB\-sx\fR : the input data is evaluated as a hexadecimal data string.
.br
\fB\-dk\fR : use the function `tcbdbputkeep' instead of `tcbdbput'.
.br
\fB\-dc\fR : use the function `tcbdbputcat' instead of `tcbdbput'.
.br
\fB\-dd\fR : use the function `tcbdbputdup' instead of `tcbdbput'.
.br
\fB\-db\fR : use the function `tcbdbputdupback' instead of `tcbdbput'.
.br
\fB\-dai\fR : use the function `tcbdbaddint' instead of `tcbdbput'.
.br
\fB\-dad\fR : use the function `tcbdbadddouble' instead of `tcbdbput'.
.br
\fB\-px\fR : the output data is converted into a hexadecimal data string.
.br
\fB\-pz\fR : do not append line feed at the end of the output.
.br
\fB\-m \fInum\fR\fR : specify the maximum number of the output.
.br
\fB\-bk\fR : perform backword scanning.
.br
\fB\-pv\fR : print values of records also.
.br
\fB\-j \fIstr\fR\fR : specify the key where the cursor jump to.
.br
\fB\-rb \fIbkey\fR \fIekey\fR\fR : specify the range of keys.
.br
\fB\-fm \fIstr\fR\fR : specify the prefix of keys.
.br
\fB\-tz\fR : enable the option `UINT8_MAX'.
.br
\fB\-sc\fR : normalize keys as lower cases.
.br
.RE
.PP
This command returns 0 on success, another on failure.

.SH THE FIXED\-LENGTH DATABASE API
.PP
Fixed\-length database is a file containing an array of fixed\-length elements and is handled with the fixed\-length database API.  See `\fBtcfdb.h\fR' for the entire specification.

.SH DESCRIPTION
.PP
To use the fixed\-length database API, include `\fBtcutil.h\fR', `\fBtcfdb.h\fR', and related standard header files.  Usually, write the following description near the front of a source file.
.PP
.RS
.br
\fB#include <tcutil.h>\fR
.br
\fB#include <tcfdb.h>\fR
.br
\fB#include <stdlib.h>\fR
.br
\fB#include <stdbool.h>\fR
.br
\fB#include <stdint.h>\fR
.RE
.PP
Objects whose type is pointer to `\fBTCFDB\fR' are used to handle fixed\-length databases.  A fixed\-length database object is created with the function `\fBtcfdbnew\fR' and is deleted with the function `\fBtcfdbdel\fR'.  To avoid memory leak, it is important to delete every object when it is no longer in use.
.PP
Before operations to store or retrieve records, it is necessary to open a database file and connect the fixed\-length database object to it.  The function `\fBtcfdbopen\fR' is used to open a database file and the function `\fBtcfdbclose\fR' is used to close the database file.  To avoid data missing or corruption, it is important to close every database file when it is no longer in use.

.SH API
.PP
The function `tcfdberrmsg' is used in order to get the message string corresponding to an error code.
.PP
.RS
.br
\fBconst char *tcfdberrmsg(int \fIecode\fB);\fR
.RS
`\fIecode\fR' specifies the error code.
.RE
.RS
The return value is the message string of the error code.
.RE
.RE
.PP
The function `tcfdbnew' is used in order to create a fixed\-length database object.
.PP
.RS
.br
\fBTCFDB *tcfdbnew(void);\fR
.RS
The return value is the new fixed\-length database object.
.RE
.RE
.PP
The function `tcfdbdel' is used in order to delete a fixed\-length database object.
.PP
.RS
.br
\fBvoid tcfdbdel(TCFDB *\fIfdb\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object.
.RE
.RS
If the database is not closed, it is closed implicitly.  Note that the deleted object and its derivatives can not be used anymore.
.RE
.RE
.PP
The function `tcfdbecode' is used in order to get the last happened error code of a fixed\-length database object.
.PP
.RS
.br
\fBint tcfdbecode(TCFDB *\fIfdb\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object.
.RE
.RS
The return value is the last happened error code.
.RE
.RS
The following error codes are defined: `TCESUCCESS' for success, `TCETHREAD' for threading error, `TCEINVALID' for invalid operation, `TCENOFILE' for file not found, `TCENOPERM' for no permission, `TCEMETA' for invalid meta data, `TCERHEAD' for invalid record header, `TCEOPEN' for open error, `TCECLOSE' for close error, `TCETRUNC' for trunc error, `TCESYNC' for sync error, `TCESTAT' for stat error, `TCESEEK' for seek error, `TCEREAD' for read error, `TCEWRITE' for write error, `TCEMMAP' for mmap error, `TCELOCK' for lock error, `TCEUNLINK' for unlink error, `TCERENAME' for rename error, `TCEMKDIR' for mkdir error, `TCERMDIR' for rmdir error, `TCEKEEP' for existing record, `TCENOREC' for no record found, and `TCEMISC' for miscellaneous error.
.RE
.RE
.PP
The function `tcfdbsetmutex' is used in order to set mutual exclusion control of a fixed\-length database object for threading.
.PP
.RS
.br
\fBbool tcfdbsetmutex(TCFDB *\fIfdb\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object which is not opened.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
Note that the mutual exclusion control is needed if the object is shared by plural threads and this function should should be called before the database is opened.
.RE
.RE
.PP
The function `tcfdbtune' is used in order to set the tuning parameters of a fixed\-length database object.
.PP
.RS
.br
\fBbool tcfdbtune(TCFDB *\fIfdb\fB, int32_t \fIwidth\fB, int64_t \fIlimsiz\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object which is not opened.
.RE
.RS
`\fIwidth\fR' specifies the width of the value of each record.  If it is not more than 0, the default value is specified.  The default value is 255.
.RE
.RS
`\fIlimsiz\fR' specifies the limit size of the database file.  If it is not more than 0, the default value is specified.  The default value is 268435456.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
Note that the tuning parameters should be set before the database is opened.
.RE
.RE
.PP
The function `tcfdbopen' is used in order to open a database file and connect a fixed\-length database object.
.PP
.RS
.br
\fBbool tcfdbopen(TCFDB *\fIfdb\fB, const char *\fIpath\fB, int \fIomode\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object which is not opened.
.RE
.RS
`\fIpath\fR' specifies the path of the database file.
.RE
.RS
`\fIomode\fR' specifies the connection mode: `FDBOWRITER' as a writer, `FDBOREADER' as a reader.  If the mode is `FDBOWRITER', the following may be added by bitwise\-or: `FDBOCREAT', which means it creates a new database if not exist, `FDBOTRUNC', which means it creates a new database regardless if one exists.  Both of `FDBOREADER' and `FDBOWRITER' can be added to by bitwise\-or: `FDBONOLCK', which means it opens the database file without file locking, or `FDBOLCKNB', which means locking is performed without blocking.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tcfdbclose' is used in order to close a fixed\-length database object.
.PP
.RS
.br
\fBbool tcfdbclose(TCFDB *\fIfdb\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
Update of a database is assured to be written when the database is closed.  If a writer opens a database but does not close it appropriately, the database will be broken.
.RE
.RE
.PP
The function `tcfdbput' is used in order to store a record into a fixed\-length database object.
.PP
.RS
.br
\fBbool tcfdbput(TCFDB *\fIfdb\fB, int64_t \fIid\fB, const void *\fIvbuf\fB, int \fIvsiz\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object connected as a writer.
.RE
.RS
`\fIid\fR' specifies the ID number.  It should be more than 0.  If it is `FDBIDMIN', the minimum ID number of existing records is specified.  If it is `FDBIDPREV', the number less by one than the minimum ID number of existing records is specified.  If it is `FDBIDMAX', the maximum ID number of existing records is specified.  If it is `FDBIDNEXT', the number greater by one than the maximum ID number of existing records is specified.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.  If the size of the value is greater than the width tuning parameter of the database, the size is cut down to the width.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, it is overwritten.
.RE
.RE
.PP
The function `tcfdbput2' is used in order to store a record with a decimal key into a fixed\-length database object.
.PP
.RS
.br
\fBbool tcfdbput2(TCFDB *\fIfdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, const void *\fIvbuf\fB, int \fIvsiz\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object connected as a writer.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "prev", the number less by one than the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.  If it is "next", the number greater by one than the maximum ID number of existing records is specified.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.  If the size of the value is greater than the width tuning parameter of the database, the size is cut down to the width.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, it is overwritten.
.RE
.RE
.PP
The function `tcfdbput3' is used in order to store a string record with a decimal key into a fixed\-length database object.
.PP
.RS
.br
\fBbool tcfdbput3(TCFDB *\fIfdb\fB, const char *\fIkstr\fB, const void *\fIvstr\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object connected as a writer.
.RE
.RS
`\fIkstr\fR' specifies the string of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "prev", the number less by one than the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.  If it is "next", the number greater by one than the maximum ID number of existing records is specified.
.RE
.RS
`\fIvstr\fR' specifies the string of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, it is overwritten.
.RE
.RE
.PP
The function `tcfdbputkeep' is used in order to store a new record into a fixed\-length database object.
.PP
.RS
.br
\fBbool tcfdbputkeep(TCFDB *\fIfdb\fB, int64_t \fIid\fB, const void *\fIvbuf\fB, int \fIvsiz\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object connected as a writer.
.RE
.RS
`\fIid\fR' specifies the ID number.  It should be more than 0.  If it is `FDBIDMIN', the minimum ID number of existing records is specified.  If it is `FDBIDPREV', the number less by one than the minimum ID number of existing records is specified.  If it is `FDBIDMAX', the maximum ID number of existing records is specified.  If it is `FDBIDNEXT', the number greater by one than the maximum ID number of existing records is specified.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.  If the size of the value is greater than the width tuning parameter of the database, the size is cut down to the width.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, this function has no effect.
.RE
.RE
.PP
The function `tcfdbputkeep2' is used in order to store a new record with a decimal key into a fixed\-length database object.
.PP
.RS
.br
\fBbool tcfdbputkeep2(TCFDB *\fIfdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, const void *\fIvbuf\fB, int \fIvsiz\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object connected as a writer.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "prev", the number less by one than the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.  If it is "next", the number greater by one than the maximum ID number of existing records is specified.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.  If the size of the value is greater than the width tuning parameter of the database, the size is cut down to the width.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, this function has no effect.
.RE
.RE
.PP
The function `tcfdbputkeep3' is used in order to store a new string record with a decimal key into a fixed\-length database object.
.PP
.RS
.br
\fBbool tcfdbputkeep3(TCFDB *\fIfdb\fB, const char *\fIkstr\fB, const void *\fIvstr\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object connected as a writer.
.RE
.RS
`\fIkstr\fR' specifies the string of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "prev", the number less by one than the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.  If it is "next", the number greater by one than the maximum ID number of existing records is specified.
.RE
.RS
`\fIvstr\fR' specifies the string of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, this function has no effect.
.RE
.RE
.PP
The function `tcfdbputcat' is used in order to concatenate a value at the end of the existing record in a fixed\-length database object.
.PP
.RS
.br
\fBbool tcfdbputcat(TCFDB *\fIfdb\fB, int64_t \fIid\fB, const void *\fIvbuf\fB, int \fIvsiz\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object connected as a writer.
.RE
.RS
`\fIid\fR' specifies the ID number.  It should be more than 0.  If it is `FDBIDMIN', the minimum ID number of existing records is specified.  If it is `FDBIDPREV', the number less by one than the minimum ID number of existing records is specified.  If it is `FDBIDMAX', the maximum ID number of existing records is specified.  If it is `FDBIDNEXT', the number greater by one than the maximum ID number of existing records is specified.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.  If the size of the value is greater than the width tuning parameter of the database, the size is cut down to the width.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If there is no corresponding record, a new record is created.
.RE
.RE
.PP
The function `tcfdbputcat2' is used in order to concatenate a value with a decimal key in a fixed\-length database object.
.PP
.RS
.br
\fBbool tcfdbputcat2(TCFDB *\fIfdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, const void *\fIvbuf\fB, int \fIvsiz\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object connected as a writer.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "prev", the number less by one than the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.  If it is "next", the number greater by one than the maximum ID number of existing records is specified.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.  If the size of the value is greater than the width tuning parameter of the database, the size is cut down to the width.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If there is no corresponding record, a new record is created.
.RE
.RE
.PP
The function `tcfdbputcat3' is used in order to concatenate a string value with a decimal key in a fixed\-length database object.
.PP
.RS
.br
\fBbool tcfdbputcat3(TCFDB *\fIfdb\fB, const char *\fIkstr\fB, const void *\fIvstr\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object connected as a writer.
.RE
.RS
`\fIkstr\fR' specifies the string of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "prev", the number less by one than the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.  If it is "next", the number greater by one than the maximum ID number of existing records is specified.
.RE
.RS
`\fIvstr\fR' specifies the string of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If there is no corresponding record, a new record is created.
.RE
.RE
.PP
The function `tcfdbout' is used in order to remove a record of a fixed\-length database object.
.PP
.RS
.br
\fBbool tcfdbout(TCFDB *\fIfdb\fB, int64_t \fIid\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object connected as a writer.
.RE
.RS
`\fIid\fR' specifies the ID number.  It should be more than 0.  If it is `FDBIDMIN', the minimum ID number of existing records is specified.  If it is `FDBIDMAX', the maximum ID number of existing records is specified.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tcfdbout2' is used in order to remove a record with a decimal key of a fixed\-length database object.
.PP
.RS
.br
\fBbool tcfdbout2(TCFDB *\fIfdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object connected as a writer.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tcfdbout3' is used in order to remove a string record with a decimal key of a fixed\-length database object.
.PP
.RS
.br
\fBbool tcfdbout3(TCFDB *\fIfdb\fB, const char *\fIkstr\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object connected as a writer.
.RE
.RS
`\fIkstr\fR' specifies the string of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tcfdbget' is used in order to retrieve a record in a fixed\-length database object.
.PP
.RS
.br
\fBvoid *tcfdbget(TCFDB *\fIfdb\fB, int64_t \fIid\fB, int *\fIsp\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object.
.RE
.RS
`\fIid\fR' specifies the ID number.  It should be more than 0.  If it is `FDBIDMIN', the minimum ID number of existing records is specified.  If it is `FDBIDMAX', the maximum ID number of existing records is specified.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned if no record corresponds.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcfdbget2' is used in order to retrieve a record with a decimal key in a fixed\-length database object.
.PP
.RS
.br
\fBvoid *tcfdbget2(TCFDB *\fIfdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, int *\fIsp\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned if no record corresponds.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcfdbget3' is used in order to retrieve a string record with a decimal key in a fixed\-length database object.
.PP
.RS
.br
\fBchar *tcfdbget3(TCFDB *\fIfdb\fB, const char *\fIkstr\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.
.RE
.RS
If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned if no record corresponds.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcfdbget4' is used in order to retrieve a record in a fixed\-length database object and write the value into a buffer.
.PP
.RS
.br
\fBint tcfdbget4(TCFDB *\fIfdb\fB, int64_t \fIid\fB, void *\fIvbuf\fB, int \fImax\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object.
.RE
.RS
`\fIid\fR' specifies the ID number.  It should be more than 0.  If it is `FDBIDMIN', the minimum ID number of existing records is specified.  If it is `FDBIDMAX', the maximum ID number of existing records is specified.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the buffer into which the value of the corresponding record is written.
.RE
.RS
`\fImax\fR' specifies the size of the buffer.
.RE
.RS
If successful, the return value is the size of the written data, else, it is \-1.  \-1 is returned if no record corresponds to the specified key.
.RE
.RS
Note that an additional zero code is not appended at the end of the region of the writing buffer.
.RE
.RE
.PP
The function `tcfdbvsiz' is used in order to get the size of the value of a record in a fixed\-length database object.
.PP
.RS
.br
\fBint tcfdbvsiz(TCFDB *\fIfdb\fB, int64_t \fIid\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object.
.RE
.RS
`\fIid\fR' specifies the ID number.  It should be more than 0.  If it is `FDBIDMIN', the minimum ID number of existing records is specified.  If it is `FDBIDMAX', the maximum ID number of existing records is specified.
.RE
.RS
If successful, the return value is the size of the value of the corresponding record, else, it is \-1.
.RE
.RE
.PP
The function `tcfdbvsiz2' is used in order to get the size of the value with a decimal key in a fixed\-length database object.
.PP
.RS
.br
\fBint tcfdbvsiz2(TCFDB *\fIfdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
If successful, the return value is the size of the value of the corresponding record, else, it is \-1.
.RE
.RE
.PP
The function `tcfdbvsiz3' is used in order to get the size of the string value with a decimal key in a fixed\-length database object.
.PP
.RS
.br
\fBint tcfdbvsiz3(TCFDB *\fIfdb\fB, const char *\fIkstr\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the decimal key.  It should be more than 0.  If it is "min", the minimum ID number of existing records is specified.  If it is "max", the maximum ID number of existing records is specified.
.RE
.RS
If successful, the return value is the size of the value of the corresponding record, else, it is \-1.
.RE
.RE
.PP
The function `tcfdbiterinit' is used in order to initialize the iterator of a fixed\-length database object.
.PP
.RS
.br
\fBbool tcfdbiterinit(TCFDB *\fIfdb\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
The iterator is used in order to access the key of every record stored in a database.
.RE
.RE
.PP
The function `tcfdbiternext' is used in order to get the next ID number of the iterator of a fixed\-length database object.
.PP
.RS
.br
\fBuint64_t tcfdbiternext(TCFDB *\fIfdb\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object.
.RE
.RS
If successful, the return value is the next ID number of the iterator, else, it is 0.  0 is returned when no record is to be get out of the iterator.
.RE
.RS
It is possible to access every record by iteration of calling this function.  It is allowed to update or remove records whose keys are fetched while the iteration.  The order of this traversal access method is ascending of the ID number.
.RE
.RE
.PP
The function `tcfdbiternext2' is used in order to get the next decimay key of the iterator of a fixed\-length database object.
.PP
.RS
.br
\fBvoid *tcfdbiternext2(TCFDB *\fIfdb\fB, int *\fIsp\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the region of the next decimal key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  It is possible to access every record by iteration of calling this function.  It is allowed to update or remove records whose keys are fetched while the iteration.  The order of this traversal access method is ascending of the ID number.
.RE
.RE
.PP
The function `tcfdbiternext3' is used in order to get the next decimay key string of the iterator of a fixed\-length database object.
.PP
.RS
.br
\fBchar *tcfdbiternext3(TCFDB *\fIfdb\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object.
.RE
.RS
If successful, the return value is the string of the next decimal key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  It is possible to access every record by iteration of calling this function.  It is allowed to update or remove records whose keys are fetched while the iteration.  The order of this traversal access method is ascending of the ID number.
.RE
.RE
.PP
The function `tcfdbrange' is used in order to get range matching ID numbers in a fixed\-length database object.
.PP
.RS
.br
\fBuint64_t *tcfdbrange(TCFDB *\fIfdb\fB, int64_t \fIlower\fB, int64_t \fIupper\fB, int \fImax\fB, int *\fInp\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object.
.RE
.RS
`\fIlower\fR' specifies the lower limit of the range.  If it is `FDBIDMIN', the minimum ID is specified.
.RE
.RS
`\fIupper\fR' specifies the upper limit of the range.  If it is `FDBIDMAX', the maximum ID is specified.
.RE
.RS
`\fImax\fR' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.
.RE
.RS
`\fInp\fR' specifies the pointer to the variable into which the number of elements of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to an array of ID numbers of the corresponding records.  `NULL' is returned on failure.  This function does never fail and return an empty array even if no key corresponds.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcfdbrange2' is used in order to get range matching decimal keys in a fixed\-length database object.
.PP
.RS
.br
\fBTCLIST *tcfdbrange2(TCFDB *\fIfdb\fB, const void *\fIlbuf\fB, int \fIlsiz\fB, const void *\fIubuf\fB, int \fIusiz\fB, int \fImax\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object.
.RE
.RS
`\fIlbuf\fR' specifies the pointer to the region of the lower key.  If it is "min", the minimum ID number of existing records is specified.
.RE
.RS
`\fIlsiz\fR' specifies the size of the region of the lower key.
.RE
.RS
`\fIubuf\fR' specifies the pointer to the region of the upper key.  If it is "max", the maximum ID number of existing records is specified.
.RE
.RS
`\fIusiz\fR' specifies the size of the region of the upper key.
.RE
.RS
`\fImax\fR' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.
.RE
.RS
The return value is a list object of the corresponding decimal keys.  This function does never fail and return an empty list even if no key corresponds.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.
.RE
.RE
.PP
The function `tcfdbrange3' is used in order to get range matching decimal keys with strings in a fixed\-length database object.
.PP
.RS
.br
\fBTCLIST *tcfdbrange3(TCFDB *\fIfdb\fB, const char *\fIlstr\fB, const char *\fIustr\fB, int \fImax\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object.
.RE
.RS
`\fIlstr\fR' specifies the string of the lower key.  If it is "min", the minimum ID number of existing records is specified.
.RE
.RS
`\fIustr\fR' specifies the string of the upper key.  If it is "max", the maximum ID number of existing records is specified.
.RE
.RS
`\fImax\fR' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.
.RE
.RS
The return value is a list object of the corresponding decimal keys.  This function does never fail and return an empty list even if no key corresponds.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.
.RE
.RE
.PP
The function `tcfdbrange4' is used in order to get keys with an interval notation in a fixed\-length database object.
.PP
.RS
.br
\fBTCLIST *tcfdbrange4(TCFDB *\fIfdb\fB, const void *\fIibuf\fB, int \fIisiz\fB, int \fImax\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object.
.RE
.RS
`\fIibuf\fR' specifies the pointer to the region of the interval notation.
.RE
.RS
`\fIisiz\fR' specifies the size of the region of the interval notation.
.RE
.RS
`\fImax\fR' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.
.RE
.RS
The return value is a list object of the corresponding decimal keys.  This function does never fail and return an empty list even if no key corresponds.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.
.RE
.RE
.PP
The function `tcfdbrange5' is used in order to get keys with an interval notation string in a fixed\-length database object.
.PP
.RS
.br
\fBTCLIST *tcfdbrange5(TCFDB *\fIfdb\fB, const void *\fIistr\fB, int \fImax\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object.
.RE
.RS
`\fIistr\fR' specifies the pointer to the region of the interval notation string.
.RE
.RS
`\fImax\fR' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.
.RE
.RS
The return value is a list object of the corresponding decimal keys.  This function does never fail and return an empty list even if no key corresponds.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.
.RE
.RE
.PP
The function `tcfdbaddint' is used in order to add an integer to a record in a fixed\-length database object.
.PP
.RS
.br
\fBint tcfdbaddint(TCFDB *\fIfdb\fB, int64_t \fIid\fB, int \fInum\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object connected as a writer.
.RE
.RS
`\fIid\fR' specifies the ID number.  It should be more than 0.  If it is `FDBIDMIN', the minimum ID number of existing records is specified.  If it is `FDBIDPREV', the number less by one than the minimum ID number of existing records is specified.  If it is `FDBIDMAX', the maximum ID number of existing records is specified.  If it is `FDBIDNEXT', the number greater by one than the maximum ID number of existing records is specified.
.RE
.RS
`\fInum\fR' specifies the additional value.
.RE
.RS
If successful, the return value is the summation value, else, it is `INT_MIN'.
.RE
.RS
If the corresponding record exists, the value is treated as an integer and is added to.  If no record corresponds, a new record of the additional value is stored.
.RE
.RE
.PP
The function `tcfdbadddouble' is used in order to add a real number to a record in a fixed\-length database object.
.PP
.RS
.br
\fBdouble tcfdbadddouble(TCFDB *\fIfdb\fB, int64_t \fIid\fB, double \fInum\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object connected as a writer.
.RE
.RS
`\fIid\fR' specifies the ID number.  It should be more than 0.  If it is `FDBIDMIN', the minimum ID number of existing records is specified.  If it is `FDBIDPREV', the number less by one than the minimum ID number of existing records is specified.  If it is `FDBIDMAX', the maximum ID number of existing records is specified.  If it is `FDBIDNEXT', the number greater by one than the maximum ID number of existing records is specified.
.RE
.RS
`\fInum\fR' specifies the additional value.
.RE
.RS
If successful, the return value is the summation value, else, it is Not\-a\-Number.
.RE
.RS
If the corresponding record exists, the value is treated as a real number and is added to.  If no record corresponds, a new record of the additional value is stored.
.RE
.RE
.PP
The function `tcfdbsync' is used in order to synchronize updated contents of a fixed\-length database object with the file and the device.
.PP
.RS
.br
\fBbool tcfdbsync(TCFDB *\fIfdb\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object connected as a writer.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
This function is useful when another process connects to the same database file.
.RE
.RE
.PP
The function `tcfdboptimize' is used in order to optimize the file of a fixed\-length database object.
.PP
.RS
.br
\fBbool tcfdboptimize(TCFDB *\fIfdb\fB, int32_t \fIwidth\fB, int64_t \fIlimsiz\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object connected as a writer.
.RE
.RS
`\fIwidth\fR' specifies the width of the value of each record.  If it is not more than 0, the current setting is not changed.
.RE
.RS
`\fIlimsiz\fR' specifies the limit size of the database file.  If it is not more than 0, the current setting is not changed.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tcfdbvanish' is used in order to remove all records of a fixed\-length database object.
.PP
.RS
.br
\fBbool tcfdbvanish(TCFDB *\fIfdb\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object connected as a writer.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tcfdbcopy' is used in order to copy the database file of a fixed\-length database object.
.PP
.RS
.br
\fBbool tcfdbcopy(TCFDB *\fIfdb\fB, const char *\fIpath\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object.
.RE
.RS
`\fIpath\fR' specifies the path of the destination file.  If it begins with `@', the trailing substring is executed as a command line.
.RE
.RS
If successful, the return value is true, else, it is false.  False is returned if the executed command returns non\-zero code.
.RE
.RS
The database file is assured to be kept synchronized and not modified while the copying or executing operation is in progress.  So, this function is useful to create a backup file of the database file.
.RE
.RE
.PP
The function `tcfdbpath' is used in order to get the file path of a fixed\-length database object.
.PP
.RS
.br
\fBconst char *tcfdbpath(TCFDB *\fIfdb\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object.
.RE
.RS
The return value is the path of the database file or `NULL' if the object does not connect to any database file.
.RE
.RE
.PP
The function `tcfdbrnum' is used in order to get the number of records of a fixed\-length database object.
.PP
.RS
.br
\fBuint64_t tcfdbrnum(TCFDB *\fIfdb\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object.
.RE
.RS
The return value is the number of records or 0 if the object does not connect to any database file.
.RE
.RE
.PP
The function `tcfdbfsiz' is used in order to get the size of the database file of a fixed\-length database object.
.PP
.RS
.br
\fBuint64_t tcfdbfsiz(TCFDB *\fIfdb\fB);\fR
.RS
`\fIfdb\fR' specifies the fixed\-length database object.
.RE
.RS
The return value is the size of the database file or 0 if the object does not connect to any database file.
.RE
.RE

.SH EXAMPLE CODE
.PP
The following code is an example to use a hash database.

.SH CLI
.PP
To use the fixed\-length database API easily, the commands `\fBtcftest\fR', `\fBtcfmttest\fR', and `\fBtcfmgr\fR' are provided.
.PP
The command `\fBtcftest\fR' is a utility for facility test and performance test.  This command is used in the following format.  `\fIpath\fR' specifies the path of a database file.  `\fIrnum\fR' specifies the number of iterations.  `\fIwidth\fR' specifies the width of the value of each record.  `\fIlimsiz\fR' specifies the limit size of the database file.
.PP
.RS
.br
\fBtcftest write \fR[\fB\-mt\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-rnd\fR]\fB \fIpath\fB \fIrnum\fB \fR[\fB\fIwidth\fB \fR[\fB\fIlimsiz\fB\fR]\fB\fR]\fB\fR
.RS
Store records with keys of 8 bytes.  They change as `00000001', `00000002'...
.RE
.br
\fBtcftest read \fR[\fB\-mt\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-wb\fR]\fB \fR[\fB\-rnd\fR]\fB \fIpath\fB\fR
.RS
Retrieve all records of the database above.
.RE
.br
\fBtcftest remove \fR[\fB\-mt\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-rnd\fR]\fB \fIpath\fB\fR
.RS
Remove all records of the database above.
.RE
.br
\fBtcftest rcat \fR[\fB\-mt\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-pn \fInum\fB\fR]\fB \fR[\fB\-dai\fR|\fB\-dad\fR|\fB\-rl\fR]\fB \fIpath\fB \fIrnum\fB \fR[\fB\fIlimsiz\fB\fR]\fB\fR]\fB\fR
.RS
Store records with partway duplicated keys using concatenate mode.
.RE
.br
\fBtcftest misc \fR[\fB\-mt\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fIpath\fB \fIrnum\fB\fR
.RS
Perform miscellaneous test of various operations.
.RE
.br
\fBtcftest wicked \fR[\fB\-mt\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fIpath\fB \fIrnum\fB\fR
.RS
Perform updating operations selected at random.
.RE
.RE
.PP
Options feature the following.
.PP
.RS
\fB\-mt\fR : call the function `tcfdbsetmutex'.
.br
\fB\-nl\fR : enable the option `FDBNOLCK'.
.br
\fB\-nb\fR : enable the option `FDBLCKNB'.
.br
\fB\-rnd\fR : select keys at random.
.br
\fB\-wb\fR : use the function `tcfdbget4' instead of `tcfdbget2'.
.br
\fB\-pn \fInum\fR\fR : specify the number of patterns.
.br
\fB\-dai\fR : use the function `tcfdbaddint' instead of `tcfdbputcat'.
.br
\fB\-dad\fR : use the function `tcfdbadddouble' instead of `tcfdbputcat'.
.br
\fB\-rl\fR : set the length of values at random.
.br
.RE
.PP
This command returns 0 on success, another on failure.
.PP
The command `\fBtcfmttest\fR' is a utility for facility test under multi\-thread situation.  This command is used in the following format.  `\fIpath\fR' specifies the path of a database file.  `\fItnum\fR' specifies the number of running threads.  `\fIrnum\fR' specifies the number of iterations.  `\fIwidth\fR' specifies the width of the value of each record.  `\fIlimsiz\fR' specifies the limit size of the database file.
.PP
.RS
.br
\fBtcfmttest write \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-rnd\fR]\fB \fIpath\fB \fItnum\fB \fIrnum\fB \fR[\fB\fIwidth\fB \fR[\fB\fIlimsiz\fB\fR]\fB\fR]\fB\fR
.RS
Store records with keys of 8 bytes.  They change as `00000001', `00000002'...
.RE
.br
\fBtcfmttest read \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-wb\fR]\fB \fR[\fB\-rnd\fR]\fB \fIpath\fB \fItnum\fB\fR
.RS
Retrieve all records of the database above.
.RE
.br
\fBtcfmttest remove \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-rnd\fR]\fB \fIpath\fB \fItnum\fB\fR
.RS
Remove all records of the database above.
.RE
.br
\fBtcfmttest wicked \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-nc\fR]\fB \fIpath\fB \fItnum\fB \fIrnum\fB\fR
.RS
Perform updating operations selected at random.
.RE
.br
\fBtcfmttest typical \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-nc\fR]\fB \fR[\fB\-rr \fInum\fB\fR]\fB \fIpath\fB \fItnum\fB \fIrnum\fB \fR[\fB\fIwidth\fB \fR[\fB\fIlimsiz\fB\fR]\fB\fR]\fB\fR
.RS
Perform typical operations selected at random.
.RE
.RE
.PP
Options feature the following.
.PP
.RS
\fB\-nl\fR : enable the option `FDBNOLCK'.
.br
\fB\-nb\fR : enable the option `FDBLCKNB'.
.br
\fB\-rnd\fR : select keys at random.
.br
\fB\-wb\fR : use the function `tcfdbget4' instead of `tcfdbget2'.
.br
\fB\-nc\fR : omit the comparison test.
.br
\fB\-rr \fInum\fR\fR : specify the ratio of reading operation by percentage.
.br
.RE
.PP
This command returns 0 on success, another on failure.
.PP
The command `\fBtcfmgr\fR' is a utility for test and debugging of the fixed\-length database API and its applications.  `\fIpath\fR' specifies the path of a database file.  `\fIwidth\fR' specifies the width of the value of each record.  `\fIlimsiz\fR' specifies the limit size of the database file.  `\fIkey\fR' specifies the key of a record.  `\fIvalue\fR' specifies the value of a record.  `\fIfile\fR' specifies the input file.
.PP
.RS
.br
\fBtcfmgr create \fIpath\fB \fR[\fB\fIwidth\fB \fR[\fB\fIlimsiz\fB\fR]\fB\fR]\fB\fR
.RS
Create a database file.
.RE
.br
\fBtcfmgr inform \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fIpath\fB\fR
.RS
Print miscellaneous information to the standard output.
.RE
.br
\fBtcfmgr put \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-sx\fR]\fB \fR[\fB\-dk\fR|\fB\-dc\fR|\fB\-dai\fR|\fB\-dad\fR]\fB \fIpath\fB \fIkey\fB \fIvalue\fB\fR
.RS
Store a record.
.RE
.br
\fBtcfmgr out \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-sx\fR]\fB \fIpath\fB \fIkey\fB\fR
.RS
Remove a record.
.RE
.br
\fBtcfmgr get \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-sx\fR]\fB \fR[\fB\-px\fR]\fB \fR[\fB\-pz\fR]\fB \fIpath\fB \fIkey\fB\fR
.RS
Print the value of a record.
.RE
.br
\fBtcfmgr list \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-m \fInum\fB\fR]\fB \fR[\fB\-pv\fR]\fB \fR[\fB\-px\fR]\fB \fR[\fB\-rb \fIlkey\fB \fIukey\fB\fR]\fB \fR[\fB\-ri \fIstr\fB\fR]\fB \fIpath\fB\fR
.RS
Print keys of all records, separated by line feeds.
.RE
.br
\fBtcfmgr optimize \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fIpath\fB \fR[\fB\fIwidth\fB \fR[\fB\fIlimsiz\fB\fR]\fB\fR]\fB\fR
.RS
Optimize a database file.
.RE
.br
\fBtcfmgr importtsv \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-sc\fR]\fB \fIpath\fB \fR[\fB\fIfile\fB\fR]\fB\fR
.RS
Store records of TSV in each line of a file.
.RE
.br
\fBtcfmgr version\fR
.RS
Print the version information of Tokyo Cabinet.
.RE
.RE
.PP
Options feature the following.
.PP
.RS
\fB\-nl\fR : enable the option `FDBNOLCK'.
.br
\fB\-nb\fR : enable the option `FDBLCKNB'.
.br
\fB\-sx\fR : the input data is evaluated as a hexadecimal data string.
.br
\fB\-dk\fR : use the function `tcfdbputkeep' instead of `tcfdbput'.
.br
\fB\-dc\fR : use the function `tcfdbputcat' instead of `tcfdbput'.
.br
\fB\-dai\fR : use the function `tcfdbaddint' instead of `tcfdbput'.
.br
\fB\-dad\fR : use the function `tcfdbadddouble' instead of `tcfdbput'.
.br
\fB\-px\fR : the output data is converted into a hexadecimal data string.
.br
\fB\-pz\fR : do not append line feed at the end of the output.
.br
\fB\-m \fInum\fR\fR : specify the maximum number of the output.
.br
\fB\-pv\fR : print values of records also.
.br
\fB\-rb \fIlkey\fR \fIukey\fR\fR : specify the range of keys.
.br
\fB\-ri \fIstr\fR\fR : specify the interval notation of keys.
.br
\fB\-sc\fR : normalize keys as lower cases.
.br
.RE
.PP
This command returns 0 on success, another on failure.

.SH THE TABLE DATABASE API
.PP
Table database is a file containing records composed of the primary keys and arbitrary columns and is handled with the table database API.  See `\fBtctdb.h\fR' for the entire specification.

.SH DESCRIPTION
.PP
To use the table database API, include `\fBtcutil.h\fR', `\fBtctdb.h\fR', and related standard header files.  Usually, write the following description near the front of a source file.
.PP
.RS
.br
\fB#include <tcutil.h>\fR
.br
\fB#include <tctdb.h>\fR
.br
\fB#include <stdlib.h>\fR
.br
\fB#include <stdbool.h>\fR
.br
\fB#include <stdint.h>\fR
.RE
.PP
Objects whose type is pointer to `\fBTCTDB\fR' are used to handle table databases.  A table database object is created with the function `\fBtctdbnew\fR' and is deleted with the function `\fBtctdbdel\fR'.  To avoid memory leak, it is important to delete every object when it is no longer in use.
.PP
Before operations to store or retrieve records, it is necessary to open a database file and connect the table database object to it.  The function `\fBtctdbopen\fR' is used to open a database file and the function `\fBtctdbclose\fR' is used to close the database file.  To avoid data missing or corruption, it is important to close every database file when it is no longer in use.

.SH API
.PP
The function `tctdberrmsg' is used in order to get the message string corresponding to an error code.
.PP
.RS
.br
\fBconst char *tctdberrmsg(int \fIecode\fB);\fR
.RS
`\fIecode\fR' specifies the error code.
.RE
.RS
The return value is the message string of the error code.
.RE
.RE
.PP
The function `tctdbnew' is used in order to create a table database object.
.PP
.RS
.br
\fBTCTDB *tctdbnew(void);\fR
.RS
The return value is the new table database object.
.RE
.RE
.PP
The function `tctdbdel' is used in order to delete a table database object.
.PP
.RS
.br
\fBvoid tctdbdel(TCTDB *\fItdb\fB);\fR
.RS
`\fItdb\fR' specifies the table database object.
.RE
.RS
If the database is not closed, it is closed implicitly.  Note that the deleted object and its derivatives can not be used anymore.
.RE
.RE
.PP
The function `tctdbecode' is used in order to get the last happened error code of a table database object.
.PP
.RS
.br
\fBint tctdbecode(TCTDB *\fItdb\fB);\fR
.RS
`\fItdb\fR' specifies the table database object.
.RE
.RS
The return value is the last happened error code.
.RE
.RS
The following error code is defined: `TCESUCCESS' for success, `TCETHREAD' for threading error, `TCEINVALID' for invalid operation, `TCENOFILE' for file not found, `TCENOPERM' for no permission, `TCEMETA' for invalid meta data, `TCERHEAD' for invalid record header, `TCEOPEN' for open error, `TCECLOSE' for close error, `TCETRUNC' for trunc error, `TCESYNC' for sync error, `TCESTAT' for stat error, `TCESEEK' for seek error, `TCEREAD' for read error, `TCEWRITE' for write error, `TCEMMAP' for mmap error, `TCELOCK' for lock error, `TCEUNLINK' for unlink error, `TCERENAME' for rename error, `TCEMKDIR' for mkdir error, `TCERMDIR' for rmdir error, `TCEKEEP' for existing record, `TCENOREC' for no record found, and `TCEMISC' for miscellaneous error.
.RE
.RE
.PP
The function `tctdbsetmutex' is used in order to set mutual exclusion control of a table database object for threading.
.PP
.RS
.br
\fBbool tctdbsetmutex(TCTDB *\fItdb\fB);\fR
.RS
`\fItdb\fR' specifies the table database object which is not opened.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
Note that the mutual exclusion control is needed if the object is shared by plural threads and this function should should be called before the database is opened.
.RE
.RE
.PP
The function `tctdbtune' is used in order to set the tuning parameters of a table database object.
.PP
.RS
.br
\fBbool tctdbtune(TCTDB *\fItdb\fB, int64_t \fIbnum\fB, int8_t \fIapow\fB, int8_t \fIfpow\fB, uint8_t \fIopts\fB);\fR
.RS
`\fItdb\fR' specifies the table database object which is not opened.
.RE
.RS
`\fIbnum\fR' specifies the number of elements of the bucket array.  If it is not more than 0, the default value is specified.  The default value is 131071.  Suggested size of the bucket array is about from 0.5 to 4 times of the number of all records to be stored.
.RE
.RS
`\fIapow\fR' specifies the size of record alignment by power of 2.  If it is negative, the default value is specified.  The default value is 4 standing for 2^4=16.
.RE
.RS
`\fIfpow\fR' specifies the maximum number of elements of the free block pool by power of 2.  If it is negative, the default value is specified.  The default value is 10 standing for 2^10=1024.
.RE
.RS
`\fIopts\fR' specifies options by bitwise\-or: `TDBTLARGE' specifies that the size of the database can be larger than 2GB by using 64\-bit bucket array, `TDBTDEFLATE' specifies that each record is compressed with Deflate encoding, `TDBTBZIP' specifies that each record is compressed with BZIP2 encoding, `TDBTTCBS' specifies that each record is compressed with TCBS encoding.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
Note that the tuning parameters should be set before the database is opened.
.RE
.RE
.PP
The function `tctdbsetcache' is set the caching parameters of a table database object.
.PP
.RS
.br
\fBbool tctdbsetcache(TCTDB *\fItdb\fB, int32_t \fIrcnum\fB, int32_t \fIlcnum\fB, int32_t \fIncnum\fB);\fR
.RS
`\fItdb\fR' specifies the table database object which is not opened.
.RE
.RS
`\fIrcnum\fR' specifies the maximum number of records to be cached.  If it is not more than 0, the record cache is disabled.  It is disabled by default.
.RE
.RS
`\fIlcnum\fR' specifies the maximum number of leaf nodes to be cached.  If it is not more than 0, the default value is specified.  The default value is 2048.
.RE
.RS
`\fIncnum\fR' specifies the maximum number of non\-leaf nodes to be cached.  If it is not more than 0, the default value is specified.  The default value is 512.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
Note that the caching parameters should be set before the database is opened.  Leaf nodes and non\-leaf nodes are used in column indexes.
.RE
.RE
.PP
The function `tctdbsetxmsiz' is used in order to set the size of the extra mapped memory of a table database object.
.PP
.RS
.br
\fBbool tctdbsetxmsiz(TCTDB *\fItdb\fB, int64_t \fIxmsiz\fB);\fR
.RS
`\fItdb\fR' specifies the table database object which is not opened.
.RE
.RS
`\fIxmsiz\fR' specifies the size of the extra mapped memory.  If it is not more than 0, the extra mapped memory is disabled.  The default size is 67108864.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
Note that the mapping parameters should be set before the database is opened.
.RE
.RE
.PP
The function `tctdbopen' is used in order to open a database file and connect a table database object.
.PP
.RS
.br
\fBbool tctdbopen(TCTDB *\fItdb\fB, const char *\fIpath\fB, int \fIomode\fB);\fR
.RS
`\fItdb\fR' specifies the table database object which is not opened.
.RE
.RS
`\fIpath\fR' specifies the path of the database file.
.RE
.RS
`\fIomode\fR' specifies the connection mode: `TDBOWRITER' as a writer, `TDBOREADER' as a reader.  If the mode is `TDBOWRITER', the following may be added by bitwise\-or: `TDBOCREAT', which means it creates a new database if not exist, `TDBOTRUNC', which means it creates a new database regardless if one exists, `TDBOTSYNC', which means every transaction synchronizes updated contents with the device.  Both of `TDBOREADER' and `TDBOWRITER' can be added to by bitwise\-or: `TDBONOLCK', which means it opens the database file without file locking, or `TDBOLCKNB', which means locking is performed without blocking.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tctdbclose' is used in order to close a table database object.
.PP
.RS
.br
\fBbool tctdbclose(TCTDB *\fItdb\fB);\fR
.RS
`\fItdb\fR' specifies the table database object.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
Update of a database is assured to be written when the database is closed.  If a writer opens a database but does not close it appropriately, the database will be broken.
.RE
.RE
.PP
The function `tctdbput' is used in order to store a record into a table database object.
.PP
.RS
.br
\fBbool tctdbput(TCTDB *\fItdb\fB, const void *\fIpkbuf\fB, int \fIpksiz\fB, TCMAP *\fIcols\fB);\fR
.RS
`\fItdb\fR' specifies the table database object connected as a writer.
.RE
.RS
`\fIpkbuf\fR' specifies the pointer to the region of the primary key.
.RE
.RS
`\fIpksiz\fR' specifies the size of the region of the primary key.
.RE
.RS
`\fIcols\fR' specifies a map object containing columns.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, it is overwritten.
.RE
.RE
.PP
The function `tctdbput2' is used in order to store a string record into a table database object with a zero separated column string.
.PP
.RS
.br
\fBbool tctdbput2(TCTDB *\fItdb\fB, const void *\fIpkbuf\fB, int \fIpksiz\fB, const void *\fIcbuf\fB, int \fIcsiz\fB);\fR
.RS
`\fItdb\fR' specifies the table database object connected as a writer.
.RE
.RS
`\fIpkbuf\fR' specifies the pointer to the region of the primary key.
.RE
.RS
`\fIpksiz\fR' specifies the size of the region of the primary key.
.RE
.RS
`\fIcbuf\fR' specifies the pointer to the region of the zero separated column string where the name and the value of each column are situated one after the other.
.RE
.RS
`\fIcsiz\fR' specifies the size of the region of the column string.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, it is overwritten.
.RE
.RE
.PP
The function `tctdbput3' is used in order to store a string record into a table database object with a tab separated column string.
.PP
.RS
.br
\fBbool tctdbput3(TCTDB *\fItdb\fB, const char *\fIpkstr\fB, const char *\fIcstr\fB);\fR
.RS
`\fItdb\fR' specifies the table database object connected as a writer.
.RE
.RS
`\fIpkstr\fR' specifies the string of the primary key.
.RE
.RS
`\fIcstr\fR' specifies the string of the the tab separated column string where the name and the value of each column are situated one after the other.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, it is overwritten.
.RE
.RE
.PP
The function `tctdbputkeep' is used in order to store a new record into a table database object.
.PP
.RS
.br
\fBbool tctdbputkeep(TCTDB *\fItdb\fB, const void *\fIpkbuf\fB, int \fIpksiz\fB, TCMAP *\fIcols\fB);\fR
.RS
`\fItdb\fR' specifies the table database object connected as a writer.
.RE
.RS
`\fIpkbuf\fR' specifies the pointer to the region of the primary key.
.RE
.RS
`\fIpksiz\fR' specifies the size of the region of the primary key.
.RE
.RS
`\fIcols\fR' specifies a map object containing columns.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, this function has no effect.
.RE
.RE
.PP
The function `tctdbputkeep2' is used in order to store a new string record into a table database object with a zero separated column string.
.PP
.RS
.br
\fBbool tctdbputkeep2(TCTDB *\fItdb\fB, const void *\fIpkbuf\fB, int \fIpksiz\fB, const void *\fIcbuf\fB, int \fIcsiz\fB);\fR
.RS
`\fItdb\fR' specifies the table database object connected as a writer.
.RE
.RS
`\fIpkbuf\fR' specifies the pointer to the region of the primary key.
.RE
.RS
`\fIpksiz\fR' specifies the size of the region of the primary key.
.RE
.RS
`\fIcbuf\fR' specifies the pointer to the region of the zero separated column string where the name and the value of each column are situated one after the other.
.RE
.RS
`\fIcsiz\fR' specifies the size of the region of the column string.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, this function has no effect.
.RE
.RE
.PP
The function `tctdbputkeep3' is used in order to store a new string record into a table database object with a tab separated column string.
.PP
.RS
.br
\fBbool tctdbputkeep3(TCTDB *\fItdb\fB, const char *\fIpkstr\fB, const char *\fIcstr\fB);\fR
.RS
`\fItdb\fR' specifies the table database object connected as a writer.
.RE
.RS
`\fIpkstr\fR' specifies the string of the primary key.
.RE
.RS
`\fIcstr\fR' specifies the string of the the tab separated column string where the name and the value of each column are situated one after the other.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, this function has no effect.
.RE
.RE
.PP
The function `tctdbputcat' is used in order to concatenate columns of the existing record in a table database object.
.PP
.RS
.br
\fBbool tctdbputcat(TCTDB *\fItdb\fB, const void *\fIpkbuf\fB, int \fIpksiz\fB, TCMAP *\fIcols\fB);\fR
.RS
`\fItdb\fR' specifies the table database object connected as a writer.
.RE
.RS
`\fIpkbuf\fR' specifies the pointer to the region of the primary key.
.RE
.RS
`\fIpksiz\fR' specifies the size of the region of the primary key.
.RE
.RS
`\fIcols\fR' specifies a map object containing columns.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If there is no corresponding record, a new record is created.
.RE
.RE
.PP
The function `tctdbputcat2' is used in order to concatenate columns in a table database object with a zero separated column string.
.PP
.RS
.br
\fBbool tctdbputcat2(TCTDB *\fItdb\fB, const void *\fIpkbuf\fB, int \fIpksiz\fB, const void *\fIcbuf\fB, int \fIcsiz\fB);\fR
.RS
`\fItdb\fR' specifies the table database object connected as a writer.
.RE
.RS
`\fIpkbuf\fR' specifies the pointer to the region of the primary key.
.RE
.RS
`\fIpksiz\fR' specifies the size of the region of the primary key.
.RE
.RS
`\fIcbuf\fR' specifies the pointer to the region of the zero separated column string where the name and the value of each column are situated one after the other.
.RE
.RS
`\fIcsiz\fR' specifies the size of the region of the column string.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If there is no corresponding record, a new record is created.
.RE
.RE
.PP
The function `tctdbputcat3' is used in order to concatenate columns in a table database object with with a tab separated column string.
.PP
.RS
.br
\fBbool tctdbputcat3(TCTDB *\fItdb\fB, const char *\fIpkstr\fB, const char *\fIcstr\fB);\fR
.RS
`\fItdb\fR' specifies the table database object connected as a writer.
.RE
.RS
`\fIpkstr\fR' specifies the string of the primary key.
.RE
.RS
`\fIcstr\fR' specifies the string of the the tab separated column string where the name and the value of each column are situated one after the other.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If there is no corresponding record, a new record is created.
.RE
.RE
.PP
The function `tctdbout' is used in order to remove a record of a table database object.
.PP
.RS
.br
\fBbool tctdbout(TCTDB *\fItdb\fB, const void *\fIpkbuf\fB, int \fIpksiz\fB);\fR
.RS
`\fItdb\fR' specifies the table database object connected as a writer.
.RE
.RS
`\fIpkbuf\fR' specifies the pointer to the region of the primary key.
.RE
.RS
`\fIpksiz\fR' specifies the size of the region of the primary key.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tctdbout2' is used in order to remove a string record of a table database object.
.PP
.RS
.br
\fBbool tctdbout2(TCTDB *\fItdb\fB, const char *\fIpkstr\fB);\fR
.RS
`\fItdb\fR' specifies the table database object connected as a writer.
.RE
.RS
`\fIpkstr\fR' specifies the string of the primary key.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tctdbget' is used in order to retrieve a record in a table database object.
.PP
.RS
.br
\fBTCMAP *tctdbget(TCTDB *\fItdb\fB, const void *\fIpkbuf\fB, int \fIpksiz\fB);\fR
.RS
`\fItdb\fR' specifies the table database object.
.RE
.RS
`\fIpkbuf\fR' specifies the pointer to the region of the primary key.
.RE
.RS
`\fIpksiz\fR' specifies the size of the region of the primary key.
.RE
.RS
If successful, the return value is a map object of the columns of the corresponding record.  `NULL' is returned if no record corresponds.
.RE
.RS
Because the object of the return value is created with the function `tcmapnew', it should be deleted with the function `tcmapdel' when it is no longer in use.
.RE
.RE
.PP
The function `tctdbget2' is used in order to retrieve a record in a table database object as a zero separated column string.
.PP
.RS
.br
\fBchar *tctdbget2(TCTDB *\fItdb\fB, const void *\fIpkbuf\fB, int \fIpksiz\fB, int *\fIsp\fB);\fR
.RS
`\fItdb\fR' specifies the table database object.
.RE
.RS
`\fIpkbuf\fR' specifies the pointer to the region of the primary key.
.RE
.RS
`\fIpksiz\fR' specifies the size of the region of the primary key.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the region of the column string of the corresponding record.  `NULL' is returned if no record corresponds.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tctdbget3' is used in order to retrieve a string record in a table database object as a tab separated column string.
.PP
.RS
.br
\fBchar *tctdbget3(TCTDB *\fItdb\fB, const char *\fIpkstr\fB);\fR
.RS
`\fItdb\fR' specifies the table database object.
.RE
.RS
`\fIpkstr\fR' specifies the string of the primary key.
.RE
.RS
If successful, the return value is the tab separated column string of the corresponding record.  `NULL' is returned if no record corresponds.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tctdbvsiz' is used in order to get the size of the value of a record in a table database object.
.PP
.RS
.br
\fBint tctdbvsiz(TCTDB *\fItdb\fB, const void *\fIpkbuf\fB, int \fIpksiz\fB);\fR
.RS
`\fItdb\fR' specifies the table database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the primary key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the primary key.
.RE
.RS
If successful, the return value is the size of the value of the corresponding record, else, it is \-1.
.RE
.RE
.PP
The function `tctdbvsiz2' is used in order to get the size of the value of a string record in a table database object.
.PP
.RS
.br
\fBint tctdbvsiz2(TCTDB *\fItdb\fB, const char *\fIpkstr\fB);\fR
.RS
`\fItdb\fR' specifies the table database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the primary key.
.RE
.RS
If successful, the return value is the size of the value of the corresponding record, else, it is \-1.
.RE
.RE
.PP
The function `tctdbiterinit' is used in order to initialize the iterator of a table database object.
.PP
.RS
.br
\fBbool tctdbiterinit(TCTDB *\fItdb\fB);\fR
.RS
`\fItdb\fR' specifies the table database object.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
The iterator is used in order to access the primary key of every record stored in a database.
.RE
.RE
.PP
The function `tctdbiternext' is used in order to get the next primary key of the iterator of a table database object.
.PP
.RS
.br
\fBvoid *tctdbiternext(TCTDB *\fItdb\fB, int *\fIsp\fB);\fR
.RS
`\fItdb\fR' specifies the table database object.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the region of the next primary key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  It is possible to access every record by iteration of calling this function.  It is allowed to update or remove records whose keys are fetched while the iteration.  However, it is not assured if updating the database is occurred while the iteration.  Besides, the order of this traversal access method is arbitrary, so it is not assured that the order of storing matches the one of the traversal access.
.RE
.RE
.PP
The function `tctdbiternext2' is used in order to get the next primary key string of the iterator of a table database object.
.PP
.RS
.br
\fBchar *tctdbiternext2(TCTDB *\fItdb\fB);\fR
.RS
`\fItdb\fR' specifies the table database object.
.RE
.RS
If successful, the return value is the string of the next primary key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  It is possible to access every record by iteration of calling this function.  However, it is not assured if updating the database is occurred while the iteration.  Besides, the order of this traversal access method is arbitrary, so it is not assured that the order of storing matches the one of the traversal access.
.RE
.RE
.PP
The function `tctdbfwmkeys' is used in order to get forward matching primary keys in a table database object.
.PP
.RS
.br
\fBTCLIST *tctdbfwmkeys(TCTDB *\fItdb\fB, const void *\fIpbuf\fB, int \fIpsiz\fB, int \fImax\fB);\fR
.RS
`\fItdb\fR' specifies the table database object.
.RE
.RS
`\fIpbuf\fR' specifies the pointer to the region of the prefix.
.RE
.RS
`\fIpsiz\fR' specifies the size of the region of the prefix.
.RE
.RS
`\fImax\fR' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.
.RE
.RS
The return value is a list object of the corresponding keys.  This function does never fail and return an empty list even if no key corresponds.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.
.RE
.RE
.PP
The function `tctdbfwmkeys2' is used in order to get forward matching string primary keys in a table database object.
.PP
.RS
.br
\fBTCLIST *tctdbfwmkeys2(TCTDB *\fItdb\fB, const char *\fIpstr\fB, int \fImax\fB);\fR
.RS
`\fItdb\fR' specifies the table database object.
.RE
.RS
`\fIpstr\fR' specifies the string of the prefix.
.RE
.RS
`\fImax\fR' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.
.RE
.RS
The return value is a list object of the corresponding keys.  This function does never fail and return an empty list even if no key corresponds.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.
.RE
.RE
.PP
The function `tctdbaddint' is used in order to add an integer to a column of a record in a table database object.
.PP
.RS
.br
\fBint tctdbaddint(TCTDB *\fItdb\fB, const void *\fIpkbuf\fB, int \fIpksiz\fB, int \fInum\fB);\fR
.RS
`\fItdb\fR' specifies the table database object connected as a writer.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the primary key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the primary key.
.RE
.RS
`\fInum\fR' specifies the additional value.
.RE
.RS
If successful, the return value is the summation value, else, it is `INT_MIN'.
.RE
.RS
The additional value is stored as a decimal string value of a column whose name is "_num".  If no record corresponds, a new record with the additional value is stored.
.RE
.RE
.PP
The function `tctdbadddouble' is used in order to add a real number to a column of a record in a table database object.
.PP
.RS
.br
\fBdouble tctdbadddouble(TCTDB *\fItdb\fB, const void *\fIpkbuf\fB, int \fIpksiz\fB, double \fInum\fB);\fR
.RS
`\fItdb\fR' specifies the table database object connected as a writer.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the primary key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the primary key.
.RE
.RS
`\fInum\fR' specifies the additional value.
.RE
.RS
If successful, the return value is the summation value, else, it is Not\-a\-Number.
.RE
.RS
The additional value is stored as a decimal string value of a column whose name is "_num".  If no record corresponds, a new record with the additional value is stored.
.RE
.RE
.PP
The function `tctdbsync' is used in order to synchronize updated contents of a table database object with the file and the device.
.PP
.RS
.br
\fBbool tctdbsync(TCTDB *\fItdb\fB);\fR
.RS
`\fItdb\fR' specifies the table database object connected as a writer.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
This function is useful when another process connects to the same database file.
.RE
.RE
.PP
The function `tctdboptimize' is used in order to optimize the file of a table database object.
.PP
.RS
.br
\fBbool tctdboptimize(TCTDB *\fItdb\fB, int64_t \fIbnum\fB, int8_t \fIapow\fB, int8_t \fIfpow\fB, uint8_t \fIopts\fB);\fR
.RS
`\fItdb\fR' specifies the table database object connected as a writer.
.RE
.RS
`\fIbnum\fR' specifies the number of elements of the bucket array.  If it is not more than 0, the default value is specified.  The default value is two times of the number of records.
.RE
.RS
`\fIapow\fR' specifies the size of record alignment by power of 2.  If it is negative, the current setting is not changed.
.RE
.RS
`\fIfpow\fR' specifies the maximum number of elements of the free block pool by power of 2.  If it is negative, the current setting is not changed.
.RE
.RS
`\fIopts\fR' specifies options by bitwise\-or: `TDBTLARGE' specifies that the size of the database can be larger than 2GB by using 64\-bit bucket array, `TDBTDEFLATE' specifies that each record is compressed with Deflate encoding, `TDBTBZIP' specifies that each record is compressed with BZIP2 encoding, `TDBTTCBS' specifies that each record is compressed with TCBS encoding.  If it is `UINT8_MAX', the current setting is not changed.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
This function is useful to reduce the size of the database file with data fragmentation by successive updating.
.RE
.RE
.PP
The function `tctdbvanish' is used in order to remove all records of a table database object.
.PP
.RS
.br
\fBbool tctdbvanish(TCTDB *\fItdb\fB);\fR
.RS
`\fItdb\fR' specifies the table database object connected as a writer.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tctdbcopy' is used in order to copy the database file of a table database object.
.PP
.RS
.br
\fBbool tctdbcopy(TCTDB *\fItdb\fB, const char *\fIpath\fB);\fR
.RS
`\fItdb\fR' specifies the table database object.
.RE
.RS
`\fIpath\fR' specifies the path of the destination file.  If it begins with `@', the trailing substring is executed as a command line.
.RE
.RS
If successful, the return value is true, else, it is false.  False is returned if the executed command returns non\-zero code.
.RE
.RS
The database file is assured to be kept synchronized and not modified while the copying or executing operation is in progress.  So, this function is useful to create a backup file of the database file.
.RE
.RE
.PP
The function `tctdbtranbegin' is used in order to begin the transaction of a table database object.
.PP
.RS
.br
\fBbool tctdbtranbegin(TCTDB *\fItdb\fB);\fR
.RS
`\fItdb\fR' specifies the table database object connected as a writer.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
The database is locked by the thread while the transaction so that only one transaction can be activated with a database object at the same time.  Thus, the serializable isolation level is assumed if every database operation is performed in the transaction.  Because all pages are cached on memory while the transaction, the amount of referred records is limited by the memory capacity.  If the database is closed during transaction, the transaction is aborted implicitly.
.RE
.RE
.PP
The function `tctdbtrancommit' is used in order to commit the transaction of a table database object.
.PP
.RS
.br
\fBbool tctdbtrancommit(TCTDB *\fItdb\fB);\fR
.RS
`\fItdb\fR' specifies the table database object connected as a writer.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
Update in the transaction is fixed when it is committed successfully.
.RE
.RE
.PP
The function `tctdbtranabort' is used in order to abort the transaction of a table database object.
.PP
.RS
.br
\fBbool tctdbtranabort(TCTDB *\fItdb\fB);\fR
.RS
`\fItdb\fR' specifies the table database object connected as a writer.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
Update in the transaction is discarded when it is aborted.  The state of the database is rollbacked to before transaction.
.RE
.RE
.PP
The function `tctdbpath' is used in order to get the file path of a table database object.
.PP
.RS
.br
\fBconst char *tctdbpath(TCTDB *\fItdb\fB);\fR
.RS
`\fItdb\fR' specifies the table database object.
.RE
.RS
The return value is the path of the database file or `NULL' if the object does not connect to any database file.
.RE
.RE
.PP
The function `tctdbrnum' is used in order to get the number of records ccccof a table database object.
.PP
.RS
.br
\fBuint64_t tctdbrnum(TCTDB *\fItdb\fB);\fR
.RS
`\fItdb\fR' specifies the table database object.
.RE
.RS
The return value is the number of records or 0 if the object does not connect to any database file.
.RE
.RE
.PP
The function `tctdbfsiz' is used in order to get the size of the database file of a table database object.
.PP
.RS
.br
\fBuint64_t tctdbfsiz(TCTDB *\fItdb\fB);\fR
.RS
`\fItdb\fR' specifies the table database object.
.RE
.RS
The return value is the size of the database file or 0 if the object does not connect to any database file.
.RE
.RE
.PP
The function `tctdbsetindex' is used in order to set a column index to a table database object.
.PP
.RS
.br
\fBbool tctdbsetindex(TCTDB *\fItdb\fB, const char *\fIname\fB, int \fItype\fB);\fR
.RS
`\fItdb\fR' specifies the table database object connected as a writer.
.RE
.RS
`\fIname\fR' specifies the name of a column.  If the name of an existing index is specified, the index is rebuilt.  An empty string means the primary key.
.RE
.RS
`\fItype\fR' specifies the index type: `TDBITLEXICAL' for lexical string, `TDBITDECIMAL' for decimal string.  If it is `TDBITOPT', the index is optimized.  If it is `TDBITVOID', the index is removed.  If `TDBITKEEP' is added by bitwise\-or and the index exists, this function merely returns failure.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
Note that the setting indexes should be set after the database is opened.
.RE
.RE
.PP
The function `tctdbgenuid' is used in order to generate a unique ID number of a table database object.
.PP
.RS
.br
\fBint64_t tctdbgenuid(TCTDB *\fItdb\fB);\fR
.RS
`\fItdb\fR' specifies the table database object connected as a writer.
.RE
.RS
The return value is the new unique ID number or \-1 on failure.
.RE
.RE
.PP
The function `tctdbqrynew' is used in order to create a query object.
.PP
.RS
.br
\fBTDBQRY *tctdbqrynew(TCTDB *\fItdb\fB);\fR
.RS
`\fItdb\fR' specifies the table database object.
.RE
.RS
The return value is the new query object.
.RE
.RE
.PP
The function `tctdbqrydel' is used in order to delete a query object.
.PP
.RS
.br
\fBvoid tctdbqrydel(TDBQRY *\fIqry\fB);\fR
.RS
`\fIqry\fR' specifies the query object.
.RE
.RE
.PP
The function `tctdbqryaddcond' is used in order to add a narrowing condition to a query object.
.PP
.RS
.br
\fBvoid tctdbqryaddcond(TDBQRY *\fIqry\fB, const char *\fIname\fB, int \fIop\fB, const char *\fIexpr\fB);\fR
.RS
`\fIqry\fR' specifies the query object.
.RE
.RS
`\fIname\fR' specifies the name of a column.  An empty string means the primary key.
.RE
.RS
`\fIop\fR' specifies an operation type: `TDBQCSTREQ' for string which is equal to the expression, `TDBQCSTRINC' for string which is included in the expression, `TDBQCSTRBW' for string which begins with the expression, `TDBQCSTREW' for string which ends with the expression, `TDBQCSTRAND' for string which includes all tokens in the expression, `TDBQCSTROR' for string which includes at least one token in the expression, `TDBQCSTROREQ' for string which is equal to at least one token in the expression, `TDBQCSTRRX' for string which matches regular expressions of the expression, `TDBQCNUMEQ' for number which is equal to the expression, `TDBQCNUMGT' for number which is greater than the expression, `TDBQCNUMGE' for number which is greater than or equal to the expression, `TDBQCNUMLT' for number which is less than the expression, `TDBQCNUMLE' for number which is less than or equal to the expression, `TDBQCNUMBT' for number which is between two tokens of the expression, `TDBQCNUMOREQ' for number which is equal to at least one token in the expression.  All operations can be flagged by bitwise\-or: `TDBQCNEGATE' for negation, `TDBQCNOIDX' for using no index.
.RE
.RS
`\fIexpr\fR' specifies an operand exression.
.RE
.RE
.PP
The function `tctdbqrysetorder' is used in order to set the order of a query object.
.PP
.RS
.br
\fBvoid tctdbqrysetorder(TDBQRY *\fIqry\fB, const char *\fIname\fB, int \fItype\fB);\fR
.RS
`\fIqry\fR' specifies the query object.
.RE
.RS
`\fIname\fR' specifies the name of a column.  An empty string means the primary key.
.RE
.RS
`\fItype\fR' specifies the order type: `TDBQOSTRASC' for string ascending, `TDBQOSTRDESC' for string descending, `TDBQONUMASC' for number ascending, `TDBQONUMDESC' for number descending.
.RE
.RE
.PP
The function `tctdbqrysetmax' is used in order to set the maximum number of records of the result of a query object.
.PP
.RS
.br
\fBvoid tctdbqrysetmax(TDBQRY *\fIqry\fB, int \fImax\fB);\fR
.RS
`\fIqry\fR' specifies the query object.
.RE
.RS
`\fImax\fR' specifies the maximum number of records of the result.
.RE
.RE
.PP
The function `tctdbqrysearch' is used in order to execute the search of a query object.
.PP
.RS
.br
\fBTCLIST *tctdbqrysearch(TDBQRY *\fIqry\fB);\fR
.RS
`\fIqry\fR' specifies the query object.
.RE
.RS
The return value is a list object of the primary keys of the corresponding records.  This function does never fail and return an empty list even if no record corresponds.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.
.RE
.RE
.PP
The function `tctdbqrysearchout' is used in order to remove each record corresponding to a query object.
.PP
.RS
.br
\fBbool tctdbqrysearchout(TDBQRY *\fIqry\fB);\fR
.RS
`\fIqry\fR' specifies the query object of the database connected as a writer.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tctdbqryproc' is used in order to process each record corresponding to a query object.
.PP
.RS
.br
\fBbool tctdbqryproc(TDBQRY *\fIqry\fB, TDBQRYPROC \fIproc\fB, void *\fIop\fB);\fR
.RS
`\fIqry\fR' specifies the query object of the database connected as a writer.
.RE
.RS
`\fIproc\fR' specifies the pointer to the iterator function called for each record.  It receives four parameters.  The first parameter is the pointer to the region of the primary key.  The second parameter is the size of the region of the primary key.  The third parameter is a map object containing columns.  The fourth parameter is the pointer to the optional opaque object.  It returns flags of the post treatment by bitwise\-or: `TDBQPPUT' to modify the record, `TDBQPOUT' to remove the record, `TDBQPSTOP' to stop the iteration.
.RE
.RS
`\fIop\fR' specifies an arbitrary pointer to be given as a parameter of the iterator function.  If it is not needed, `NULL' can be specified.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tctdbqryhint' is used in order to get the hint of a query object.
.PP
.RS
.br
\fBconst char *tctdbqryhint(TDBQRY *\fIqry\fB);\fR
.RS
`\fIqry\fR' specifies the query object.
.RE
.RS
The return value is the hint string.
.RE
.RE

.SH EXAMPLE CODE
.PP
The following code is an example to use a table database.

.SH CLI
.PP
To use the table database API easily, the commands `\fBtcttest\fR', `\fBtctmttest\fR', and `\fBtctmgr\fR' are provided.
.PP
The command `\fBtcttest\fR' is a utility for facility test and performance test.  This command is used in the following format.  `\fIpath\fR' specifies the path of a database file.  `\fIrnum\fR' specifies the number of iterations.  `\fIbnum\fR' specifies the number of buckets.  `\fIapow\fR' specifies the power of the alignment.  `\fIfpow\fR' specifies the power of the free block pool.
.PP
.RS
.br
\fBtcttest write \fR[\fB\-mt\fR]\fB \fR[\fB\-tl\fR]\fB \fR[\fB\-td\fR|\fB\-tb\fR|\fB\-tt\fR|\fB\-tx\fR]\fB \fR[\fB\-rc \fInum\fB\fR]\fB \fR[\fB\-lc \fInum\fB\fR]\fB \fR[\fB\-nc \fInum\fB\fR]\fB \fR[\fB\-xm \fInum\fB\fR]\fB \fR[\fB\-ip\fR]\fB \fR[\fB\-is\fR]\fB \fR[\fB\-in\fR]\fB \fR[\fB\-it\fR]\fB \fR[\fB\-if\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-rnd\fR]\fB \fIpath\fB \fIrnum\fB \fR[\fB\fIbnum\fB \fR[\fB\fIapow\fB \fR[\fB\fIfpow\fB\fR]\fB\fR]\fB\fR]\fB\fR
.RS
Store records with columns "str", "num", "type", and "flag".
.RE
.br
\fBtcttest read \fR[\fB\-mt\fR]\fB \fR[\fB\-rc \fInum\fB\fR]\fB \fR[\fB\-lc \fInum\fB\fR]\fB \fR[\fB\-nc \fInum\fB\fR]\fB \fR[\fB\-xm \fInum\fB\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-rnd\fR]\fB \fIpath\fB\fR
.RS
Retrieve all records of the database above.
.RE
.br
\fBtcttest remove \fR[\fB\-mt\fR]\fB \fR[\fB\-rc \fInum\fB\fR]\fB \fR[\fB\-lc \fInum\fB\fR]\fB \fR[\fB\-nc \fInum\fB\fR]\fB \fR[\fB\-xm \fInum\fB\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-rnd\fR]\fB \fIpath\fB\fR
.RS
Remove all records of the database above.
.RE
.br
\fBtcttest rcat \fR[\fB\-mt\fR]\fB \fR[\fB\-tl\fR]\fB \fR[\fB\-td\fR|\fB\-tb\fR|\fB\-tt\fR|\fB\-tx\fR]\fB \fR[\fB\-rc \fInum\fB\fR]\fB \fR[\fB\-lc \fInum\fB\fR]\fB \fR[\fB\-nc \fInum\fB\fR]\fB \fR[\fB\-xm \fInum\fB\fR]\fB \fR[\fB\-ip\fR]\fB \fR[\fB\-is\fR]\fB \fR[\fB\-in\fR]\fB \fR[\fB\-it\fR]\fB \fR[\fB\-if\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-pn \fInum\fB\fR]\fB \fR[\fB\-dai\fR|\fB\-dad\fR|\fB\-rl\fR|\fB\-ru\fR]\fB \fIpath\fB \fIrnum\fB \fR[\fB\fIbnum\fB \fR[\fB\fIapow\fB \fR[\fB\fIfpow\fB\fR]\fB\fR]\fB\fR]\fB\fR
.RS
Store records with partway duplicated keys using concatenate mode.
.RE
.br
\fBtcttest misc \fR[\fB\-mt\fR]\fB \fR[\fB\-tl\fR]\fB \fR[\fB\-td\fR|\fB\-tb\fR|\fB\-tt\fR|\fB\-tx\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fIpath\fB \fIrnum\fB\fR
.RS
Perform miscellaneous test of various operations.
.RE
.br
\fBtcttest wicked \fR[\fB\-mt\fR]\fB \fR[\fB\-tl\fR]\fB \fR[\fB\-td\fR|\fB\-tb\fR|\fB\-tt\fR|\fB\-tx\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fIpath\fB \fIrnum\fB\fR
.RS
Perform updating operations selected at random.
.RE
.RE
.PP
Options feature the following.
.PP
.RS
\fB\-mt\fR : call the function `tctdbsetmutex'.
.br
\fB\-tl\fR : enable the option `TDBTLARGE'.
.br
\fB\-td\fR : enable the option `TDBTDEFLATE'.
.br
\fB\-tb\fR : enable the option `TDBTBZIP'.
.br
\fB\-tt\fR : enable the option `TDBTTCBS'.
.br
\fB\-tx\fR : enable the option `TDBTEXCODEC'.
.br
\fB\-rc \fInum\fR\fR : specify the number of cached records.
.br
\fB\-lc \fInum\fR\fR : specify the number of cached leaf pages.
.br
\fB\-nc \fInum\fR\fR : specify the number of cached non\-leaf pages.
.br
\fB\-xm \fInum\fR\fR : specify the size of the extra mapped memory.
.br
\fB\-ip\fR : create the number index for the primary key.
.br
\fB\-is\fR : create the string index for the column "str".
.br
\fB\-in\fR : create the number index for the column "num".
.br
\fB\-it\fR : create the string index for the column "type".
.br
\fB\-if\fR : create the string index for the column "flag".
.br
\fB\-nl\fR : enable the option `TDBNOLCK'.
.br
\fB\-nb\fR : enable the option `TDBLCKNB'.
.br
\fB\-rnd\fR : select keys at random.
.br
\fB\-pn \fInum\fR\fR : specify the number of patterns.
.br
\fB\-dai\fR : use the function `tctdbaddint' instead of `tctdbputcat'.
.br
\fB\-dad\fR : use the function `tctdbadddouble' instead of `tctdbputcat'.
.br
\fB\-rl\fR : set the length of values at random.
.br
\fB\-ru\fR : select update operations at random.
.br
.RE
.PP
This command returns 0 on success, another on failure.
.PP
The command `\fBtctmttest\fR' is a utility for facility test under multi\-thread situation.  This command is used in the following format.  `\fIpath\fR' specifies the path of a database file.  `\fItnum\fR' specifies the number of running threads.  `\fIrnum\fR' specifies the number of iterations.  `\fIbnum\fR' specifies the number of buckets.  `\fIapow\fR' specifies the power of the alignment.  `\fIfpow\fR' specifies the power of the free block pool.
.PP
.RS
.br
\fBtctmttest write \fR[\fB\-tl\fR]\fB \fR[\fB\-td\fR|\fB\-tb\fR|\fB\-tt\fR|\fB\-tx\fR]\fB \fR[\fB\-rc \fInum\fB\fR]\fB \fR[\fB\-lc \fInum\fB\fR]\fB \fR[\fB\-nc \fInum\fB\fR]\fB \fR[\fB\-xm \fInum\fB\fR]\fB \fR[\fB\-ip\fR]\fB \fR[\fB\-is\fR]\fB \fR[\fB\-in\fR]\fB \fR[\fB\-it\fR]\fB \fR[\fB\-if\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-rnd\fR]\fB \fIpath\fB \fItnum\fB \fIrnum\fB \fR[\fB\fIbnum\fB \fR[\fB\fIapow\fB \fR[\fB\fIfpow\fB\fR]\fB\fR]\fB\fR]\fB\fR
.RS
Store records with columns "str", "num", "type", and "flag".
.RE
.br
\fBtctmttest read \fR[\fB\-rc \fInum\fB\fR]\fB \fR[\fB\-lc \fInum\fB\fR]\fB \fR[\fB\-nc \fInum\fB\fR]\fB \fR[\fB\-xm \fInum\fB\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-rnd\fR]\fB \fIpath\fB \fItnum\fB\fR
.RS
Retrieve all records of the database above.
.RE
.br
\fBtctmttest remove \fR[\fB\-rc \fInum\fB\fR]\fB \fR[\fB\-lc \fInum\fB\fR]\fB \fR[\fB\-nc \fInum\fB\fR]\fB \fR[\fB\-xm \fInum\fB\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-rnd\fR]\fB \fIpath\fB \fItnum\fB\fR
.RS
Remove all records of the database above.
.RE
.br
\fBtctmttest wicked \fR[\fB\-tl\fR]\fB \fR[\fB\-td\fR|\fB\-tb\fR|\fB\-tt\fR|\fB\-tx\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fIpath\fB \fItnum\fB \fIrnum\fB\fR
.RS
Perform updating operations selected at random.
.RE
.br
\fBtctmttest typical \fR[\fB\-tl\fR]\fB \fR[\fB\-td\fR|\fB\-tb\fR|\fB\-tt\fR|\fB\-tx\fR]\fB \fR[\fB\-rc \fInum\fB\fR]\fB \fR[\fB\-lc \fInum\fB\fR]\fB \fR[\fB\-nc \fInum\fB\fR]\fB \fR[\fB\-xm \fInum\fB\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-rr \fInum\fB\fR]\fB \fIpath\fB \fItnum\fB \fIrnum\fB \fR[\fB\fIbnum\fB \fR[\fB\fIapow\fB \fR[\fB\fIfpow\fB\fR]\fB\fR]\fB\fR
.RS
Perform typical operations selected at random.
.RE
.RE
.PP
Options feature the following.
.PP
.RS
\fB\-tl\fR : enable the option `TDBTLARGE'.
.br
\fB\-td\fR : enable the option `TDBTDEFLATE'.
.br
\fB\-tb\fR : enable the option `TDBTBZIP'.
.br
\fB\-tt\fR : enable the option `TDBTTCBS'.
.br
\fB\-tx\fR : enable the option `TDBTEXCODEC'.
.br
\fB\-rc \fInum\fR\fR : specify the number of cached records.
.br
\fB\-lc \fInum\fR\fR : specify the number of cached leaf pages.
.br
\fB\-nc \fInum\fR\fR : specify the number of cached non\-leaf pages.
.br
\fB\-xm \fInum\fR\fR : specify the size of the extra mapped memory.
.br
\fB\-ip\fR : create the number index for the primary key.
.br
\fB\-is\fR : create the string index for the column "str".
.br
\fB\-in\fR : create the number index for the column "num".
.br
\fB\-it\fR : create the string index for the column "type".
.br
\fB\-if\fR : create the string index for the column "flag".
.br
\fB\-nl\fR : enable the option `TDBNOLCK'.
.br
\fB\-nb\fR : enable the option `TDBLCKNB'.
.br
\fB\-rnd\fR : select keys at random.
.br
\fB\-nc\fR : omit the comparison test.
.br
\fB\-rr \fInum\fR\fR : specify the ratio of reading operation by percentage.
.br
.RE
.PP
This command returns 0 on success, another on failure.
.PP
The command `\fBtctmgr\fR' is a utility for test and debugging of the table database API and its applications.  `\fIpath\fR' specifies the path of a database file.  `\fIbnum\fR' specifies the number of buckets.  `\fIapow\fR' specifies the power of the alignment.  `\fIfpow\fR' specifies the power of the free block pool.  `\fIpkey\fR' specifies the primary key of a record.  `\fIcols\fR' specifies the names and the values of a record alternately.  `\fIname\fR' specifies the name of a column.  `\fIop\fR' specifies an operator.  `\fIexpr\fR' specifies the condition expression.  `\fIfile\fR' specifies the input file.
.PP
.RS
.br
\fBtctmgr create \fR[\fB\-tl\fR]\fB \fR[\fB\-td\fR|\fB\-tb\fR|\fB\-tt\fR|\fB\-tx\fR]\fB \fIpath\fB \fR[\fB\fIbnum\fB \fR[\fB\fIapow\fB \fR[\fB\fIfpow\fB\fR]\fB\fR]\fB\fR]\fB\fR
.RS
Create a database file.
.RE
.br
\fBtctmgr inform \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fIpath\fB\fR
.RS
Print miscellaneous information to the standard output.
.RE
.br
\fBtctmgr put \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-sx\fR]\fB \fR[\fB\-dk\fR|\fB\-dc\fR|\fB\-dai\fR|\fB\-dad\fR]\fB \fIpath\fB \fIpkey\fB \fR[\fB\fIcols\fB ...\fR]\fB\fR
.RS
Store a record.
.RE
.br
\fBtctmgr out \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-sx\fR]\fB \fIpath\fB \fIpkey\fB\fR
.RS
Remove a record.
.RE
.br
\fBtctmgr get \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-sx\fR]\fB \fR[\fB\-px\fR]\fB \fR[\fB\-pz\fR]\fB \fIpath\fB \fIpkey\fB\fR
.RS
Print the value of a record.
.RE
.br
\fBtctmgr list \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-m \fInum\fB\fR]\fB \fR[\fB\-pv\fR]\fB \fR[\fB\-px\fR]\fB \fR[\fB\-fm \fIstr\fB\fR]\fB \fIpath\fB\fR
.RS
Print the primary keys of all records, separated by line feeds.
.RE
.br
\fBtctmgr search \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-ord \fIname\fB \fItype\fB\fR]\fB \fR[\fB\-m \fInum\fB\fR]\fB \fR[\fB\-pv\fR]\fB \fR[\fB\-px\fR]\fB \fR[\fB\-ph\fR]\fB \fR[\fB\-bt \fInum\fB\fR]\fB \fR[\fB\-rm\fR]\fB \fIpath\fB \fR[\fB\fIname\fB \fIop\fB \fIexpr\fB ...\fR]\fB\fR
.RS
Print records matching conditions, separated by line feeds.
.RE
.br
\fBtctmgr optimize \fR[\fB\-tl\fR]\fB \fR[\fB\-td\fR|\fB\-tb\fR|\fB\-tt\fR|\fB\-tx\fR]\fB \fR[\fB\-tz\fR]\fB \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fIpath\fB \fR[\fB\fIbnum\fB \fR[\fB\fIapow\fB \fR[\fB\fIfpow\fB\fR]\fB\fR]\fB\fR]\fB\fR
.RS
Optimize a database file.
.RE
.br
\fBtctmgr setindex \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-it \fItype\fB\fR]\fB \fIpath\fB \fIname\fB\fR
.RS
Set the index of a column.
.RE
.br
\fBtctmgr importtsv \fR[\fB\-nl\fR|\fB\-nb\fR]\fB \fR[\fB\-sc\fR]\fB \fIpath\fB \fR[\fB\fIfile\fB\fR]\fB\fR
.RS
Store records of TSV in each line of a file.
.RE
.br
\fBtctmgr version\fR
.RS
Print the version information of Tokyo Cabinet.
.RE
.RE
.PP
Options feature the following.
.PP
.RS
\fB\-tl\fR : enable the option `TDBTLARGE'.
.br
\fB\-td\fR : enable the option `TDBTDEFLATE'.
.br
\fB\-tb\fR : enable the option `TDBTBZIP'.
.br
\fB\-tt\fR : enable the option `TDBTTCBS'.
.br
\fB\-tx\fR : enable the option `TDBTEXCODEC'.
.br
\fB\-nl\fR : enable the option `TDBNOLCK'.
.br
\fB\-nb\fR : enable the option `TDBLCKNB'.
.br
\fB\-sx\fR : the input data is evaluated as a hexadecimal data string.
.br
\fB\-dk\fR : use the function `tctdbputkeep' instead of `tctdbput'.
.br
\fB\-dc\fR : use the function `tctdbputcat' instead of `tctdbput'.
.br
\fB\-dai\fR : use the function `tctdbaddint' instead of `tctdbput'.
.br
\fB\-dad\fR : use the function `tctdbadddouble' instead of `tctdbput'.
.br
\fB\-px\fR : the output data is converted into a hexadecimal data string.
.br
\fB\-pz\fR : do not append line feed at the end of the output.
.br
\fB\-m \fInum\fR\fR : specify the maximum number of the output.
.br
\fB\-pv\fR : print values of records also.
.br
\fB\-fm \fIstr\fR\fR : specify the prefix of keys.
.br
\fB\-ord \fIname\fR \fItype\fR\fR : specify the order of the result.
.br
\fB\-ph\fR : print hint information also.
.br
\fB\-bt\fR : specify the number of benchmark tests.
.br
\fB\-rm\fR : remove every record in the result.
.br
\fB\-tz\fR : enable the option `UINT8_MAX'.
.br
\fB\-it \fItype\fR\fR : specify the index type among "lexical", "decimal", and "void".
.br
\fB\-cd\fR : create the number index instead of the string index.
.br
\fB\-cv\fR : remove the existing index.
.br
\fB\-sc\fR : normalize keys as lower cases.
.br
.RE
.PP
The operator of the `search' subcommand is one of "STREQ", "STRINC", "STRBW", "STREW", "STRAND", "STROR", "STROREQ", "STRRX", "NUMEQ", "NUMGT", "NUMGE", "NUMLT", "NUMLE", "NUMBT", and "NUMOREQ".  If "~" preposes each operator, the logical meaning is reversed.  If "+" preposes each operator, no index is used for the operator.  The type of the `\-ord' option is one of "STRASC", "STRDESC", "NUMASC", and "NUMDESC".  This command returns 0 on success, another on failure.

.SH THE ABSTRACT DATABASE API
.PP
Abstract database is a set of interfaces to use on\-memory hash database, on\-memory tree database, hash database, B+ tree database, fixed\-length database, and table database with the same API.  See `\fBtcadb.h\fR' for the entire specification.

.SH DESCRIPTION
.PP
To use the abstract database API, include `\fBtcutil.h\fR', `\fBtcadb.h\fR', and related standard header files.  Usually, write the following description near the front of a source file.
.PP
.RS
.br
\fB#include <tcutil.h>\fR
.br
\fB#include <tcadb.h>\fR
.br
\fB#include <stdlib.h>\fR
.br
\fB#include <stdbool.h>\fR
.br
\fB#include <stdint.h>\fR
.RE
.PP
Objects whose type is pointer to `\fBTCADB\fR' are used to handle abstract databases.  An abstract database object is created with the function `\fBtcadbnew\fR' and is deleted with the function `\fBtcadbdel\fR'.  To avoid memory leak, it is important to delete every object when it is no longer in use.
.PP
Before operations to store or retrieve records, it is necessary to connect the abstract database object to the concrete one.  The function `\fBtcadbopen\fR' is used to open a concrete database and the function `\fBtcadbclose\fR' is used to close the database.  To avoid data missing or corruption, it is important to close every database file when it is no longer in use.

.SH API
.PP
The function `tcadbnew' is used in order to create an abstract database object.
.PP
.RS
.br
\fBTCADB *tcadbnew(void);\fR
.RS
The return value is the new abstract database object.
.RE
.RE
.PP
The function `tcadbdel' is used in order to delete an abstract database object.
.PP
.RS
.br
\fBvoid tcadbdel(TCADB *\fIadb\fB);\fR
.RS
`\fIadb\fR' specifies the abstract database object.
.RE
.RE
.PP
The function `tcadbopen' is used in order to open an abstract database.
.PP
.RS
.br
\fBbool tcadbopen(TCADB *\fIadb\fB, const char *\fIname\fB);\fR
.RS
`\fIadb\fR' specifies the abstract database object.
.RE
.RS
`\fIname\fR' specifies the name of the database.  If it is "*", the database will be an on\-memory hash database.  If it is "+", the database will be an on\-memory tree database.  If its suffix is ".tch", the database will be a hash database.  If its suffix is ".tcb", the database will be a B+ tree database.  If its suffix is ".tcf", the database will be a fixed\-length database.  If its suffix is ".tct", the database will be a table database.  Otherwise, this function fails.  Tuning parameters can trail the name, separated by "#".  Each parameter is composed of the name and the value, separated by "=".  On\-memory hash database supports "bnum", "capnum", and "capsiz".  On\-memory tree database supports "capnum" and "capsiz".  Hash database supports "mode", "bnum", "apow", "fpow", "opts", "rcnum", and "xmsiz".  B+ tree database supports "mode", "lmemb", "nmemb", "bnum", "apow", "fpow", "opts", "lcnum", "ncnum", and "xmsiz".  Fixed\-length database supports "mode", "width", and "limsiz".  Table database supports "mode", "bnum", "apow", "fpow", "opts", "rcnum", "lcnum", "ncnum", "xmsiz", and "idx".
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
The tuning parameter "capnum" specifies the capacity number of records.  "capsiz" specifies the capacity size of using memory.  Records spilled the capacity are removed by the storing order.  "mode" can contain "w" of writer, "r" of reader, "c" of creating, "t" of truncating, "e" of no locking, and "f" of non\-blocking lock.  The default mode is relevant to "wc".  "opts" can contains "l" of large option, "d" of Deflate option, "b" of BZIP2 option, and "t" of TCBS option.  "idx" specifies the column name of an index and its type separated by ":".  For example, "casket.tch#bnum=1000000#opts=ld" means that the name of the database file is "casket.tch", and the bucket number is 1000000, and the options are large and Deflate.
.RE
.RE
.PP
The function `tcadbclose' is used in order to close an abstract database object.
.PP
.RS
.br
\fBbool tcadbclose(TCADB *\fIadb\fB);\fR
.RS
`\fIadb\fR' specifies the abstract database object.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
Update of a database is assured to be written when the database is closed.  If a writer opens a database but does not close it appropriately, the database will be broken.
.RE
.RE
.PP
The function `tcadbput' is used in order to store a record into an abstract database object.
.PP
.RS
.br
\fBbool tcadbput(TCADB *\fIadb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, const void *\fIvbuf\fB, int \fIvsiz\fB);\fR
.RS
`\fIadb\fR' specifies the abstract database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, it is overwritten.
.RE
.RE
.PP
The function `tcadbput2' is used in order to store a string record into an abstract object.
.PP
.RS
.br
\fBbool tcadbput2(TCADB *\fIadb\fB, const char *\fIkstr\fB, const char *\fIvstr\fB);\fR
.RS
`\fIadb\fR' specifies the abstract database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
`\fIvstr\fR' specifies the string of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, it is overwritten.
.RE
.RE
.PP
The function `tcadbputkeep' is used in order to store a new record into an abstract database object.
.PP
.RS
.br
\fBbool tcadbputkeep(TCADB *\fIadb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, const void *\fIvbuf\fB, int \fIvsiz\fB);\fR
.RS
`\fIadb\fR' specifies the abstract database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, this function has no effect.
.RE
.RE
.PP
The function `tcadbputkeep2' is used in order to store a new string record into an abstract database object.
.PP
.RS
.br
\fBbool tcadbputkeep2(TCADB *\fIadb\fB, const char *\fIkstr\fB, const char *\fIvstr\fB);\fR
.RS
`\fIadb\fR' specifies the abstract database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
`\fIvstr\fR' specifies the string of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, this function has no effect.
.RE
.RE
.PP
The function `tcadbputcat' is used in order to concatenate a value at the end of the existing record in an abstract database object.
.PP
.RS
.br
\fBbool tcadbputcat(TCADB *\fIadb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, const void *\fIvbuf\fB, int \fIvsiz\fB);\fR
.RS
`\fIadb\fR' specifies the abstract database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If there is no corresponding record, a new record is created.
.RE
.RE
.PP
The function `tcadbputcat2' is used in order to concatenate a string value at the end of the existing record in an abstract database object.
.PP
.RS
.br
\fBbool tcadbputcat2(TCADB *\fIadb\fB, const char *\fIkstr\fB, const char *\fIvstr\fB);\fR
.RS
`\fIadb\fR' specifies the abstract database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
`\fIvstr\fR' specifies the string of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If there is no corresponding record, a new record is created.
.RE
.RE
.PP
The function `tcadbout' is used in order to remove a record of an abstract database object.
.PP
.RS
.br
\fBbool tcadbout(TCADB *\fIadb\fB, const void *\fIkbuf\fB, int \fIksiz\fB);\fR
.RS
`\fIadb\fR' specifies the abstract database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tcadbout2' is used in order to remove a string record of an abstract database object.
.PP
.RS
.br
\fBbool tcadbout2(TCADB *\fIadb\fB, const char *\fIkstr\fB);\fR
.RS
`\fIadb\fR' specifies the abstract database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tcadbget' is used in order to retrieve a record in an abstract database object.
.PP
.RS
.br
\fBvoid *tcadbget(TCADB *\fIadb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, int *\fIsp\fB);\fR
.RS
`\fIadb\fR' specifies the abstract database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned if no record corresponds.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcadbget2' is used in order to retrieve a string record in an abstract database object.
.PP
.RS
.br
\fBchar *tcadbget2(TCADB *\fIadb\fB, const char *\fIkstr\fB);\fR
.RS
`\fIadb\fR' specifies the abstract database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned if no record corresponds.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcadbvsiz' is used in order to get the size of the value of a record in an abstract database object.
.PP
.RS
.br
\fBint tcadbvsiz(TCADB *\fIadb\fB, const void *\fIkbuf\fB, int \fIksiz\fB);\fR
.RS
`\fIadb\fR' specifies the abstract database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
If successful, the return value is the size of the value of the corresponding record, else, it is \-1.
.RE
.RE
.PP
The function `tcadbvsiz2' is used in order to get the size of the value of a string record in an abstract database object.
.PP
.RS
.br
\fBint tcadbvsiz2(TCADB *\fIadb\fB, const char *\fIkstr\fB);\fR
.RS
`\fIadb\fR' specifies the abstract database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
If successful, the return value is the size of the value of the corresponding record, else, it is \-1.
.RE
.RE
.PP
The function `tcadbiterinit' is used in order to initialize the iterator of an abstract database object.
.PP
.RS
.br
\fBbool tcadbiterinit(TCADB *\fIadb\fB);\fR
.RS
`\fIadb\fR' specifies the abstract database object.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
The iterator is used in order to access the key of every record stored in a database.
.RE
.RE
.PP
The function `tcadbiternext' is used in order to get the next key of the iterator of an abstract database object.
.PP
.RS
.br
\fBvoid *tcadbiternext(TCADB *\fIadb\fB, int *\fIsp\fB);\fR
.RS
`\fIadb\fR' specifies the abstract database object.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  It is possible to access every record by iteration of calling this function.  It is allowed to update or remove records whose keys are fetched while the iteration.  However, it is not assured if updating the database is occurred while the iteration.  Besides, the order of this traversal access method is arbitrary, so it is not assured that the order of storing matches the one of the traversal access.
.RE
.RE
.PP
The function `tcadbiternext2' is used in order to get the next key string of the iterator of an abstract database object.
.PP
.RS
.br
\fBchar *tcadbiternext2(TCADB *\fIadb\fB);\fR
.RS
`\fIadb\fR' specifies the abstract database object.
.RE
.RS
If successful, the return value is the string of the next key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  It is possible to access every record by iteration of calling this function.  However, it is not assured if updating the database is occurred while the iteration.  Besides, the order of this traversal access method is arbitrary, so it is not assured that the order of storing matches the one of the traversal access.
.RE
.RE
.PP
The function `tcadbfwmkeys' is used in order to get forward matching keys in an abstract database object.
.PP
.RS
.br
\fBTCLIST *tcadbfwmkeys(TCADB *\fIadb\fB, const void *\fIpbuf\fB, int \fIpsiz\fB, int \fImax\fB);\fR
.RS
`\fIadb\fR' specifies the abstract database object.
.RE
.RS
`\fIpbuf\fR' specifies the pointer to the region of the prefix.
.RE
.RS
`\fIpsiz\fR' specifies the size of the region of the prefix.
.RE
.RS
`\fImax\fR' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.
.RE
.RS
The return value is a list object of the corresponding keys.  This function does never fail and return an empty list even if no key corresponds.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.
.RE
.RE
.PP
The function `tcadbfwmkeys2' is used in order to get forward matching string keys in an abstract database object.
.PP
.RS
.br
\fBTCLIST *tcadbfwmkeys2(TCADB *\fIadb\fB, const char *\fIpstr\fB, int \fImax\fB);\fR
.RS
`\fIadb\fR' specifies the abstract database object.
.RE
.RS
`\fIpstr\fR' specifies the string of the prefix.
.RE
.RS
`\fImax\fR' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.
.RE
.RS
The return value is a list object of the corresponding keys.  This function does never fail and return an empty list even if no key corresponds.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Note that this function may be very slow because every key in the database is scanned.
.RE
.RE
.PP
The function `tcadbaddint' is used in order to add an integer to a record in an abstract database object.
.PP
.RS
.br
\fBint tcadbaddint(TCADB *\fIadb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, int \fInum\fB);\fR
.RS
`\fIadb\fR' specifies the abstract database object connected as a writer.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fInum\fR' specifies the additional value.
.RE
.RS
If successful, the return value is the summation value, else, it is `INT_MIN'.
.RE
.RS
If the corresponding record exists, the value is treated as an integer and is added to.  If no record corresponds, a new record of the additional value is stored.
.RE
.RE
.PP
The function `tcadbadddouble' is used in order to add a real number to a record in an abstract database object.
.PP
.RS
.br
\fBdouble tcadbadddouble(TCADB *\fIadb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, double \fInum\fB);\fR
.RS
`\fIadb\fR' specifies the abstract database object connected as a writer.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fInum\fR' specifies the additional value.
.RE
.RS
If successful, the return value is the summation value, else, it is Not\-a\-Number.
.RE
.RS
If the corresponding record exists, the value is treated as a real number and is added to.  If no record corresponds, a new record of the additional value is stored.
.RE
.RE
.PP
The function `tcadbsync' is used in order to synchronize updated contents of an abstract database object with the file and the device.
.PP
.RS
.br
\fBbool tcadbsync(TCADB *\fIadb\fB);\fR
.RS
`\fIadb\fR' specifies the abstract database object.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tcadbvanish' is used in order to remove all records of an abstract database object.
.PP
.RS
.br
\fBbool tcadbvanish(TCADB *\fIadb\fB);\fR
.RS
`\fIadb\fR' specifies the abstract database object.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tcadbcopy' is used in order to copy the database file of an abstract database object.
.PP
.RS
.br
\fBbool tcadbcopy(TCADB *\fIadb\fB, const char *\fIpath\fB);\fR
.RS
`\fIadb\fR' specifies the abstract database object.
.RE
.RS
`\fIpath\fR' specifies the path of the destination file.  If it begins with `@', the trailing substring is executed as a command line.
.RE
.RS
If successful, the return value is true, else, it is false.  False is returned if the executed command returns non\-zero code.
.RE
.RS
The database file is assured to be kept synchronized and not modified while the copying or executing operation is in progress.  So, this function is useful to create a backup file of the database file.
.RE
.RE
.PP
The function `tcadbrnum' is used in order to get the number of records of an abstract database object.
.PP
.RS
.br
\fBuint64_t tcadbrnum(TCADB *\fIadb\fB);\fR
.RS
`\fIadb\fR' specifies the abstract database object.
.RE
.RS
The return value is the number of records or 0 if the object does not connect to any database instance.
.RE
.RE
.PP
The function `tcadbsize' is used in order to get the size of the database of an abstract database object.
.PP
.RS
.br
\fBuint64_t tcadbsize(TCADB *\fIadb\fB);\fR
.RS
`\fIadb\fR' specifies the abstract database object.
.RE
.RS
The return value is the size of the database or 0 if the object does not connect to any database instance.
.RE
.RE
.PP
The function `tcadbmisc' is used in order to call a versatile function for miscellaneous operations of an abstract database object.
.PP
.RS
.br
\fBTCLIST *tcadbmisc(TCADB *\fIadb\fB, const char *\fIname\fB, const TCLIST *\fIargs\fB);\fR
.RS
`\fIadb\fR' specifies the abstract database object.
.RE
.RS
`\fIname\fR' specifies the name of the function.  All databases support "put", "out", "get", "putlist", "outlist", and "getlist".  "put" is to store a record.  It receives a key and a value, and returns an empty list.  "out" is to remove a record.  It receives a key, and returns an empty list.  "get" is to retrieve a record.  It receives a key, and returns a list of the values.  "putlist" is to store records.  It receives keys and values one after the other, and returns an empty list.  "outlist" is to remove records.  It receives keys, and returns an empty list.  "getlist" is to retrieve records.  It receives keys, and returns keys and values of corresponding records one after the other.
.RE
.RS
`\fIargs\fR' specifies a list object containing arguments.
.RE
.RS
If successful, the return value is a list object of the result.  `NULL' is returned on failure.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.
.RE
.RE

.SH EXAMPLE CODE
.PP
The following code is an example to use an abstract database.

.SH CLI
.PP
To use the abstract database API easily, the commands `\fBtcatest\fR' and `\fBtcamgr\fR' are provided.
.PP
The command `\fBtcatest\fR' is a utility for facility test and performance test.  This command is used in the following format.  `\fIname\fR' specifies the database name.  `\fIrnum\fR' specifies the number of iterations.  `\fItnum\fR' specifies the number of transactions.
.PP
.RS
.br
\fBtcatest write \fIname\fB \fIrnum\fB\fR
.RS
Store records with keys of 8 bytes.  They change as `00000001', `00000002'...
.RE
.br
\fBtcatest read \fIname\fB\fR
.RS
Retrieve all records of the database above.
.RE
.br
\fBtcatest remove \fIname\fB\fR
.RS
Remove all records of the database above.
.RE
.br
\fBtcatest rcat \fIname\fB \fIrnum\fB\fR
.RS
Store records with partway duplicated keys using concatenate mode.
.RE
.br
\fBtcatest misc \fIname\fB \fIrnum\fB\fR
.RS
Perform miscellaneous test of various operations.
.RE
.br
\fBtcatest wicked \fIname\fB \fIrnum\fB\fR
.RS
Perform updating operations of list and map selected at random.
.RE
.br
\fBtcatest compare \fIname\fB \fItnum\fB \fIrnum\fB\fR
.RS
Perform comparison test of database schema.
.RE
.RE
.PP
This command returns 0 on success, another on failure.
.PP
The command `\fBtcamgr\fR' is a utility for test and debugging of the abstract database API and its applications.  `\fIname\fR' specifies the name of a database.  `\fIkey\fR' specifies the key of a record.  `\fIvalue\fR' specifies the value of a record.  `\fIfunc\fR' specifies the name of a function.  `\fIarg\fR' specifies the arguments of the function.
.PP
.RS
.br
\fBtcamgr create \fIname\fB\fR
.RS
Create a database file.
.RE
.br
\fBtcamgr inform \fIname\fB\fR
.RS
Print miscellaneous information to the standard output.
.RE
.br
\fBtcamgr put \fR[\fB\-sx\fR]\fB \fR[\fB\-sep \fIchr\fB\fR]\fB \fR[\fB\-dk\fR|\fB\-dc\fR|\fB\-dai\fR|\fB\-dad\fR]\fB \fIname\fB \fIkey\fB \fIvalue\fB\fR
.RS
Store a record.
.RE
.br
\fBtcamgr out \fR[\fB\-sx\fR]\fB \fR[\fB\-sep \fIchr\fB\fR]\fB \fIname\fB \fIkey\fB\fR
.RS
Remove a record.
.RE
.br
\fBtcamgr get \fR[\fB\-sx\fR]\fB \fR[\fB\-sep \fIchr\fB\fR]\fB \fR[\fB\-px\fR]\fB \fR[\fB\-pz\fR]\fB \fIname\fB \fIkey\fB\fR
.RS
Print the value of a record.
.RE
.br
\fBtcamgr list \fR[\fB\-sep \fIchr\fB\fR]\fB \fR[\fB\-m \fInum\fB\fR]\fB \fR[\fB\-pv\fR]\fB \fR[\fB\-px\fR]\fB \fR[\fB\-fm \fIstr\fB\fR]\fB \fIname\fB\fR
.RS
Print keys of all records, separated by line feeds.
.RE
.br
\fBtcamgr misc \fR[\fB\-sx\fR]\fB \fR[\fB\-sep \fIchr\fB\fR]\fB \fR[\fB\-px\fR]\fB \fIname\fB \fIfunc\fB \fR[\fB\fIarg\fB...\fR]\fB\fR
.RS
Call a versatile function for miscellaneous operations.
.RE
.br
\fBtcamgr version\fR
.RS
Print the version information of Tokyo Cabinet.
.RE
.RE
.PP
Options feature the following.
.PP
.RS
\fB\-sx\fR : the input data is evaluated as a hexadecimal data string.
.br
\fB\-sep \fIchr\fR\fR : specify the separator of the input data.
.br
\fB\-dk\fR : use the function `tcadbputkeep' instead of `tcadbput'.
.br
\fB\-dc\fR : use the function `tcadbputcat' instead of `tcadbput'.
.br
\fB\-dai\fR : use the function `tcadbaddint' instead of `tcadbput'.
.br
\fB\-dad\fR : use the function `tcadbadddouble' instead of `tcadbput'.
.br
\fB\-px\fR : the output data is converted into a hexadecimal data string.
.br
\fB\-pz\fR : do not append line feed at the end of the output.
.br
\fB\-m \fInum\fR\fR : specify the maximum number of the output.
.br
\fB\-pv\fR : print values of records also.
.br
\fB\-fm \fIstr\fR\fR : specify the prefix of keys.
.br
.RE
.PP
This command returns 0 on success, another on failure.

.SH CGI
.PP
To use the abstract database API easily, the CGI script `\fBtcawmgr.cgi\fR' is provided.
.PP
The CGI script `\fBtcawmgr.cgi\fR' is a utility to browse and edit an abstract database by Web interface.  The database should be placed in the same directory of the CGI script and named as "\fBcasket.tch\fR", "\fBcasket.tcb\fR", or "\fBcasket.tcf\fR".  And, its permission should allow reading and writing by the user executing the CGI script.  Install the CGI script in a public directory of your Web server then you can start to use the CGI script by accessing the assigned URL.

.SH LICENSE
.PP
Tokyo Cabinet is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License or any later version.
.PP
Tokyo Cabinet is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
.PP
You should have received a copy of the GNU Lesser General Public License along with Tokyo Cabinet (See the file `\fBCOPYING\fR'); if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111\-1307 USA.
.PP
Tokyo Cabinet was written by Mikio Hirabayashi.  You can contact the author by e\-mail to `\fBmikio@users.sourceforge.net\fR'.

.SH SEE ALSO
.PP
.BR tcutil (3),
.BR tchdb (3),
.BR tcbdb (3)
.BR tcfdb (3)
.PP
Please see
.I http://tokyocabinet.sourceforge.net/spex-en.html
for detail.
